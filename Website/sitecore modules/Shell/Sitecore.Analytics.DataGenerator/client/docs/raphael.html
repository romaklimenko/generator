<!DOCTYPE html>

<html>
<head>
  <title>raphael.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="app.html">
                app.js
              </a>
            
              
              <a class="source" href="days-collection.html">
                days-collection.js
              </a>
            
              
              <a class="source" href="main.html">
                main.js
              </a>
            
              
              <a class="source" href="day-model.html">
                day-model.js
              </a>
            
              
              <a class="source" href="router.html">
                router.js
              </a>
            
              
              <a class="source" href="days-collection-test.html">
                days-collection-test.js
              </a>
            
              
              <a class="source" href="day-model-test.html">
                day-model-test.js
              </a>
            
              
              <a class="source" href="backbone.html">
                backbone.js
              </a>
            
              
              <a class="source" href="bootstrap.html">
                bootstrap.js
              </a>
            
              
              <a class="source" href="chai.html">
                chai.js
              </a>
            
              
              <a class="source" href="jquery.html">
                jquery.js
              </a>
            
              
              <a class="source" href="mocha.html">
                mocha.js
              </a>
            
              
              <a class="source" href="raphael.html">
                raphael.js
              </a>
            
              
              <a class="source" href="require.html">
                require.js
              </a>
            
              
              <a class="source" href="text.html">
                text.js
              </a>
            
              
              <a class="source" href="underscore.html">
                underscore.js
              </a>
            
              
              <a class="source" href="chart-view.html">
                chart-view.js
              </a>
            
              
              <a class="source" href="default-view.html">
                default-view.js
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>raphael.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <p>┌────────────────────────────────────────────────────────────────────┐ \
│ Raphaël 2.1.0 - JavaScript Vector Library                          │ \
├────────────────────────────────────────────────────────────────────┤ \
│ Copyright © 2008-2012 Dmitry Baranovskiy (<a href="http://raphaeljs.com">http://raphaeljs.com</a>)    │ \
│ Copyright © 2008-2012 Sencha Labs (<a href="http://sencha.com">http://sencha.com</a>)              │ \
├────────────────────────────────────────────────────────────────────┤ \
│ Licensed under the MIT (<a href="http://raphaeljs.com/license.html">http://raphaeljs.com/license.html</a>) license.│ \
└────────────────────────────────────────────────────────────────────┘ \
Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.</p>
<p>Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
you may not use this file except in compliance with the License.
You may obtain a copy of the License at</p>
<p><a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a></p>
<p>Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
┌────────────────────────────────────────────────────────────┐ \
│ Eve 0.4.2 - JavaScript Events Library                      │ \
├────────────────────────────────────────────────────────────┤ \
│ Author Dmitry Baranovskiy (<a href="http://dmitry.baranovskiy.com/">http://dmitry.baranovskiy.com/</a>) │ \
└────────────────────────────────────────────────────────────┘ \</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>(<span class="function"><span class="keyword">function</span> <span class="params">(glob)</span> {</span>
    <span class="keyword">var</span> version = <span class="string">"0.4.2"</span>,
        has = <span class="string">"hasOwnProperty"</span>,
        separator = <span class="regexp">/[\.\/]/</span>,
        wildcard = <span class="string">"*"</span>,
        fun = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>},
        numsort = <span class="function"><span class="keyword">function</span> <span class="params">(a, b)</span> {</span>
            <span class="keyword">return</span> a - b;
        },
        current_event,
        stop,
        events = {n: {}},
    <span class="comment">/*\
     * eve
     [ method ]

     * Fires event with given `name`, given scope and other parameters.

     &gt; Arguments

     - name (string) name of the *event*, dot (`.`) or slash (`/`) separated
     - scope (object) context for the event handlers
     - varargs (...) the rest of arguments will be sent to event handlers

     = (object) array of returned values from the listeners
    \*/</span>
        eve = <span class="function"><span class="keyword">function</span> <span class="params">(name, scope)</span> {</span>
			name = String(name);
            <span class="keyword">var</span> e = events,
                oldstop = stop,
                args = Array.prototype.slice.call(arguments, <span class="number">2</span>),
                listeners = eve.listeners(name),
                z = <span class="number">0</span>,
                f = <span class="literal">false</span>,
                l,
                indexed = [],
                queue = {},
                out = [],
                ce = current_event,
                errors = [];
            current_event = name;
            stop = <span class="number">0</span>;
            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, ii = listeners.length; i &lt; ii; i++) <span class="keyword">if</span> (<span class="string">"zIndex"</span> <span class="keyword">in</span> listeners[i]) {
                indexed.push(listeners[i].zIndex);
                <span class="keyword">if</span> (listeners[i].zIndex &lt; <span class="number">0</span>) {
                    queue[listeners[i].zIndex] = listeners[i];
                }
            }
            indexed.sort(numsort);
            <span class="keyword">while</span> (indexed[z] &lt; <span class="number">0</span>) {
                l = queue[indexed[z++]];
                out.push(l.apply(scope, args));
                <span class="keyword">if</span> (stop) {
                    stop = oldstop;
                    <span class="keyword">return</span> out;
                }
            }
            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ii; i++) {
                l = listeners[i];
                <span class="keyword">if</span> (<span class="string">"zIndex"</span> <span class="keyword">in</span> l) {
                    <span class="keyword">if</span> (l.zIndex == indexed[z]) {
                        out.push(l.apply(scope, args));
                        <span class="keyword">if</span> (stop) {
                            <span class="keyword">break</span>;
                        }
                        <span class="keyword">do</span> {
                            z++;
                            l = queue[indexed[z]];
                            l &amp;&amp; out.push(l.apply(scope, args));
                            <span class="keyword">if</span> (stop) {
                                <span class="keyword">break</span>;
                            }
                        } <span class="keyword">while</span> (l)
                    } <span class="keyword">else</span> {
                        queue[l.zIndex] = l;
                    }
                } <span class="keyword">else</span> {
                    out.push(l.apply(scope, args));
                    <span class="keyword">if</span> (stop) {
                        <span class="keyword">break</span>;
                    }
                }
            }
            stop = oldstop;
            current_event = ce;
            <span class="keyword">return</span> out.length ? out : <span class="literal">null</span>;
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>Undocumented. Debug only.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		eve._events = events;
    <span class="comment">/*\
     * eve.listeners
     [ method ]

     * Internal method which gives you array of all event handlers that will be triggered by the given `name`.

     &gt; Arguments

     - name (string) name of the event, dot (`.`) or slash (`/`) separated

     = (array) array of event handlers
    \*/</span>
    eve.listeners = <span class="function"><span class="keyword">function</span> <span class="params">(name)</span> {</span>
        <span class="keyword">var</span> names = name.split(separator),
            e = events,
            item,
            items,
            k,
            i,
            ii,
            j,
            jj,
            nes,
            es = [e],
            out = [];
        <span class="keyword">for</span> (i = <span class="number">0</span>, ii = names.length; i &lt; ii; i++) {
            nes = [];
            <span class="keyword">for</span> (j = <span class="number">0</span>, jj = es.length; j &lt; jj; j++) {
                e = es[j].n;
                items = [e[names[i]], e[wildcard]];
                k = <span class="number">2</span>;
                <span class="keyword">while</span> (k--) {
                    item = items[k];
                    <span class="keyword">if</span> (item) {
                        nes.push(item);
                        out = out.concat(item.f || []);
                    }
                }
            }
            es = nes;
        }
        <span class="keyword">return</span> out;
    };
    
    <span class="comment">/*\
     * eve.on
     [ method ]
     **
     * Binds given event handler with a given name. You can use wildcards “`*`” for the names:
     | eve.on("*.under.*", f);
     | eve("mouse.under.floor"); // triggers f
     * Use @eve to trigger the listener.
     **
     &gt; Arguments
     **
     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
     - f (function) event handler function
     **
     = (function) returned function accepts a single numeric parameter that represents z-index of the handler. It is an optional feature and only used when you need to ensure that some subset of handlers will be invoked in a given order, despite of the order of assignment. 
     &gt; Example:
     | eve.on("mouse", eatIt)(2);
     | eve.on("mouse", scream);
     | eve.on("mouse", catchIt)(1);
     * This will ensure that `catchIt()` function will be called before `eatIt()`.
	 *
     * If you want to put your handler before non-indexed handlers, specify a negative value.
     * Note: I assume most of the time you don’t need to worry about z-index, but it’s nice to have this feature “just in case”.
    \*/</span>
    eve.on = <span class="function"><span class="keyword">function</span> <span class="params">(name, f)</span> {</span>
		name = String(name);
		<span class="keyword">if</span> (<span class="keyword">typeof</span> f != <span class="string">"function"</span>) {
			<span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>};
		}
        <span class="keyword">var</span> names = name.split(separator),
            e = events;
        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, ii = names.length; i &lt; ii; i++) {
            e = e.n;
            e = e.hasOwnProperty(names[i]) &amp;&amp; e[names[i]] || (e[names[i]] = {n: {}});
        }
        e.f = e.f || [];
        <span class="keyword">for</span> (i = <span class="number">0</span>, ii = e.f.length; i &lt; ii; i++) <span class="keyword">if</span> (e.f[i] == f) {
            <span class="keyword">return</span> fun;
        }
        e.f.push(f);
        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(zIndex)</span> {</span>
            <span class="keyword">if</span> (+zIndex == +zIndex) {
                f.zIndex = +zIndex;
            }
        };
    };
    <span class="comment">/*\
     * eve.f
     [ method ]
     **
     * Returns function that will fire given event with optional arguments.
	 * Arguments that will be passed to the result function will be also
	 * concated to the list of final arguments.
 	 | el.onclick = eve.f("click", 1, 2);
 	 | eve.on("click", function (a, b, c) {
 	 |     console.log(a, b, c); // 1, 2, [event object]
 	 | });
     &gt; Arguments
	 - event (string) event name
	 - varargs (…) and any other arguments
	 = (function) possible event handler function
    \*/</span>
	eve.f = <span class="function"><span class="keyword">function</span> <span class="params">(event)</span> {</span>
		<span class="keyword">var</span> attrs = [].slice.call(arguments, <span class="number">1</span>);
		<span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
			eve.apply(<span class="literal">null</span>, [event, <span class="literal">null</span>].concat(attrs).concat([].slice.call(arguments, <span class="number">0</span>)));
		};
	};
    <span class="comment">/*\
     * eve.stop
     [ method ]
     **
     * Is used inside an event handler to stop the event, preventing any subsequent listeners from firing.
    \*/</span>
    eve.stop = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        stop = <span class="number">1</span>;
    };
    <span class="comment">/*\
     * eve.nt
     [ method ]
     **
     * Could be used inside event handler to figure out actual name of the event.
     **
     &gt; Arguments
     **
     - subname (string) #optional subname of the event
     **
     = (string) name of the event, if `subname` is not specified
     * or
     = (boolean) `true`, if current event’s name contains `subname`
    \*/</span>
    eve.nt = <span class="function"><span class="keyword">function</span> <span class="params">(subname)</span> {</span>
        <span class="keyword">if</span> (subname) {
            <span class="keyword">return</span> <span class="keyword">new</span> RegExp(<span class="string">"(?:\\.|\\/|^)"</span> + subname + <span class="string">"(?:\\.|\\/|$)"</span>).test(current_event);
        }
        <span class="keyword">return</span> current_event;
    };
    <span class="comment">/*\
     * eve.nts
     [ method ]
     **
     * Could be used inside event handler to figure out actual name of the event.
     **
     **
     = (array) names of the event
    \*/</span>
    eve.nts = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">return</span> current_event.split(separator);
    };
    <span class="comment">/*\
     * eve.off
     [ method ]
     **
     * Removes given function from the list of event listeners assigned to given name.
	 * If no arguments specified all the events will be cleared.
     **
     &gt; Arguments
     **
     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
     - f (function) event handler function
    \*/</span>
    <span class="comment">/*\
     * eve.unbind
     [ method ]
     **
     * See @eve.off
    \*/</span>
    eve.off = eve.unbind = <span class="function"><span class="keyword">function</span> <span class="params">(name, f)</span> {</span>
		<span class="keyword">if</span> (!name) {
		    eve._events = events = {n: {}};
			<span class="keyword">return</span>;
		}
        <span class="keyword">var</span> names = name.split(separator),
            e,
            key,
            splice,
            i, ii, j, jj,
            cur = [events];
        <span class="keyword">for</span> (i = <span class="number">0</span>, ii = names.length; i &lt; ii; i++) {
            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; cur.length; j += splice.length - <span class="number">2</span>) {
                splice = [j, <span class="number">1</span>];
                e = cur[j].n;
                <span class="keyword">if</span> (names[i] != wildcard) {
                    <span class="keyword">if</span> (e[names[i]]) {
                        splice.push(e[names[i]]);
                    }
                } <span class="keyword">else</span> {
                    <span class="keyword">for</span> (key <span class="keyword">in</span> e) <span class="keyword">if</span> (e[has](key)) {
                        splice.push(e[key]);
                    }
                }
                cur.splice.apply(cur, splice);
            }
        }
        <span class="keyword">for</span> (i = <span class="number">0</span>, ii = cur.length; i &lt; ii; i++) {
            e = cur[i];
            <span class="keyword">while</span> (e.n) {
                <span class="keyword">if</span> (f) {
                    <span class="keyword">if</span> (e.f) {
                        <span class="keyword">for</span> (j = <span class="number">0</span>, jj = e.f.length; j &lt; jj; j++) <span class="keyword">if</span> (e.f[j] == f) {
                            e.f.splice(j, <span class="number">1</span>);
                            <span class="keyword">break</span>;
                        }
                        !e.f.length &amp;&amp; <span class="keyword">delete</span> e.f;
                    }
                    <span class="keyword">for</span> (key <span class="keyword">in</span> e.n) <span class="keyword">if</span> (e.n[has](key) &amp;&amp; e.n[key].f) {
                        <span class="keyword">var</span> funcs = e.n[key].f;
                        <span class="keyword">for</span> (j = <span class="number">0</span>, jj = funcs.length; j &lt; jj; j++) <span class="keyword">if</span> (funcs[j] == f) {
                            funcs.splice(j, <span class="number">1</span>);
                            <span class="keyword">break</span>;
                        }
                        !funcs.length &amp;&amp; <span class="keyword">delete</span> e.n[key].f;
                    }
                } <span class="keyword">else</span> {
                    <span class="keyword">delete</span> e.f;
                    <span class="keyword">for</span> (key <span class="keyword">in</span> e.n) <span class="keyword">if</span> (e.n[has](key) &amp;&amp; e.n[key].f) {
                        <span class="keyword">delete</span> e.n[key].f;
                    }
                }
                e = e.n;
            }
        }
    };
    <span class="comment">/*\
     * eve.once
     [ method ]
     **
     * Binds given event handler with a given name to only run once then unbind itself.
     | eve.once("login", f);
     | eve("login"); // triggers f
     | eve("login"); // no listeners
     * Use @eve to trigger the listener.
     **
     &gt; Arguments
     **
     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
     - f (function) event handler function
     **
     = (function) same return function as @eve.on
    \*/</span>
    eve.once = <span class="function"><span class="keyword">function</span> <span class="params">(name, f)</span> {</span>
        <span class="keyword">var</span> f2 = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
            eve.unbind(name, f2);
            <span class="keyword">return</span> f.apply(<span class="keyword">this</span>, arguments);
        };
        <span class="keyword">return</span> eve.on(name, f2);
    };
    <span class="comment">/*\
     * eve.version
     [ property (string) ]
     **
     * Current version of the library.
    \*/</span>
    eve.version = version;
    eve.toString = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">return</span> <span class="string">"You are running Eve "</span> + version;
    };
    (<span class="keyword">typeof</span> module != <span class="string">"undefined"</span> &amp;&amp; module.exports) ? (module.exports = eve) : (<span class="keyword">typeof</span> define != <span class="string">"undefined"</span> ? (define(<span class="string">"eve"</span>, [], <span class="keyword">function</span>() { <span class="keyword">return</span> eve; })) : (glob.eve = eve));
})(<span class="keyword">this</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>┌─────────────────────────────────────────────────────────────────────┐ \
│ &quot;Raphaël 2.1.0&quot; - JavaScript Vector Library                         │ \
├─────────────────────────────────────────────────────────────────────┤ \
│ Copyright (c) 2008-2011 Dmitry Baranovskiy (<a href="http://raphaeljs.com">http://raphaeljs.com</a>)   │ \
│ Copyright (c) 2008-2011 Sencha Labs (<a href="http://sencha.com">http://sencha.com</a>)             │ \
│ Licensed under the MIT (<a href="http://raphaeljs.com/license.html">http://raphaeljs.com/license.html</a>) license. │ \
└─────────────────────────────────────────────────────────────────────┘ \</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>(<span class="function"><span class="keyword">function</span> <span class="params">(glob, factory)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>AMD support</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">"function"</span> &amp;&amp; define.amd) {</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>Define as an anonymous module</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        define([<span class="string">"eve"</span>], <span class="keyword">function</span>( eve ) {
            <span class="keyword">return</span> factory(glob, eve);
        });
    } <span class="keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>Browser globals (glob is window)
Raphael adds itself to window</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        factory(glob, glob.eve);
    }
}(<span class="keyword">this</span>, <span class="function"><span class="keyword">function</span> <span class="params">(window, eve)</span> {</span>
    <span class="comment">/*\
     * Raphael
     [ method ]
     **
     * Creates a canvas object on which to draw.
     * You must do this first, as all future calls to drawing methods
     * from this instance will be bound to this canvas.
     &gt; Parameters
     **
     - container (HTMLElement|string) DOM element or its ID which is going to be a parent for drawing surface
     - width (number)
     - height (number)
     - callback (function) #optional callback function which is going to be executed in the context of newly created paper
     * or
     - x (number)
     - y (number)
     - width (number)
     - height (number)
     - callback (function) #optional callback function which is going to be executed in the context of newly created paper
     * or
     - all (array) (first 3 or 4 elements in the array are equal to [containerID, width, height] or [x, y, width, height]. The rest are element descriptions in format {type: type, &lt;attributes&gt;}). See @Paper.add.
     - callback (function) #optional callback function which is going to be executed in the context of newly created paper
     * or
     - onReadyCallback (function) function that is going to be called on DOM ready event. You can also subscribe to this event via Eve’s “DOMLoad” event. In this case method returns `undefined`.
     = (object) @Paper
     &gt; Usage
     | // Each of the following examples create a canvas
     | // that is 320px wide by 200px high.
     | // Canvas is created at the viewport’s 10,50 coordinate.
     | var paper = Raphael(10, 50, 320, 200);
     | // Canvas is created at the top left corner of the #notepad element
     | // (or its top right corner in dir="rtl" elements)
     | var paper = Raphael(document.getElementById("notepad"), 320, 200);
     | // Same as above
     | var paper = Raphael("notepad", 320, 200);
     | // Image dump
     | var set = Raphael(["notepad", 320, 200, {
     |     type: "rect",
     |     x: 10,
     |     y: 10,
     |     width: 25,
     |     height: 25,
     |     stroke: "#f00"
     | }, {
     |     type: "text",
     |     x: 30,
     |     y: 40,
     |     text: "Dump"
     | }]);
    \*/</span>
    <span class="function"><span class="keyword">function</span> <span class="title">R</span><span class="params">(first)</span> {</span>
        <span class="keyword">if</span> (R.is(first, <span class="string">"function"</span>)) {
            <span class="keyword">return</span> loaded ? first() : eve.on(<span class="string">"raphael.DOMload"</span>, first);
        } <span class="keyword">else</span> <span class="keyword">if</span> (R.is(first, array)) {
            <span class="keyword">return</span> R._engine.create[apply](R, first.splice(<span class="number">0</span>, <span class="number">3</span> + R.is(first[<span class="number">0</span>], nu))).add(first);
        } <span class="keyword">else</span> {
            <span class="keyword">var</span> args = Array.prototype.slice.call(arguments, <span class="number">0</span>);
            <span class="keyword">if</span> (R.is(args[args.length - <span class="number">1</span>], <span class="string">"function"</span>)) {
                <span class="keyword">var</span> f = args.pop();
                <span class="keyword">return</span> loaded ? f.call(R._engine.create[apply](R, args)) : eve.on(<span class="string">"raphael.DOMload"</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
                    f.call(R._engine.create[apply](R, args));
                });
            } <span class="keyword">else</span> {
                <span class="keyword">return</span> R._engine.create[apply](R, arguments);
            }
        }
    }
    R.version = <span class="string">"2.1.0"</span>;
    R.eve = eve;
    <span class="keyword">var</span> loaded,
        separator = <span class="regexp">/[, ]+/</span>,
        elements = {circle: <span class="number">1</span>, rect: <span class="number">1</span>, path: <span class="number">1</span>, ellipse: <span class="number">1</span>, text: <span class="number">1</span>, image: <span class="number">1</span>},
        formatrg = <span class="regexp">/\{(\d+)\}/g</span>,
        proto = <span class="string">"prototype"</span>,
        has = <span class="string">"hasOwnProperty"</span>,
        g = {
            doc: document,
            win: window
        },
        oldRaphael = {
            was: Object.prototype[has].call(g.win, <span class="string">"Raphael"</span>),
            is: g.win.Raphael
        },
        Paper = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
            <span class="comment">/*\
             * Paper.ca
             [ property (object) ]
             **
             * Shortcut for @Paper.customAttributes
            \*/</span>
            <span class="comment">/*\
             * Paper.customAttributes
             [ property (object) ]
             **
             * If you have a set of attributes that you would like to represent
             * as a function of some number you can do it easily with custom attributes:
             &gt; Usage
             | paper.customAttributes.hue = function (num) {
             |     num = num % 1;
             |     return {fill: "hsb(" + num + ", 0.75, 1)"};
             | };
             | // Custom attribute “hue” will change fill
             | // to be given hue with fixed saturation and brightness.
             | // Now you can use it like this:
             | var c = paper.circle(10, 10, 10).attr({hue: .45});
             | // or even like this:
             | c.animate({hue: 1}, 1e3);
             | 
             | // You could also create custom attribute
             | // with multiple parameters:
             | paper.customAttributes.hsb = function (h, s, b) {
             |     return {fill: "hsb(" + [h, s, b].join(",") + ")"};
             | };
             | c.attr({hsb: "0.5 .8 1"});
             | c.animate({hsb: [1, 0, 0.5]}, 1e3);
            \*/</span>
            <span class="keyword">this</span>.ca = <span class="keyword">this</span>.customAttributes = {};
        },
        paperproto,
        appendChild = <span class="string">"appendChild"</span>,
        apply = <span class="string">"apply"</span>,
        concat = <span class="string">"concat"</span>,
        supportsTouch = (<span class="string">'ontouchstart'</span> <span class="keyword">in</span> g.win) || g.win.DocumentTouch &amp;&amp; g.doc <span class="keyword">instanceof</span> DocumentTouch, <span class="comment">//taken from Modernizr touch test</span>
        E = <span class="string">""</span>,
        S = <span class="string">" "</span>,
        Str = String,
        split = <span class="string">"split"</span>,
        events = <span class="string">"click dblclick mousedown mousemove mouseout mouseover mouseup touchstart touchmove touchend touchcancel"</span>[split](S),
        touchMap = {
            mousedown: <span class="string">"touchstart"</span>,
            mousemove: <span class="string">"touchmove"</span>,
            mouseup: <span class="string">"touchend"</span>
        },
        lowerCase = Str.prototype.toLowerCase,
        math = Math,
        mmax = math.max,
        mmin = math.min,
        abs = math.abs,
        pow = math.pow,
        PI = math.PI,
        nu = <span class="string">"number"</span>,
        string = <span class="string">"string"</span>,
        array = <span class="string">"array"</span>,
        toString = <span class="string">"toString"</span>,
        fillString = <span class="string">"fill"</span>,
        objectToString = Object.prototype.toString,
        paper = {},
        push = <span class="string">"push"</span>,
        ISURL = R._ISURL = <span class="regexp">/^url\(['"]?([^\)]+?)['"]?\)$/i</span>,
        colourRegExp = <span class="regexp">/^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+%?)?)\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\))\s*$/i</span>,
        isnan = {<span class="string">"NaN"</span>: <span class="number">1</span>, <span class="string">"Infinity"</span>: <span class="number">1</span>, <span class="string">"-Infinity"</span>: <span class="number">1</span>},
        bezierrg = <span class="regexp">/^(?:cubic-)?bezier\(([^,]+),([^,]+),([^,]+),([^\)]+)\)/</span>,
        round = math.round,
        setAttribute = <span class="string">"setAttribute"</span>,
        toFloat = parseFloat,
        toInt = parseInt,
        upperCase = Str.prototype.toUpperCase,
        availableAttrs = R._availableAttrs = {
            <span class="string">"arrow-end"</span>: <span class="string">"none"</span>,
            <span class="string">"arrow-start"</span>: <span class="string">"none"</span>,
            blur: <span class="number">0</span>,
            <span class="string">"clip-rect"</span>: <span class="string">"0 0 1e9 1e9"</span>,
            cursor: <span class="string">"default"</span>,
            cx: <span class="number">0</span>,
            cy: <span class="number">0</span>,
            fill: <span class="string">"#fff"</span>,
            <span class="string">"fill-opacity"</span>: <span class="number">1</span>,
            font: <span class="string">'10px "Arial"'</span>,
            <span class="string">"font-family"</span>: <span class="string">'"Arial"'</span>,
            <span class="string">"font-size"</span>: <span class="string">"10"</span>,
            <span class="string">"font-style"</span>: <span class="string">"normal"</span>,
            <span class="string">"font-weight"</span>: <span class="number">400</span>,
            gradient: <span class="number">0</span>,
            height: <span class="number">0</span>,
            href: <span class="string">"http://raphaeljs.com/"</span>,
            <span class="string">"letter-spacing"</span>: <span class="number">0</span>,
            opacity: <span class="number">1</span>,
            path: <span class="string">"M0,0"</span>,
            r: <span class="number">0</span>,
            rx: <span class="number">0</span>,
            ry: <span class="number">0</span>,
            src: <span class="string">""</span>,
            stroke: <span class="string">"#000"</span>,
            <span class="string">"stroke-dasharray"</span>: <span class="string">""</span>,
            <span class="string">"stroke-linecap"</span>: <span class="string">"butt"</span>,
            <span class="string">"stroke-linejoin"</span>: <span class="string">"butt"</span>,
            <span class="string">"stroke-miterlimit"</span>: <span class="number">0</span>,
            <span class="string">"stroke-opacity"</span>: <span class="number">1</span>,
            <span class="string">"stroke-width"</span>: <span class="number">1</span>,
            target: <span class="string">"_blank"</span>,
            <span class="string">"text-anchor"</span>: <span class="string">"middle"</span>,
            title: <span class="string">"Raphael"</span>,
            transform: <span class="string">""</span>,
            width: <span class="number">0</span>,
            x: <span class="number">0</span>,
            y: <span class="number">0</span>
        },
        availableAnimAttrs = R._availableAnimAttrs = {
            blur: nu,
            <span class="string">"clip-rect"</span>: <span class="string">"csv"</span>,
            cx: nu,
            cy: nu,
            fill: <span class="string">"colour"</span>,
            <span class="string">"fill-opacity"</span>: nu,
            <span class="string">"font-size"</span>: nu,
            height: nu,
            opacity: nu,
            path: <span class="string">"path"</span>,
            r: nu,
            rx: nu,
            ry: nu,
            stroke: <span class="string">"colour"</span>,
            <span class="string">"stroke-opacity"</span>: nu,
            <span class="string">"stroke-width"</span>: nu,
            transform: <span class="string">"transform"</span>,
            width: nu,
            x: nu,
            y: nu
        },
        whitespace = <span class="regexp">/[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]/g</span>,
        commaSpaces = <span class="regexp">/[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*/</span>,
        hsrg = {hs: <span class="number">1</span>, rg: <span class="number">1</span>},
        p2s = <span class="regexp">/,?([achlmqrstvxz]),?/gi</span>,
        pathCommand = <span class="regexp">/([achlmrqstvz])[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*)+)/ig</span>,
        tCommand = <span class="regexp">/([rstm])[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*)+)/ig</span>,
        pathValues = <span class="regexp">/(-?\d*\.?\d*(?:e[\-+]?\d+)?)[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*/ig</span>,
        radial_gradient = R._radial_gradient = <span class="regexp">/^r(?:\(([^,]+?)[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*([^\)]+?)\))?/</span>,
        eldata = {},
        sortByKey = <span class="function"><span class="keyword">function</span> <span class="params">(a, b)</span> {</span>
            <span class="keyword">return</span> a.key - b.key;
        },
        sortByNumber = <span class="function"><span class="keyword">function</span> <span class="params">(a, b)</span> {</span>
            <span class="keyword">return</span> toFloat(a) - toFloat(b);
        },
        fun = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>},
        pipe = <span class="function"><span class="keyword">function</span> <span class="params">(x)</span> {</span>
            <span class="keyword">return</span> x;
        },
        rectPath = R._rectPath = <span class="function"><span class="keyword">function</span> <span class="params">(x, y, w, h, r)</span> {</span>
            <span class="keyword">if</span> (r) {
                <span class="keyword">return</span> [[<span class="string">"M"</span>, x + r, y], [<span class="string">"l"</span>, w - r * <span class="number">2</span>, <span class="number">0</span>], [<span class="string">"a"</span>, r, r, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, r, r], [<span class="string">"l"</span>, <span class="number">0</span>, h - r * <span class="number">2</span>], [<span class="string">"a"</span>, r, r, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -r, r], [<span class="string">"l"</span>, r * <span class="number">2</span> - w, <span class="number">0</span>], [<span class="string">"a"</span>, r, r, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -r, -r], [<span class="string">"l"</span>, <span class="number">0</span>, r * <span class="number">2</span> - h], [<span class="string">"a"</span>, r, r, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, r, -r], [<span class="string">"z"</span>]];
            }
            <span class="keyword">return</span> [[<span class="string">"M"</span>, x, y], [<span class="string">"l"</span>, w, <span class="number">0</span>], [<span class="string">"l"</span>, <span class="number">0</span>, h], [<span class="string">"l"</span>, -w, <span class="number">0</span>], [<span class="string">"z"</span>]];
        },
        ellipsePath = <span class="function"><span class="keyword">function</span> <span class="params">(x, y, rx, ry)</span> {</span>
            <span class="keyword">if</span> (ry == <span class="literal">null</span>) {
                ry = rx;
            }
            <span class="keyword">return</span> [[<span class="string">"M"</span>, x, y], [<span class="string">"m"</span>, <span class="number">0</span>, -ry], [<span class="string">"a"</span>, rx, ry, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span> * ry], [<span class="string">"a"</span>, rx, ry, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">2</span> * ry], [<span class="string">"z"</span>]];
        },
        getPath = R._getPath = {
            path: <span class="function"><span class="keyword">function</span> <span class="params">(el)</span> {</span>
                <span class="keyword">return</span> el.attr(<span class="string">"path"</span>);
            },
            circle: <span class="function"><span class="keyword">function</span> <span class="params">(el)</span> {</span>
                <span class="keyword">var</span> a = el.attrs;
                <span class="keyword">return</span> ellipsePath(a.cx, a.cy, a.r);
            },
            ellipse: <span class="function"><span class="keyword">function</span> <span class="params">(el)</span> {</span>
                <span class="keyword">var</span> a = el.attrs;
                <span class="keyword">return</span> ellipsePath(a.cx, a.cy, a.rx, a.ry);
            },
            rect: <span class="function"><span class="keyword">function</span> <span class="params">(el)</span> {</span>
                <span class="keyword">var</span> a = el.attrs;
                <span class="keyword">return</span> rectPath(a.x, a.y, a.width, a.height, a.r);
            },
            image: <span class="function"><span class="keyword">function</span> <span class="params">(el)</span> {</span>
                <span class="keyword">var</span> a = el.attrs;
                <span class="keyword">return</span> rectPath(a.x, a.y, a.width, a.height);
            },
            text: <span class="function"><span class="keyword">function</span> <span class="params">(el)</span> {</span>
                <span class="keyword">var</span> bbox = el._getBBox();
                <span class="keyword">return</span> rectPath(bbox.x, bbox.y, bbox.width, bbox.height);
            },
            set : <span class="keyword">function</span>(el) {
                <span class="keyword">var</span> bbox = el._getBBox();
                <span class="keyword">return</span> rectPath(bbox.x, bbox.y, bbox.width, bbox.height);
            }
        },
        <span class="comment">/*\
         * Raphael.mapPath
         [ method ]
         **
         * Transform the path string with given matrix.
         &gt; Parameters
         - path (string) path string
         - matrix (object) see @Matrix
         = (string) transformed path string
        \*/</span>
        mapPath = R.mapPath = <span class="function"><span class="keyword">function</span> <span class="params">(path, matrix)</span> {</span>
            <span class="keyword">if</span> (!matrix) {
                <span class="keyword">return</span> path;
            }
            <span class="keyword">var</span> x, y, i, j, ii, jj, pathi;
            path = path2curve(path);
            <span class="keyword">for</span> (i = <span class="number">0</span>, ii = path.length; i &lt; ii; i++) {
                pathi = path[i];
                <span class="keyword">for</span> (j = <span class="number">1</span>, jj = pathi.length; j &lt; jj; j += <span class="number">2</span>) {
                    x = matrix.x(pathi[j], pathi[j + <span class="number">1</span>]);
                    y = matrix.y(pathi[j], pathi[j + <span class="number">1</span>]);
                    pathi[j] = x;
                    pathi[j + <span class="number">1</span>] = y;
                }
            }
            <span class="keyword">return</span> path;
        };

    R._g = g;
    <span class="comment">/*\
     * Raphael.type
     [ property (string) ]
     **
     * Can be “SVG”, “VML” or empty, depending on browser support.
    \*/</span>
    R.type = (g.win.SVGAngle || g.doc.implementation.hasFeature(<span class="string">"http://www.w3.org/TR/SVG11/feature#BasicStructure"</span>, <span class="string">"1.1"</span>) ? <span class="string">"SVG"</span> : <span class="string">"VML"</span>);
    <span class="keyword">if</span> (R.type == <span class="string">"VML"</span>) {
        <span class="keyword">var</span> d = g.doc.createElement(<span class="string">"div"</span>),
            b;
        d.innerHTML = <span class="string">'&lt;v:shape adj="1"/&gt;'</span>;
        b = d.firstChild;
        b.style.behavior = <span class="string">"url(#default#VML)"</span>;
        <span class="keyword">if</span> (!(b &amp;&amp; <span class="keyword">typeof</span> b.adj == <span class="string">"object"</span>)) {
            <span class="keyword">return</span> (R.type = E);
        }
        d = <span class="literal">null</span>;
    }
    <span class="comment">/*\
     * Raphael.svg
     [ property (boolean) ]
     **
     * `true` if browser supports SVG.
    \*/</span>
    <span class="comment">/*\
     * Raphael.vml
     [ property (boolean) ]
     **
     * `true` if browser supports VML.
    \*/</span>
    R.svg = !(R.vml = R.type == <span class="string">"VML"</span>);
    R._Paper = Paper;
    <span class="comment">/*\
     * Raphael.fn
     [ property (object) ]
     **
     * You can add your own method to the canvas. For example if you want to draw a pie chart,
     * you can create your own pie chart function and ship it as a Raphaël plugin. To do this
     * you need to extend the `Raphael.fn` object. You should modify the `fn` object before a
     * Raphaël instance is created, otherwise it will take no effect. Please note that the
     * ability for namespaced plugins was removed in Raphael 2.0. It is up to the plugin to
     * ensure any namespacing ensures proper context.
     &gt; Usage
     | Raphael.fn.arrow = function (x1, y1, x2, y2, size) {
     |     return this.path( ... );
     | };
     | // or create namespace
     | Raphael.fn.mystuff = {
     |     arrow: function () {…},
     |     star: function () {…},
     |     // etc…
     | };
     | var paper = Raphael(10, 10, 630, 480);
     | // then use it
     | paper.arrow(10, 10, 30, 30, 5).attr({fill: "#f00"});
     | paper.mystuff.arrow();
     | paper.mystuff.star();
    \*/</span>
    R.fn = paperproto = Paper.prototype = R.prototype;
    R._id = <span class="number">0</span>;
    R._oid = <span class="number">0</span>;
    <span class="comment">/*\
     * Raphael.is
     [ method ]
     **
     * Handfull replacement for `typeof` operator.
     &gt; Parameters
     - o (…) any object or primitive
     - type (string) name of the type, i.e. “string”, “function”, “number”, etc.
     = (boolean) is given value is of given type
    \*/</span>
    R.is = <span class="function"><span class="keyword">function</span> <span class="params">(o, type)</span> {</span>
        type = lowerCase.call(type);
        <span class="keyword">if</span> (type == <span class="string">"finite"</span>) {
            <span class="keyword">return</span> !isnan[has](+o);
        }
        <span class="keyword">if</span> (type == <span class="string">"array"</span>) {
            <span class="keyword">return</span> o <span class="keyword">instanceof</span> Array;
        }
        <span class="keyword">return</span>  (type == <span class="string">"null"</span> &amp;&amp; o === <span class="literal">null</span>) ||
                (type == <span class="keyword">typeof</span> o &amp;&amp; o !== <span class="literal">null</span>) ||
                (type == <span class="string">"object"</span> &amp;&amp; o === Object(o)) ||
                (type == <span class="string">"array"</span> &amp;&amp; Array.isArray &amp;&amp; Array.isArray(o)) ||
                objectToString.call(o).slice(<span class="number">8</span>, -<span class="number">1</span>).toLowerCase() == type;
    };

    <span class="function"><span class="keyword">function</span> <span class="title">clone</span><span class="params">(obj)</span> {</span>
        <span class="keyword">if</span> (Object(obj) !== obj) {
            <span class="keyword">return</span> obj;
        }
        <span class="keyword">var</span> res = <span class="keyword">new</span> obj.constructor;
        <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) <span class="keyword">if</span> (obj[has](key)) {
            res[key] = clone(obj[key]);
        }
        <span class="keyword">return</span> res;
    }

    <span class="comment">/*\
     * Raphael.angle
     [ method ]
     **
     * Returns angle between two or three points
     &gt; Parameters
     - x1 (number) x coord of first point
     - y1 (number) y coord of first point
     - x2 (number) x coord of second point
     - y2 (number) y coord of second point
     - x3 (number) #optional x coord of third point
     - y3 (number) #optional y coord of third point
     = (number) angle in degrees.
    \*/</span>
    R.angle = <span class="function"><span class="keyword">function</span> <span class="params">(x1, y1, x2, y2, x3, y3)</span> {</span>
        <span class="keyword">if</span> (x3 == <span class="literal">null</span>) {
            <span class="keyword">var</span> x = x1 - x2,
                y = y1 - y2;
            <span class="keyword">if</span> (!x &amp;&amp; !y) {
                <span class="keyword">return</span> <span class="number">0</span>;
            }
            <span class="keyword">return</span> (<span class="number">180</span> + math.atan2(-y, -x) * <span class="number">180</span> / PI + <span class="number">360</span>) % <span class="number">360</span>;
        } <span class="keyword">else</span> {
            <span class="keyword">return</span> R.angle(x1, y1, x3, y3) - R.angle(x2, y2, x3, y3);
        }
    };
    <span class="comment">/*\
     * Raphael.rad
     [ method ]
     **
     * Transform angle to radians
     &gt; Parameters
     - deg (number) angle in degrees
     = (number) angle in radians.
    \*/</span>
    R.rad = <span class="function"><span class="keyword">function</span> <span class="params">(deg)</span> {</span>
        <span class="keyword">return</span> deg % <span class="number">360</span> * PI / <span class="number">180</span>;
    };
    <span class="comment">/*\
     * Raphael.deg
     [ method ]
     **
     * Transform angle to degrees
     &gt; Parameters
     - deg (number) angle in radians
     = (number) angle in degrees.
    \*/</span>
    R.deg = <span class="function"><span class="keyword">function</span> <span class="params">(rad)</span> {</span>
        <span class="keyword">return</span> rad * <span class="number">180</span> / PI % <span class="number">360</span>;
    };
    <span class="comment">/*\
     * Raphael.snapTo
     [ method ]
     **
     * Snaps given value to given grid.
     &gt; Parameters
     - values (array|number) given array of values or step of the grid
     - value (number) value to adjust
     - tolerance (number) #optional tolerance for snapping. Default is `10`.
     = (number) adjusted value.
    \*/</span>
    R.snapTo = <span class="function"><span class="keyword">function</span> <span class="params">(values, value, tolerance)</span> {</span>
        tolerance = R.is(tolerance, <span class="string">"finite"</span>) ? tolerance : <span class="number">10</span>;
        <span class="keyword">if</span> (R.is(values, array)) {
            <span class="keyword">var</span> i = values.length;
            <span class="keyword">while</span> (i--) <span class="keyword">if</span> (abs(values[i] - value) &lt;= tolerance) {
                <span class="keyword">return</span> values[i];
            }
        } <span class="keyword">else</span> {
            values = +values;
            <span class="keyword">var</span> rem = value % values;
            <span class="keyword">if</span> (rem &lt; tolerance) {
                <span class="keyword">return</span> value - rem;
            }
            <span class="keyword">if</span> (rem &gt; values - tolerance) {
                <span class="keyword">return</span> value - rem + values;
            }
        }
        <span class="keyword">return</span> value;
    };

    <span class="comment">/*\
     * Raphael.createUUID
     [ method ]
     **
     * Returns RFC4122, version 4 ID
    \*/</span>
    <span class="keyword">var</span> createUUID = R.createUUID = (<span class="function"><span class="keyword">function</span> <span class="params">(uuidRegEx, uuidReplacer)</span> {</span>
        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
            <span class="keyword">return</span> <span class="string">"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx"</span>.replace(uuidRegEx, uuidReplacer).toUpperCase();
        };
    })(<span class="regexp">/[xy]/g</span>, <span class="function"><span class="keyword">function</span> <span class="params">(c)</span> {</span>
        <span class="keyword">var</span> r = math.random() * <span class="number">16</span> | <span class="number">0</span>,
            v = c == <span class="string">"x"</span> ? r : (r &amp; <span class="number">3</span> | <span class="number">8</span>);
        <span class="keyword">return</span> v.toString(<span class="number">16</span>);
    });

    <span class="comment">/*\
     * Raphael.setWindow
     [ method ]
     **
     * Used when you need to draw in `&amp;lt;iframe&gt;`. Switched window to the iframe one.
     &gt; Parameters
     - newwin (window) new window object
    \*/</span>
    R.setWindow = <span class="function"><span class="keyword">function</span> <span class="params">(newwin)</span> {</span>
        eve(<span class="string">"raphael.setWindow"</span>, R, g.win, newwin);
        g.win = newwin;
        g.doc = g.win.document;
        <span class="keyword">if</span> (R._engine.initWin) {
            R._engine.initWin(g.win);
        }
    };
    <span class="keyword">var</span> toHex = <span class="function"><span class="keyword">function</span> <span class="params">(color)</span> {</span>
        <span class="keyword">if</span> (R.vml) {</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p><a href="http://dean.edwards.name/weblog/2009/10/convert-any-colour-value-to-hex-in-msie/">http://dean.edwards.name/weblog/2009/10/convert-any-colour-value-to-hex-in-msie/</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">var</span> trim = <span class="regexp">/^\s+|\s+$/g</span>;
            <span class="keyword">var</span> bod;
            <span class="keyword">try</span> {
                <span class="keyword">var</span> docum = <span class="keyword">new</span> ActiveXObject(<span class="string">"htmlfile"</span>);
                docum.write(<span class="string">"&lt;body&gt;"</span>);
                docum.close();
                bod = docum.body;
            } <span class="keyword">catch</span>(e) {
                bod = createPopup().document.body;
            }
            <span class="keyword">var</span> range = bod.createTextRange();
            toHex = cacher(<span class="function"><span class="keyword">function</span> <span class="params">(color)</span> {</span>
                <span class="keyword">try</span> {
                    bod.style.color = Str(color).replace(trim, E);
                    <span class="keyword">var</span> value = range.queryCommandValue(<span class="string">"ForeColor"</span>);
                    value = ((value &amp; <span class="number">255</span>) &lt;<span class="xml"><span class="tag">&lt; <span class="attribute">16</span>) | (<span class="attribute">value</span> &amp; <span class="attribute">65280</span>) | ((<span class="attribute">value</span> &amp; <span class="attribute">16711680</span>) &gt;</span>&gt;&gt; 16);
                    return "#" + ("000000" + value.toString(16)).slice(-6);
                } catch(e) {
                    return "none";
                }
            });
        } else {
            var i = g.doc.createElement("i");
            i.title = "Rapha\xebl Colour Picker";
            i.style.display = "none";
            g.doc.body.appendChild(i);
            toHex = cacher(function (color) {
                i.style.color = color;
                return g.doc.defaultView.getComputedStyle(i, E).getPropertyValue("color");
            });
        }
        return toHex(color);
    },
    hsbtoString = function () {
        return "hsb(" + [this.h, this.s, this.b] + ")";
    },
    hsltoString = function () {
        return "hsl(" + [this.h, this.s, this.l] + ")";
    },
    rgbtoString = function () {
        return this.hex;
    },
    prepareRGB = function (r, g, b) {
        if (g == null &amp;&amp; R.is(r, "object") &amp;&amp; "r" in r &amp;&amp; "g" in r &amp;&amp; "b" in r) {
            b = r.b;
            g = r.g;
            r = r.r;
        }
        if (g == null &amp;&amp; R.is(r, string)) {
            var clr = R.getRGB(r);
            r = clr.r;
            g = clr.g;
            b = clr.b;
        }
        if (r &gt; 1 || g &gt; 1 || b &gt; 1) {
            r /= 255;
            g /= 255;
            b /= 255;
        }

        return [r, g, b];
    },
    packageRGB = function (r, g, b, o) {
        r *= 255;
        g *= 255;
        b *= 255;
        var rgb = {
            r: r,
            g: g,
            b: b,
            hex: R.rgb(r, g, b),
            toString: rgbtoString
        };
        R.is(o, "finite") &amp;&amp; (rgb.opacity = o);
        return rgb;
    };

    /*\
     * Raphael.color
     [ method ]
     **
     * Parses the color string and returns object with all values for the given color.
     &gt; Parameters
     - clr (string) color string in one of the supported formats (see @Raphael.getRGB)
     = (object) Combined RGB &amp; HSB object in format:
     o {
     o     r (number) red,
     o     g (number) green,
     o     b (number) blue,
     o     hex (string) color in HTML/CSS format: #••••••,
     o     error (boolean) `true` if string can’t be parsed,
     o     h (number) hue,
     o     s (number) saturation,
     o     v (number) value (brightness),
     o     l (number) lightness
     o }
    \*/
    R.color = function (clr) {
        var rgb;
        if (R.is(clr, "object") &amp;&amp; "h" in clr &amp;&amp; "s" in clr &amp;&amp; "b" in clr) {
            rgb = R.hsb2rgb(clr);
            clr.r = rgb.r;
            clr.g = rgb.g;
            clr.b = rgb.b;
            clr.hex = rgb.hex;
        } else if (R.is(clr, "object") &amp;&amp; "h" in clr &amp;&amp; "s" in clr &amp;&amp; "l" in clr) {
            rgb = R.hsl2rgb(clr);
            clr.r = rgb.r;
            clr.g = rgb.g;
            clr.b = rgb.b;
            clr.hex = rgb.hex;
        } else {
            if (R.is(clr, "string")) {
                clr = R.getRGB(clr);
            }
            if (R.is(clr, "object") &amp;&amp; "r" in clr &amp;&amp; "g" in clr &amp;&amp; "b" in clr) {
                rgb = R.rgb2hsl(clr);
                clr.h = rgb.h;
                clr.s = rgb.s;
                clr.l = rgb.l;
                rgb = R.rgb2hsb(clr);
                clr.v = rgb.b;
            } else {
                clr = {hex: "none"};
                clr.r = clr.g = clr.b = clr.h = clr.s = clr.v = clr.l = -1;
            }
        }
        clr.toString = rgbtoString;
        return clr;
    };
    /*\
     * Raphael.hsb2rgb
     [ method ]
     **
     * Converts HSB values to RGB object.
     &gt; Parameters
     - h (number) hue
     - s (number) saturation
     - v (number) value or brightness
     = (object) RGB object in format:
     o {
     o     r (number) red,
     o     g (number) green,
     o     b (number) blue,
     o     hex (string) color in HTML/CSS format: #••••••
     o }
    \*/
    R.hsb2rgb = function (h, s, v, o) {
        if (this.is(h, "object") &amp;&amp; "h" in h &amp;&amp; "s" in h &amp;&amp; "b" in h) {
            v = h.b;
            s = h.s;
            h = h.h;
            o = h.o;
        }
        h *= 360;
        var R, G, B, X, C;
        h = (h % 360) / 60;
        C = v * s;
        X = C * (1 - abs(h % 2 - 1));
        R = G = B = v - C;

        h = ~~h;
        R += [C, X, 0, 0, X, C][h];
        G += [X, C, C, X, 0, 0][h];
        B += [0, 0, X, C, C, X][h];
        return packageRGB(R, G, B, o);
    };
    /*\
     * Raphael.hsl2rgb
     [ method ]
     **
     * Converts HSL values to RGB object.
     &gt; Parameters
     - h (number) hue
     - s (number) saturation
     - l (number) luminosity
     = (object) RGB object in format:
     o {
     o     r (number) red,
     o     g (number) green,
     o     b (number) blue,
     o     hex (string) color in HTML/CSS format: #••••••
     o }
    \*/
    R.hsl2rgb = function (h, s, l, o) {
        if (this.is(h, "object") &amp;&amp; "h" in h &amp;&amp; "s" in h &amp;&amp; "l" in h) {
            l = h.l;
            s = h.s;
            h = h.h;
        }
        if (h &gt; 1 || s &gt; 1 || l &gt; 1) {
            h /= 360;
            s /= 100;
            l /= 100;
        }
        h *= 360;
        var R, G, B, X, C;
        h = (h % 360) / 60;
        C = 2 * s * (l <span class="tag">&lt; <span class="attribute">.5</span> ? <span class="attribute">l</span> <span class="attribute">:</span> <span class="attribute">1</span> <span class="attribute">-</span> <span class="attribute">l</span>);
        <span class="attribute">X</span> = <span class="attribute">C</span> * (<span class="attribute">1</span> <span class="attribute">-</span> <span class="attribute">abs</span>(<span class="attribute">h</span> % <span class="attribute">2</span> <span class="attribute">-</span> <span class="attribute">1</span>));
        <span class="attribute">R</span> = <span class="attribute">G</span> = <span class="attribute">B</span> = <span class="attribute">l</span> <span class="attribute">-</span> <span class="attribute">C</span> / <span class="attribute">2</span>;

        <span class="attribute">h</span> = ~~<span class="attribute">h</span>;
        <span class="attribute">R</span> += [<span class="attribute">C</span>, <span class="attribute">X</span>, <span class="attribute">0</span>, <span class="attribute">0</span>, <span class="attribute">X</span>, <span class="attribute">C</span>][<span class="attribute">h</span>];
        <span class="attribute">G</span> += [<span class="attribute">X</span>, <span class="attribute">C</span>, <span class="attribute">C</span>, <span class="attribute">X</span>, <span class="attribute">0</span>, <span class="attribute">0</span>][<span class="attribute">h</span>];
        <span class="attribute">B</span> += [<span class="attribute">0</span>, <span class="attribute">0</span>, <span class="attribute">X</span>, <span class="attribute">C</span>, <span class="attribute">C</span>, <span class="attribute">X</span>][<span class="attribute">h</span>];
        <span class="attribute">return</span> <span class="attribute">packageRGB</span>(<span class="attribute">R</span>, <span class="attribute">G</span>, <span class="attribute">B</span>, <span class="attribute">o</span>);
    };
    /*\
     * <span class="attribute">Raphael.rgb2hsb</span>
     [ <span class="attribute">method</span> ]
     **
     * <span class="attribute">Converts</span> <span class="attribute">RGB</span> <span class="attribute">values</span> <span class="attribute">to</span> <span class="attribute">HSB</span> <span class="attribute">object.</span>
     &gt;</span> Parameters
     - r (number) red
     - g (number) green
     - b (number) blue
     = (object) HSB object in format:
     o {
     o     h (number) hue
     o     s (number) saturation
     o     b (number) brightness
     o }
    \*/
    R.rgb2hsb = function (r, g, b) {
        b = prepareRGB(r, g, b);
        r = b[0];
        g = b[1];
        b = b[2];

        var H, S, V, C;
        V = mmax(r, g, b);
        C = V - mmin(r, g, b);
        H = (C == 0 ? null :
             V == r ? (g - b) / C :
             V == g ? (b - r) / C + 2 :
                      (r - g) / C + 4
            );
        H = ((H + 360) % 6) * 60 / 360;
        S = C == 0 ? 0 : C / V;
        return {h: H, s: S, b: V, toString: hsbtoString};
    };
    /*\
     * Raphael.rgb2hsl
     [ method ]
     **
     * Converts RGB values to HSL object.
     &gt; Parameters
     - r (number) red
     - g (number) green
     - b (number) blue
     = (object) HSL object in format:
     o {
     o     h (number) hue
     o     s (number) saturation
     o     l (number) luminosity
     o }
    \*/
    R.rgb2hsl = function (r, g, b) {
        b = prepareRGB(r, g, b);
        r = b[0];
        g = b[1];
        b = b[2];

        var H, S, L, M, m, C;
        M = mmax(r, g, b);
        m = mmin(r, g, b);
        C = M - m;
        H = (C == 0 ? null :
             M == r ? (g - b) / C :
             M == g ? (b - r) / C + 2 :
                      (r - g) / C + 4);
        H = ((H + 360) % 6) * 60 / 360;
        L = (M + m) / 2;
        S = (C == 0 ? 0 :
             L <span class="tag">&lt; <span class="attribute">.5</span> ? <span class="attribute">C</span> / (<span class="attribute">2</span> * <span class="attribute">L</span>) <span class="attribute">:</span>
                      <span class="attribute">C</span> / (<span class="attribute">2</span> <span class="attribute">-</span> <span class="attribute">2</span> * <span class="attribute">L</span>));
        <span class="attribute">return</span> {<span class="attribute">h:</span> <span class="attribute">H</span>, <span class="attribute">s:</span> <span class="attribute">S</span>, <span class="attribute">l:</span> <span class="attribute">L</span>, <span class="attribute">toString:</span> <span class="attribute">hsltoString</span>};
    };
    <span class="attribute">R._path2string</span> = <span class="attribute">function</span> () {
        <span class="attribute">return</span> <span class="attribute">this.join</span>(",")<span class="attribute">.replace</span>(<span class="attribute">p2s</span>, "$<span class="attribute">1</span>");
    };
    <span class="attribute">function</span> <span class="attribute">repush</span>(<span class="attribute">array</span>, <span class="attribute">item</span>) {
        <span class="attribute">for</span> (<span class="attribute">var</span> <span class="attribute">i</span> = <span class="attribute">0</span>, <span class="attribute">ii</span> = <span class="attribute">array.length</span>; <span class="attribute">i</span> &lt; <span class="attribute">ii</span>; <span class="attribute">i</span>++) <span class="attribute">if</span> (<span class="attribute">array</span>[<span class="attribute">i</span>] =<span class="value">==</span> <span class="attribute">item</span>) {
            <span class="attribute">return</span> <span class="attribute">array.push</span>(<span class="attribute">array.splice</span>(<span class="attribute">i</span>, <span class="attribute">1</span>)[<span class="attribute">0</span>]);
        }
    }
    <span class="attribute">function</span> <span class="attribute">cacher</span>(<span class="attribute">f</span>, <span class="attribute">scope</span>, <span class="attribute">postprocessor</span>) {
        <span class="attribute">function</span> <span class="attribute">newf</span>() {
            <span class="attribute">var</span> <span class="attribute">arg</span> = <span class="attribute">Array.prototype.slice.call</span>(<span class="attribute">arguments</span>, <span class="attribute">0</span>),
                <span class="attribute">args</span> = <span class="attribute">arg.join</span>("\<span class="attribute">u2400</span>"),
                <span class="attribute">cache</span> = <span class="attribute">newf.cache</span> = <span class="attribute">newf.cache</span> || {},
                <span class="attribute">count</span> = <span class="attribute">newf.count</span> = <span class="attribute">newf.count</span> || [];
            <span class="attribute">if</span> (<span class="attribute">cache</span>[<span class="attribute">has</span>](<span class="attribute">args</span>)) {
                <span class="attribute">repush</span>(<span class="attribute">count</span>, <span class="attribute">args</span>);
                <span class="attribute">return</span> <span class="attribute">postprocessor</span> ? <span class="attribute">postprocessor</span>(<span class="attribute">cache</span>[<span class="attribute">args</span>]) <span class="attribute">:</span> <span class="attribute">cache</span>[<span class="attribute">args</span>];
            }
            <span class="attribute">count.length</span> &gt;</span>= 1e3 &amp;&amp; delete cache[count.shift()];
            count.push(args);
            cache[args] = f[apply](scope, arg);
            return postprocessor ? postprocessor(cache[args]) : cache[args];
        }
        return newf;
    }

    var preload = R._preload = function (src, f) {
        var img = g.doc.createElement("img");
        img.style.cssText = "position:absolute;left:-9999em;top:-9999em";
        img.onload = function () {
            f.call(this);
            this.onload = null;
            g.doc.body.removeChild(this);
        };
        img.onerror = function () {
            g.doc.body.removeChild(this);
        };
        g.doc.body.appendChild(img);
        img.src = src;
    };

    function clrToString() {
        return this.hex;
    }

    /*\
     * Raphael.getRGB
     [ method ]
     **
     * Parses colour string as RGB object
     &gt; Parameters
     - colour (string) colour string in one of formats:
     # <span class="tag">&lt;<span class="title">ul</span>&gt;</span>
     #     <span class="tag">&lt;<span class="title">li</span>&gt;</span>Colour name (“<span class="tag">&lt;<span class="title">code</span>&gt;</span>red<span class="tag">&lt;/<span class="title">code</span>&gt;</span>”, “<span class="tag">&lt;<span class="title">code</span>&gt;</span>green<span class="tag">&lt;/<span class="title">code</span>&gt;</span>”, “<span class="tag">&lt;<span class="title">code</span>&gt;</span>cornflowerblue<span class="tag">&lt;/<span class="title">code</span>&gt;</span>”, etc)<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
     #     <span class="tag">&lt;<span class="title">li</span>&gt;</span>#••• — shortened HTML colour: (“<span class="tag">&lt;<span class="title">code</span>&gt;</span>#000<span class="tag">&lt;/<span class="title">code</span>&gt;</span>”, “<span class="tag">&lt;<span class="title">code</span>&gt;</span>#fc0<span class="tag">&lt;/<span class="title">code</span>&gt;</span>”, etc)<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
     #     <span class="tag">&lt;<span class="title">li</span>&gt;</span>#•••••• — full length HTML colour: (“<span class="tag">&lt;<span class="title">code</span>&gt;</span>#000000<span class="tag">&lt;/<span class="title">code</span>&gt;</span>”, “<span class="tag">&lt;<span class="title">code</span>&gt;</span>#bd2300<span class="tag">&lt;/<span class="title">code</span>&gt;</span>”)<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
     #     <span class="tag">&lt;<span class="title">li</span>&gt;</span>rgb(•••, •••, •••) — red, green and blue channels’ values: (“<span class="tag">&lt;<span class="title">code</span>&gt;</span>rgb(200,&amp;nbsp;100,&amp;nbsp;0)<span class="tag">&lt;/<span class="title">code</span>&gt;</span>”)<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
     #     <span class="tag">&lt;<span class="title">li</span>&gt;</span>rgb(•••%, •••%, •••%) — same as above, but in %: (“<span class="tag">&lt;<span class="title">code</span>&gt;</span>rgb(100%,&amp;nbsp;175%,&amp;nbsp;0%)<span class="tag">&lt;/<span class="title">code</span>&gt;</span>”)<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
     #     <span class="tag">&lt;<span class="title">li</span>&gt;</span>hsb(•••, •••, •••) — hue, saturation and brightness values: (“<span class="tag">&lt;<span class="title">code</span>&gt;</span>hsb(0.5,&amp;nbsp;0.25,&amp;nbsp;1)<span class="tag">&lt;/<span class="title">code</span>&gt;</span>”)<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
     #     <span class="tag">&lt;<span class="title">li</span>&gt;</span>hsb(•••%, •••%, •••%) — same as above, but in %<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
     #     <span class="tag">&lt;<span class="title">li</span>&gt;</span>hsl(•••, •••, •••) — same as hsb<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
     #     <span class="tag">&lt;<span class="title">li</span>&gt;</span>hsl(•••%, •••%, •••%) — same as hsb<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
     # <span class="tag">&lt;/<span class="title">ul</span>&gt;</span>
     = (object) RGB object in format:
     o {
     o     r (number) red,
     o     g (number) green,
     o     b (number) blue
     o     hex (string) color in HTML/CSS format: #••••••,
     o     error (boolean) true if string can’t be parsed
     o }
    \*/
    R.getRGB = cacher(function (colour) {
        if (!colour || !!((colour = Str(colour)).indexOf("-") + 1)) {
            return {r: -1, g: -1, b: -1, hex: "none", error: 1, toString: clrToString};
        }
        if (colour == "none") {
            return {r: -1, g: -1, b: -1, hex: "none", toString: clrToString};
        }
        !(hsrg[has](colour.toLowerCase().substring(0, 2)) || colour.charAt() == "#") &amp;&amp; (colour = toHex(colour));
        var res,
            red,
            green,
            blue,
            opacity,
            t,
            values,
            rgb = colour.match(colourRegExp);
        if (rgb) {
            if (rgb[2]) {
                blue = toInt(rgb[2].substring(5), 16);
                green = toInt(rgb[2].substring(3, 5), 16);
                red = toInt(rgb[2].substring(1, 3), 16);
            }
            if (rgb[3]) {
                blue = toInt((t = rgb[3].charAt(3)) + t, 16);
                green = toInt((t = rgb[3].charAt(2)) + t, 16);
                red = toInt((t = rgb[3].charAt(1)) + t, 16);
            }
            if (rgb[4]) {
                values = rgb[4][split](commaSpaces);
                red = toFloat(values[0]);
                values[0].slice(-1) == "%" &amp;&amp; (red *= 2.55);
                green = toFloat(values[1]);
                values[1].slice(-1) == "%" &amp;&amp; (green *= 2.55);
                blue = toFloat(values[2]);
                values[2].slice(-1) == "%" &amp;&amp; (blue *= 2.55);
                rgb[1].toLowerCase().slice(0, 4) == "rgba" &amp;&amp; (opacity = toFloat(values[3]));
                values[3] &amp;&amp; values[3].slice(-1) == "%" &amp;&amp; (opacity /= 100);
            }
            if (rgb[5]) {
                values = rgb[5][split](commaSpaces);
                red = toFloat(values[0]);
                values[0].slice(-1) == "%" &amp;&amp; (red *= 2.55);
                green = toFloat(values[1]);
                values[1].slice(-1) == "%" &amp;&amp; (green *= 2.55);
                blue = toFloat(values[2]);
                values[2].slice(-1) == "%" &amp;&amp; (blue *= 2.55);
                (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") &amp;&amp; (red /= 360);
                rgb[1].toLowerCase().slice(0, 4) == "hsba" &amp;&amp; (opacity = toFloat(values[3]));
                values[3] &amp;&amp; values[3].slice(-1) == "%" &amp;&amp; (opacity /= 100);
                return R.hsb2rgb(red, green, blue, opacity);
            }
            if (rgb[6]) {
                values = rgb[6][split](commaSpaces);
                red = toFloat(values[0]);
                values[0].slice(-1) == "%" &amp;&amp; (red *= 2.55);
                green = toFloat(values[1]);
                values[1].slice(-1) == "%" &amp;&amp; (green *= 2.55);
                blue = toFloat(values[2]);
                values[2].slice(-1) == "%" &amp;&amp; (blue *= 2.55);
                (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") &amp;&amp; (red /= 360);
                rgb[1].toLowerCase().slice(0, 4) == "hsla" &amp;&amp; (opacity = toFloat(values[3]));
                values[3] &amp;&amp; values[3].slice(-1) == "%" &amp;&amp; (opacity /= 100);
                return R.hsl2rgb(red, green, blue, opacity);
            }
            rgb = {r: red, g: green, b: blue, toString: clrToString};
            rgb.hex = "#" + (16777216 | blue | (green <span class="tag">&lt;<span class="title">&lt;</span> <span class="attribute">8</span>) | (<span class="attribute">red</span> &lt;&lt; <span class="attribute">16</span>))<span class="attribute">.toString</span>(<span class="attribute">16</span>)<span class="attribute">.slice</span>(<span class="attribute">1</span>);
            <span class="attribute">R.is</span>(<span class="attribute">opacity</span>, "<span class="attribute">finite</span>") &amp;&amp; (<span class="attribute">rgb.opacity</span> = <span class="attribute">opacity</span>);
            <span class="attribute">return</span> <span class="attribute">rgb</span>;
        }
        <span class="attribute">return</span> {<span class="attribute">r:</span> <span class="attribute">-1</span>, <span class="attribute">g:</span> <span class="attribute">-1</span>, <span class="attribute">b:</span> <span class="attribute">-1</span>, <span class="attribute">hex:</span> "<span class="attribute">none</span>", <span class="attribute">error:</span> <span class="attribute">1</span>, <span class="attribute">toString:</span> <span class="attribute">clrToString</span>};
    }, <span class="attribute">R</span>);
    /*\
     * <span class="attribute">Raphael.hsb</span>
     [ <span class="attribute">method</span> ]
     **
     * <span class="attribute">Converts</span> <span class="attribute">HSB</span> <span class="attribute">values</span> <span class="attribute">to</span> <span class="attribute">hex</span> <span class="attribute">representation</span> <span class="attribute">of</span> <span class="attribute">the</span> <span class="attribute">colour.</span>
     &gt;</span> Parameters
     - h (number) hue
     - s (number) saturation
     - b (number) value or brightness
     = (string) hex representation of the colour.
    \*/
    R.hsb = cacher(function (h, s, b) {
        return R.hsb2rgb(h, s, b).hex;
    });
    /*\
     * Raphael.hsl
     [ method ]
     **
     * Converts HSL values to hex representation of the colour.
     &gt; Parameters
     - h (number) hue
     - s (number) saturation
     - l (number) luminosity
     = (string) hex representation of the colour.
    \*/
    R.hsl = cacher(function (h, s, l) {
        return R.hsl2rgb(h, s, l).hex;
    });
    /*\
     * Raphael.rgb
     [ method ]
     **
     * Converts RGB values to hex representation of the colour.
     &gt; Parameters
     - r (number) red
     - g (number) green
     - b (number) blue
     = (string) hex representation of the colour.
    \*/
    R.rgb = cacher(function (r, g, b) {
        return "#" + (16777216 | b | (g <span class="tag">&lt;<span class="title">&lt;</span> <span class="attribute">8</span>) | (<span class="attribute">r</span> &lt;&lt; <span class="attribute">16</span>))<span class="attribute">.toString</span>(<span class="attribute">16</span>)<span class="attribute">.slice</span>(<span class="attribute">1</span>);
    });
    /*\
     * <span class="attribute">Raphael.getColor</span>
     [ <span class="attribute">method</span> ]
     **
     * <span class="attribute">On</span> <span class="attribute">each</span> <span class="attribute">call</span> <span class="attribute">returns</span> <span class="attribute">next</span> <span class="attribute">colour</span> <span class="attribute">in</span> <span class="attribute">the</span> <span class="attribute">spectrum.</span> <span class="attribute">To</span> <span class="attribute">reset</span> <span class="attribute">it</span> <span class="attribute">back</span> <span class="attribute">to</span> <span class="attribute">red</span> <span class="attribute">call</span> @<span class="attribute">Raphael.getColor.reset</span>
     &gt;</span> Parameters
     - value (number) #optional brightness, default is `0.75`
     = (string) hex representation of the colour.
    \*/
    R.getColor = function (value) {
        var start = this.getColor.start = this.getColor.start || {h: 0, s: 1, b: value || .75},
            rgb = this.hsb2rgb(start.h, start.s, start.b);
        start.h += .075;
        if (start.h &gt; 1) {
            start.h = 0;
            start.s -= .2;
            start.s <span class="tag">&lt;<span class="title">=</span> <span class="attribute">0</span> &amp;&amp; (<span class="attribute">this.getColor.start</span> = {<span class="attribute">h:</span> <span class="attribute">0</span>, <span class="attribute">s:</span> <span class="attribute">1</span>, <span class="attribute">b:</span> <span class="attribute">start.b</span>});
        }
        <span class="attribute">return</span> <span class="attribute">rgb.hex</span>;
    };
    /*\
     * <span class="attribute">Raphael.getColor.reset</span>
     [ <span class="attribute">method</span> ]
     **
     * <span class="attribute">Resets</span> <span class="attribute">spectrum</span> <span class="attribute">position</span> <span class="attribute">for</span> @<span class="attribute">Raphael.getColor</span> <span class="attribute">back</span> <span class="attribute">to</span> <span class="attribute">red.</span>
    \*/
    <span class="attribute">R.getColor.reset</span> = <span class="attribute">function</span> () {
        <span class="attribute">delete</span> <span class="attribute">this.start</span>;
    };

</span></pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p><a href="http://schepers.cc/getting-to-the-point">http://schepers.cc/getting-to-the-point</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">catmullRom2bezier</span><span class="params">(crp, z)</span> {</span>
        <span class="keyword">var</span> d = [];
        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, iLen = crp.length; iLen - <span class="number">2</span> * !z &gt; i; i += <span class="number">2</span>) {
            <span class="keyword">var</span> p = [
                        {x: +crp[i - <span class="number">2</span>], y: +crp[i - <span class="number">1</span>]},
                        {x: +crp[i],     y: +crp[i + <span class="number">1</span>]},
                        {x: +crp[i + <span class="number">2</span>], y: +crp[i + <span class="number">3</span>]},
                        {x: +crp[i + <span class="number">4</span>], y: +crp[i + <span class="number">5</span>]}
                    ];
            <span class="keyword">if</span> (z) {
                <span class="keyword">if</span> (!i) {
                    p[<span class="number">0</span>] = {x: +crp[iLen - <span class="number">2</span>], y: +crp[iLen - <span class="number">1</span>]};
                } <span class="keyword">else</span> <span class="keyword">if</span> (iLen - <span class="number">4</span> == i) {
                    p[<span class="number">3</span>] = {x: +crp[<span class="number">0</span>], y: +crp[<span class="number">1</span>]};
                } <span class="keyword">else</span> <span class="keyword">if</span> (iLen - <span class="number">2</span> == i) {
                    p[<span class="number">2</span>] = {x: +crp[<span class="number">0</span>], y: +crp[<span class="number">1</span>]};
                    p[<span class="number">3</span>] = {x: +crp[<span class="number">2</span>], y: +crp[<span class="number">3</span>]};
                }
            } <span class="keyword">else</span> {
                <span class="keyword">if</span> (iLen - <span class="number">4</span> == i) {
                    p[<span class="number">3</span>] = p[<span class="number">2</span>];
                } <span class="keyword">else</span> <span class="keyword">if</span> (!i) {
                    p[<span class="number">0</span>] = {x: +crp[i], y: +crp[i + <span class="number">1</span>]};
                }
            }
            d.push([<span class="string">"C"</span>,
                  (-p[<span class="number">0</span>].x + <span class="number">6</span> * p[<span class="number">1</span>].x + p[<span class="number">2</span>].x) / <span class="number">6</span>,
                  (-p[<span class="number">0</span>].y + <span class="number">6</span> * p[<span class="number">1</span>].y + p[<span class="number">2</span>].y) / <span class="number">6</span>,
                  (p[<span class="number">1</span>].x + <span class="number">6</span> * p[<span class="number">2</span>].x - p[<span class="number">3</span>].x) / <span class="number">6</span>,
                  (p[<span class="number">1</span>].y + <span class="number">6</span>*p[<span class="number">2</span>].y - p[<span class="number">3</span>].y) / <span class="number">6</span>,
                  p[<span class="number">2</span>].x,
                  p[<span class="number">2</span>].y
            ]);
        }

        <span class="keyword">return</span> d;
    }
    <span class="comment">/*\
     * Raphael.parsePathString
     [ method ]
     **
     * Utility method
     **
     * Parses given path string into an array of arrays of path segments.
     &gt; Parameters
     - pathString (string|array) path string or array of segments (in the last case it will be returned straight away)
     = (array) array of segments.
    \*/</span>
    R.parsePathString = <span class="function"><span class="keyword">function</span> <span class="params">(pathString)</span> {</span>
        <span class="keyword">if</span> (!pathString) {
            <span class="keyword">return</span> <span class="literal">null</span>;
        }
        <span class="keyword">var</span> pth = paths(pathString);
        <span class="keyword">if</span> (pth.arr) {
            <span class="keyword">return</span> pathClone(pth.arr);
        }

        <span class="keyword">var</span> paramCounts = {a: <span class="number">7</span>, c: <span class="number">6</span>, h: <span class="number">1</span>, l: <span class="number">2</span>, m: <span class="number">2</span>, r: <span class="number">4</span>, q: <span class="number">4</span>, s: <span class="number">4</span>, t: <span class="number">2</span>, v: <span class="number">1</span>, z: <span class="number">0</span>},
            data = [];
        <span class="keyword">if</span> (R.is(pathString, array) &amp;&amp; R.is(pathString[<span class="number">0</span>], array)) { <span class="comment">// rough assumption</span>
            data = pathClone(pathString);
        }
        <span class="keyword">if</span> (!data.length) {
            Str(pathString).replace(pathCommand, <span class="function"><span class="keyword">function</span> <span class="params">(a, b, c)</span> {</span>
                <span class="keyword">var</span> params = [],
                    name = b.toLowerCase();
                c.replace(pathValues, <span class="function"><span class="keyword">function</span> <span class="params">(a, b)</span> {</span>
                    b &amp;&amp; params.push(+b);
                });
                <span class="keyword">if</span> (name == <span class="string">"m"</span> &amp;&amp; params.length &gt; <span class="number">2</span>) {
                    data.push([b][concat](params.splice(<span class="number">0</span>, <span class="number">2</span>)));
                    name = <span class="string">"l"</span>;
                    b = b == <span class="string">"m"</span> ? <span class="string">"l"</span> : <span class="string">"L"</span>;
                }
                <span class="keyword">if</span> (name == <span class="string">"r"</span>) {
                    data.push([b][concat](params));
                } <span class="keyword">else</span> <span class="keyword">while</span> (params.length &gt;= paramCounts[name]) {
                    data.push([b][concat](params.splice(<span class="number">0</span>, paramCounts[name])));
                    <span class="keyword">if</span> (!paramCounts[name]) {
                        <span class="keyword">break</span>;
                    }
                }
            });
        }
        data.toString = R._path2string;
        pth.arr = pathClone(data);
        <span class="keyword">return</span> data;
    };
    <span class="comment">/*\
     * Raphael.parseTransformString
     [ method ]
     **
     * Utility method
     **
     * Parses given path string into an array of transformations.
     &gt; Parameters
     - TString (string|array) transform string or array of transformations (in the last case it will be returned straight away)
     = (array) array of transformations.
    \*/</span>
    R.parseTransformString = cacher(<span class="function"><span class="keyword">function</span> <span class="params">(TString)</span> {</span>
        <span class="keyword">if</span> (!TString) {
            <span class="keyword">return</span> <span class="literal">null</span>;
        }
        <span class="keyword">var</span> paramCounts = {r: <span class="number">3</span>, s: <span class="number">4</span>, t: <span class="number">2</span>, m: <span class="number">6</span>},
            data = [];
        <span class="keyword">if</span> (R.is(TString, array) &amp;&amp; R.is(TString[<span class="number">0</span>], array)) { <span class="comment">// rough assumption</span>
            data = pathClone(TString);
        }
        <span class="keyword">if</span> (!data.length) {
            Str(TString).replace(tCommand, <span class="function"><span class="keyword">function</span> <span class="params">(a, b, c)</span> {</span>
                <span class="keyword">var</span> params = [],
                    name = lowerCase.call(b);
                c.replace(pathValues, <span class="function"><span class="keyword">function</span> <span class="params">(a, b)</span> {</span>
                    b &amp;&amp; params.push(+b);
                });
                data.push([b][concat](params));
            });
        }
        data.toString = R._path2string;
        <span class="keyword">return</span> data;
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>PATHS</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> paths = <span class="function"><span class="keyword">function</span> <span class="params">(ps)</span> {</span>
        <span class="keyword">var</span> p = paths.ps = paths.ps || {};
        <span class="keyword">if</span> (p[ps]) {
            p[ps].sleep = <span class="number">100</span>;
        } <span class="keyword">else</span> {
            p[ps] = {
                sleep: <span class="number">100</span>
            };
        }
        setTimeout(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
            <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> p) <span class="keyword">if</span> (p[has](key) &amp;&amp; key != ps) {
                p[key].sleep--;
                !p[key].sleep &amp;&amp; <span class="keyword">delete</span> p[key];
            }
        });
        <span class="keyword">return</span> p[ps];
    };
    <span class="comment">/*\
     * Raphael.findDotsAtSegment
     [ method ]
     **
     * Utility method
     **
     * Find dot coordinates on the given cubic bezier curve at the given t.
     &gt; Parameters
     - p1x (number) x of the first point of the curve
     - p1y (number) y of the first point of the curve
     - c1x (number) x of the first anchor of the curve
     - c1y (number) y of the first anchor of the curve
     - c2x (number) x of the second anchor of the curve
     - c2y (number) y of the second anchor of the curve
     - p2x (number) x of the second point of the curve
     - p2y (number) y of the second point of the curve
     - t (number) position on the curve (0..1)
     = (object) point information in format:
     o {
     o     x: (number) x coordinate of the point
     o     y: (number) y coordinate of the point
     o     m: {
     o         x: (number) x coordinate of the left anchor
     o         y: (number) y coordinate of the left anchor
     o     }
     o     n: {
     o         x: (number) x coordinate of the right anchor
     o         y: (number) y coordinate of the right anchor
     o     }
     o     start: {
     o         x: (number) x coordinate of the start of the curve
     o         y: (number) y coordinate of the start of the curve
     o     }
     o     end: {
     o         x: (number) x coordinate of the end of the curve
     o         y: (number) y coordinate of the end of the curve
     o     }
     o     alpha: (number) angle of the curve derivative at the point
     o }
    \*/</span>
    R.findDotsAtSegment = <span class="function"><span class="keyword">function</span> <span class="params">(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t)</span> {</span>
        <span class="keyword">var</span> t1 = <span class="number">1</span> - t,
            t13 = pow(t1, <span class="number">3</span>),
            t12 = pow(t1, <span class="number">2</span>),
            t2 = t * t,
            t3 = t2 * t,
            x = t13 * p1x + t12 * <span class="number">3</span> * t * c1x + t1 * <span class="number">3</span> * t * t * c2x + t3 * p2x,
            y = t13 * p1y + t12 * <span class="number">3</span> * t * c1y + t1 * <span class="number">3</span> * t * t * c2y + t3 * p2y,
            mx = p1x + <span class="number">2</span> * t * (c1x - p1x) + t2 * (c2x - <span class="number">2</span> * c1x + p1x),
            my = p1y + <span class="number">2</span> * t * (c1y - p1y) + t2 * (c2y - <span class="number">2</span> * c1y + p1y),
            nx = c1x + <span class="number">2</span> * t * (c2x - c1x) + t2 * (p2x - <span class="number">2</span> * c2x + c1x),
            ny = c1y + <span class="number">2</span> * t * (c2y - c1y) + t2 * (p2y - <span class="number">2</span> * c2y + c1y),
            ax = t1 * p1x + t * c1x,
            ay = t1 * p1y + t * c1y,
            cx = t1 * c2x + t * p2x,
            cy = t1 * c2y + t * p2y,
            alpha = (<span class="number">90</span> - math.atan2(mx - nx, my - ny) * <span class="number">180</span> / PI);
        (mx &gt; nx || my &lt; ny) &amp;&amp; (alpha += <span class="number">180</span>);
        <span class="keyword">return</span> {
            x: x,
            y: y,
            m: {x: mx, y: my},
            n: {x: nx, y: ny},
            start: {x: ax, y: ay},
            end: {x: cx, y: cy},
            alpha: alpha
        };
    };
    <span class="comment">/*\
     * Raphael.bezierBBox
     [ method ]
     **
     * Utility method
     **
     * Return bounding box of a given cubic bezier curve
     &gt; Parameters
     - p1x (number) x of the first point of the curve
     - p1y (number) y of the first point of the curve
     - c1x (number) x of the first anchor of the curve
     - c1y (number) y of the first anchor of the curve
     - c2x (number) x of the second anchor of the curve
     - c2y (number) y of the second anchor of the curve
     - p2x (number) x of the second point of the curve
     - p2y (number) y of the second point of the curve
     * or
     - bez (array) array of six points for bezier curve
     = (object) point information in format:
     o {
     o     min: {
     o         x: (number) x coordinate of the left point
     o         y: (number) y coordinate of the top point
     o     }
     o     max: {
     o         x: (number) x coordinate of the right point
     o         y: (number) y coordinate of the bottom point
     o     }
     o }
    \*/</span>
    R.bezierBBox = <span class="function"><span class="keyword">function</span> <span class="params">(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y)</span> {</span>
        <span class="keyword">if</span> (!R.is(p1x, <span class="string">"array"</span>)) {
            p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];
        }
        <span class="keyword">var</span> bbox = curveDim.apply(<span class="literal">null</span>, p1x);
        <span class="keyword">return</span> {
            x: bbox.min.x,
            y: bbox.min.y,
            x2: bbox.max.x,
            y2: bbox.max.y,
            width: bbox.max.x - bbox.min.x,
            height: bbox.max.y - bbox.min.y
        };
    };
    <span class="comment">/*\
     * Raphael.isPointInsideBBox
     [ method ]
     **
     * Utility method
     **
     * Returns `true` if given point is inside bounding boxes.
     &gt; Parameters
     - bbox (string) bounding box
     - x (string) x coordinate of the point
     - y (string) y coordinate of the point
     = (boolean) `true` if point inside
    \*/</span>
    R.isPointInsideBBox = <span class="function"><span class="keyword">function</span> <span class="params">(bbox, x, y)</span> {</span>
        <span class="keyword">return</span> x &gt;= bbox.x &amp;&amp; x &lt;= bbox.x2 &amp;&amp; y &gt;= bbox.y &amp;&amp; y &lt;= bbox.y2;
    };
    <span class="comment">/*\
     * Raphael.isBBoxIntersect
     [ method ]
     **
     * Utility method
     **
     * Returns `true` if two bounding boxes intersect
     &gt; Parameters
     - bbox1 (string) first bounding box
     - bbox2 (string) second bounding box
     = (boolean) `true` if they intersect
    \*/</span>
    R.isBBoxIntersect = <span class="function"><span class="keyword">function</span> <span class="params">(bbox1, bbox2)</span> {</span>
        <span class="keyword">var</span> i = R.isPointInsideBBox;
        <span class="keyword">return</span> i(bbox2, bbox1.x, bbox1.y)
            || i(bbox2, bbox1.x2, bbox1.y)
            || i(bbox2, bbox1.x, bbox1.y2)
            || i(bbox2, bbox1.x2, bbox1.y2)
            || i(bbox1, bbox2.x, bbox2.y)
            || i(bbox1, bbox2.x2, bbox2.y)
            || i(bbox1, bbox2.x, bbox2.y2)
            || i(bbox1, bbox2.x2, bbox2.y2)
            || (bbox1.x &lt; bbox2.x2 &amp;&amp; bbox1.x &gt; bbox2.x || bbox2.x &lt; bbox1.x2 &amp;&amp; bbox2.x &gt; bbox1.x)
            &amp;&amp; (bbox1.y &lt; bbox2.y2 &amp;&amp; bbox1.y &gt; bbox2.y || bbox2.y &lt; bbox1.y2 &amp;&amp; bbox2.y &gt; bbox1.y);
    };
    <span class="function"><span class="keyword">function</span> <span class="title">base3</span><span class="params">(t, p1, p2, p3, p4)</span> {</span>
        <span class="keyword">var</span> t1 = -<span class="number">3</span> * p1 + <span class="number">9</span> * p2 - <span class="number">9</span> * p3 + <span class="number">3</span> * p4,
            t2 = t * t1 + <span class="number">6</span> * p1 - <span class="number">12</span> * p2 + <span class="number">6</span> * p3;
        <span class="keyword">return</span> t * t2 - <span class="number">3</span> * p1 + <span class="number">3</span> * p2;
    }
    <span class="function"><span class="keyword">function</span> <span class="title">bezlen</span><span class="params">(x1, y1, x2, y2, x3, y3, x4, y4, z)</span> {</span>
        <span class="keyword">if</span> (z == <span class="literal">null</span>) {
            z = <span class="number">1</span>;
        }
        z = z &gt; <span class="number">1</span> ? <span class="number">1</span> : z &lt; <span class="number">0</span> ? <span class="number">0</span> : z;
        <span class="keyword">var</span> z2 = z / <span class="number">2</span>,
            n = <span class="number">12</span>,
            Tvalues = [-<span class="number">0.1252</span>,<span class="number">0.1252</span>,-<span class="number">0.3678</span>,<span class="number">0.3678</span>,-<span class="number">0.5873</span>,<span class="number">0.5873</span>,-<span class="number">0.7699</span>,<span class="number">0.7699</span>,-<span class="number">0.9041</span>,<span class="number">0.9041</span>,-<span class="number">0.9816</span>,<span class="number">0.9816</span>],
            Cvalues = [<span class="number">0.2491</span>,<span class="number">0.2491</span>,<span class="number">0.2335</span>,<span class="number">0.2335</span>,<span class="number">0.2032</span>,<span class="number">0.2032</span>,<span class="number">0.1601</span>,<span class="number">0.1601</span>,<span class="number">0.1069</span>,<span class="number">0.1069</span>,<span class="number">0.0472</span>,<span class="number">0.0472</span>],
            sum = <span class="number">0</span>;
        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i++) {
            <span class="keyword">var</span> ct = z2 * Tvalues[i] + z2,
                xbase = base3(ct, x1, x2, x3, x4),
                ybase = base3(ct, y1, y2, y3, y4),
                comb = xbase * xbase + ybase * ybase;
            sum += Cvalues[i] * math.sqrt(comb);
        }
        <span class="keyword">return</span> z2 * sum;
    }
    <span class="function"><span class="keyword">function</span> <span class="title">getTatLen</span><span class="params">(x1, y1, x2, y2, x3, y3, x4, y4, ll)</span> {</span>
        <span class="keyword">if</span> (ll &lt; <span class="number">0</span> || bezlen(x1, y1, x2, y2, x3, y3, x4, y4) &lt; ll) {
            <span class="keyword">return</span>;
        }
        <span class="keyword">var</span> t = <span class="number">1</span>,
            step = t / <span class="number">2</span>,
            t2 = t - step,
            l,
            e = <span class="number">.01</span>;
        l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
        <span class="keyword">while</span> (abs(l - ll) &gt; e) {
            step /= <span class="number">2</span>;
            t2 += (l &lt; ll ? <span class="number">1</span> : -<span class="number">1</span>) * step;
            l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
        }
        <span class="keyword">return</span> t2;
    }
    <span class="function"><span class="keyword">function</span> <span class="title">intersect</span><span class="params">(x1, y1, x2, y2, x3, y3, x4, y4)</span> {</span>
        <span class="keyword">if</span> (
            mmax(x1, x2) &lt; mmin(x3, x4) ||
            mmin(x1, x2) &gt; mmax(x3, x4) ||
            mmax(y1, y2) &lt; mmin(y3, y4) ||
            mmin(y1, y2) &gt; mmax(y3, y4)
        ) {
            <span class="keyword">return</span>;
        }
        <span class="keyword">var</span> nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),
            ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),
            denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);

        <span class="keyword">if</span> (!denominator) {
            <span class="keyword">return</span>;
        }
        <span class="keyword">var</span> px = nx / denominator,
            py = ny / denominator,
            px2 = +px.toFixed(<span class="number">2</span>),
            py2 = +py.toFixed(<span class="number">2</span>);
        <span class="keyword">if</span> (
            px2 &lt; +mmin(x1, x2).toFixed(<span class="number">2</span>) ||
            px2 &gt; +mmax(x1, x2).toFixed(<span class="number">2</span>) ||
            px2 &lt; +mmin(x3, x4).toFixed(<span class="number">2</span>) ||
            px2 &gt; +mmax(x3, x4).toFixed(<span class="number">2</span>) ||
            py2 &lt; +mmin(y1, y2).toFixed(<span class="number">2</span>) ||
            py2 &gt; +mmax(y1, y2).toFixed(<span class="number">2</span>) ||
            py2 &lt; +mmin(y3, y4).toFixed(<span class="number">2</span>) ||
            py2 &gt; +mmax(y3, y4).toFixed(<span class="number">2</span>)
        ) {
            <span class="keyword">return</span>;
        }
        <span class="keyword">return</span> {x: px, y: py};
    }
    <span class="function"><span class="keyword">function</span> <span class="title">inter</span><span class="params">(bez1, bez2)</span> {</span>
        <span class="keyword">return</span> interHelper(bez1, bez2);
    }
    <span class="function"><span class="keyword">function</span> <span class="title">interCount</span><span class="params">(bez1, bez2)</span> {</span>
        <span class="keyword">return</span> interHelper(bez1, bez2, <span class="number">1</span>);
    }
    <span class="function"><span class="keyword">function</span> <span class="title">interHelper</span><span class="params">(bez1, bez2, justCount)</span> {</span>
        <span class="keyword">var</span> bbox1 = R.bezierBBox(bez1),
            bbox2 = R.bezierBBox(bez2);
        <span class="keyword">if</span> (!R.isBBoxIntersect(bbox1, bbox2)) {
            <span class="keyword">return</span> justCount ? <span class="number">0</span> : [];
        }
        <span class="keyword">var</span> l1 = bezlen.apply(<span class="number">0</span>, bez1),
            l2 = bezlen.apply(<span class="number">0</span>, bez2),
            n1 = ~~(l1 / <span class="number">5</span>),
            n2 = ~~(l2 / <span class="number">5</span>),
            dots1 = [],
            dots2 = [],
            xy = {},
            res = justCount ? <span class="number">0</span> : [];
        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n1 + <span class="number">1</span>; i++) {
            <span class="keyword">var</span> p = R.findDotsAtSegment.apply(R, bez1.concat(i / n1));
            dots1.push({x: p.x, y: p.y, t: i / n1});
        }
        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n2 + <span class="number">1</span>; i++) {
            p = R.findDotsAtSegment.apply(R, bez2.concat(i / n2));
            dots2.push({x: p.x, y: p.y, t: i / n2});
        }
        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n1; i++) {
            <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; n2; j++) {
                <span class="keyword">var</span> di = dots1[i],
                    di1 = dots1[i + <span class="number">1</span>],
                    dj = dots2[j],
                    dj1 = dots2[j + <span class="number">1</span>],
                    ci = abs(di1.x - di.x) &lt; <span class="number">.001</span> ? <span class="string">"y"</span> : <span class="string">"x"</span>,
                    cj = abs(dj1.x - dj.x) &lt; <span class="number">.001</span> ? <span class="string">"y"</span> : <span class="string">"x"</span>,
                    is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);
                <span class="keyword">if</span> (is) {
                    <span class="keyword">if</span> (xy[is.x.toFixed(<span class="number">4</span>)] == is.y.toFixed(<span class="number">4</span>)) {
                        <span class="keyword">continue</span>;
                    }
                    xy[is.x.toFixed(<span class="number">4</span>)] = is.y.toFixed(<span class="number">4</span>);
                    <span class="keyword">var</span> t1 = di.t + abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t),
                        t2 = dj.t + abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);
                    <span class="keyword">if</span> (t1 &gt;= <span class="number">0</span> &amp;&amp; t1 &lt;= <span class="number">1</span> &amp;&amp; t2 &gt;= <span class="number">0</span> &amp;&amp; t2 &lt;= <span class="number">1</span>) {
                        <span class="keyword">if</span> (justCount) {
                            res++;
                        } <span class="keyword">else</span> {
                            res.push({
                                x: is.x,
                                y: is.y,
                                t1: t1,
                                t2: t2
                            });
                        }
                    }
                }
            }
        }
        <span class="keyword">return</span> res;
    }
    <span class="comment">/*\
     * Raphael.pathIntersection
     [ method ]
     **
     * Utility method
     **
     * Finds intersections of two paths
     &gt; Parameters
     - path1 (string) path string
     - path2 (string) path string
     = (array) dots of intersection
     o [
     o     {
     o         x: (number) x coordinate of the point
     o         y: (number) y coordinate of the point
     o         t1: (number) t value for segment of path1
     o         t2: (number) t value for segment of path2
     o         segment1: (number) order number for segment of path1
     o         segment2: (number) order number for segment of path2
     o         bez1: (array) eight coordinates representing beziér curve for the segment of path1
     o         bez2: (array) eight coordinates representing beziér curve for the segment of path2
     o     }
     o ]
    \*/</span>
    R.pathIntersection = <span class="function"><span class="keyword">function</span> <span class="params">(path1, path2)</span> {</span>
        <span class="keyword">return</span> interPathHelper(path1, path2);
    };
    R.pathIntersectionNumber = <span class="function"><span class="keyword">function</span> <span class="params">(path1, path2)</span> {</span>
        <span class="keyword">return</span> interPathHelper(path1, path2, <span class="number">1</span>);
    };
    <span class="function"><span class="keyword">function</span> <span class="title">interPathHelper</span><span class="params">(path1, path2, justCount)</span> {</span>
        path1 = R._path2curve(path1);
        path2 = R._path2curve(path2);
        <span class="keyword">var</span> x1, y1, x2, y2, x1m, y1m, x2m, y2m, bez1, bez2,
            res = justCount ? <span class="number">0</span> : [];
        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, ii = path1.length; i &lt; ii; i++) {
            <span class="keyword">var</span> pi = path1[i];
            <span class="keyword">if</span> (pi[<span class="number">0</span>] == <span class="string">"M"</span>) {
                x1 = x1m = pi[<span class="number">1</span>];
                y1 = y1m = pi[<span class="number">2</span>];
            } <span class="keyword">else</span> {
                <span class="keyword">if</span> (pi[<span class="number">0</span>] == <span class="string">"C"</span>) {
                    bez1 = [x1, y1].concat(pi.slice(<span class="number">1</span>));
                    x1 = bez1[<span class="number">6</span>];
                    y1 = bez1[<span class="number">7</span>];
                } <span class="keyword">else</span> {
                    bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];
                    x1 = x1m;
                    y1 = y1m;
                }
                <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>, jj = path2.length; j &lt; jj; j++) {
                    <span class="keyword">var</span> pj = path2[j];
                    <span class="keyword">if</span> (pj[<span class="number">0</span>] == <span class="string">"M"</span>) {
                        x2 = x2m = pj[<span class="number">1</span>];
                        y2 = y2m = pj[<span class="number">2</span>];
                    } <span class="keyword">else</span> {
                        <span class="keyword">if</span> (pj[<span class="number">0</span>] == <span class="string">"C"</span>) {
                            bez2 = [x2, y2].concat(pj.slice(<span class="number">1</span>));
                            x2 = bez2[<span class="number">6</span>];
                            y2 = bez2[<span class="number">7</span>];
                        } <span class="keyword">else</span> {
                            bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];
                            x2 = x2m;
                            y2 = y2m;
                        }
                        <span class="keyword">var</span> intr = interHelper(bez1, bez2, justCount);
                        <span class="keyword">if</span> (justCount) {
                            res += intr;
                        } <span class="keyword">else</span> {
                            <span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>, kk = intr.length; k &lt; kk; k++) {
                                intr[k].segment1 = i;
                                intr[k].segment2 = j;
                                intr[k].bez1 = bez1;
                                intr[k].bez2 = bez2;
                            }
                            res = res.concat(intr);
                        }
                    }
                }
            }
        }
        <span class="keyword">return</span> res;
    }
    <span class="comment">/*\
     * Raphael.isPointInsidePath
     [ method ]
     **
     * Utility method
     **
     * Returns `true` if given point is inside a given closed path.
     &gt; Parameters
     - path (string) path string
     - x (number) x of the point
     - y (number) y of the point
     = (boolean) true, if point is inside the path
    \*/</span>
    R.isPointInsidePath = <span class="function"><span class="keyword">function</span> <span class="params">(path, x, y)</span> {</span>
        <span class="keyword">var</span> bbox = R.pathBBox(path);
        <span class="keyword">return</span> R.isPointInsideBBox(bbox, x, y) &amp;&amp;
               interPathHelper(path, [[<span class="string">"M"</span>, x, y], [<span class="string">"H"</span>, bbox.x2 + <span class="number">10</span>]], <span class="number">1</span>) % <span class="number">2</span> == <span class="number">1</span>;
    };
    R._removedFactory = <span class="function"><span class="keyword">function</span> <span class="params">(methodname)</span> {</span>
        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
            eve(<span class="string">"raphael.log"</span>, <span class="literal">null</span>, <span class="string">"Rapha\xebl: you are calling to method \u201c"</span> + methodname + <span class="string">"\u201d of removed object"</span>, methodname);
        };
    };
    <span class="comment">/*\
     * Raphael.pathBBox
     [ method ]
     **
     * Utility method
     **
     * Return bounding box of a given path
     &gt; Parameters
     - path (string) path string
     = (object) bounding box
     o {
     o     x: (number) x coordinate of the left top point of the box
     o     y: (number) y coordinate of the left top point of the box
     o     x2: (number) x coordinate of the right bottom point of the box
     o     y2: (number) y coordinate of the right bottom point of the box
     o     width: (number) width of the box
     o     height: (number) height of the box
     o     cx: (number) x coordinate of the center of the box
     o     cy: (number) y coordinate of the center of the box
     o }
    \*/</span>
    <span class="keyword">var</span> pathDimensions = R.pathBBox = <span class="function"><span class="keyword">function</span> <span class="params">(path)</span> {</span>
        <span class="keyword">var</span> pth = paths(path);
        <span class="keyword">if</span> (pth.bbox) {
            <span class="keyword">return</span> clone(pth.bbox);
        }
        <span class="keyword">if</span> (!path) {
            <span class="keyword">return</span> {x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">0</span>, height: <span class="number">0</span>, x2: <span class="number">0</span>, y2: <span class="number">0</span>};
        }
        path = path2curve(path);
        <span class="keyword">var</span> x = <span class="number">0</span>,
            y = <span class="number">0</span>,
            X = [],
            Y = [],
            p;
        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, ii = path.length; i &lt; ii; i++) {
            p = path[i];
            <span class="keyword">if</span> (p[<span class="number">0</span>] == <span class="string">"M"</span>) {
                x = p[<span class="number">1</span>];
                y = p[<span class="number">2</span>];
                X.push(x);
                Y.push(y);
            } <span class="keyword">else</span> {
                <span class="keyword">var</span> dim = curveDim(x, y, p[<span class="number">1</span>], p[<span class="number">2</span>], p[<span class="number">3</span>], p[<span class="number">4</span>], p[<span class="number">5</span>], p[<span class="number">6</span>]);
                X = X[concat](dim.min.x, dim.max.x);
                Y = Y[concat](dim.min.y, dim.max.y);
                x = p[<span class="number">5</span>];
                y = p[<span class="number">6</span>];
            }
        }
        <span class="keyword">var</span> xmin = mmin[apply](<span class="number">0</span>, X),
            ymin = mmin[apply](<span class="number">0</span>, Y),
            xmax = mmax[apply](<span class="number">0</span>, X),
            ymax = mmax[apply](<span class="number">0</span>, Y),
            width = xmax - xmin,
            height = ymax - ymin,
                bb = {
                x: xmin,
                y: ymin,
                x2: xmax,
                y2: ymax,
                width: width,
                height: height,
                cx: xmin + width / <span class="number">2</span>,
                cy: ymin + height / <span class="number">2</span>
            };
        pth.bbox = clone(bb);
        <span class="keyword">return</span> bb;
    },
        pathClone = <span class="function"><span class="keyword">function</span> <span class="params">(pathArray)</span> {</span>
            <span class="keyword">var</span> res = clone(pathArray);
            res.toString = R._path2string;
            <span class="keyword">return</span> res;
        },
        pathToRelative = R._pathToRelative = <span class="function"><span class="keyword">function</span> <span class="params">(pathArray)</span> {</span>
            <span class="keyword">var</span> pth = paths(pathArray);
            <span class="keyword">if</span> (pth.rel) {
                <span class="keyword">return</span> pathClone(pth.rel);
            }
            <span class="keyword">if</span> (!R.is(pathArray, array) || !R.is(pathArray &amp;&amp; pathArray[<span class="number">0</span>], array)) { <span class="comment">// rough assumption</span>
                pathArray = R.parsePathString(pathArray);
            }
            <span class="keyword">var</span> res = [],
                x = <span class="number">0</span>,
                y = <span class="number">0</span>,
                mx = <span class="number">0</span>,
                my = <span class="number">0</span>,
                start = <span class="number">0</span>;
            <span class="keyword">if</span> (pathArray[<span class="number">0</span>][<span class="number">0</span>] == <span class="string">"M"</span>) {
                x = pathArray[<span class="number">0</span>][<span class="number">1</span>];
                y = pathArray[<span class="number">0</span>][<span class="number">2</span>];
                mx = x;
                my = y;
                start++;
                res.push([<span class="string">"M"</span>, x, y]);
            }
            <span class="keyword">for</span> (<span class="keyword">var</span> i = start, ii = pathArray.length; i &lt; ii; i++) {
                <span class="keyword">var</span> r = res[i] = [],
                    pa = pathArray[i];
                <span class="keyword">if</span> (pa[<span class="number">0</span>] != lowerCase.call(pa[<span class="number">0</span>])) {
                    r[<span class="number">0</span>] = lowerCase.call(pa[<span class="number">0</span>]);
                    <span class="keyword">switch</span> (r[<span class="number">0</span>]) {
                        <span class="keyword">case</span> <span class="string">"a"</span>:
                            r[<span class="number">1</span>] = pa[<span class="number">1</span>];
                            r[<span class="number">2</span>] = pa[<span class="number">2</span>];
                            r[<span class="number">3</span>] = pa[<span class="number">3</span>];
                            r[<span class="number">4</span>] = pa[<span class="number">4</span>];
                            r[<span class="number">5</span>] = pa[<span class="number">5</span>];
                            r[<span class="number">6</span>] = +(pa[<span class="number">6</span>] - x).toFixed(<span class="number">3</span>);
                            r[<span class="number">7</span>] = +(pa[<span class="number">7</span>] - y).toFixed(<span class="number">3</span>);
                            <span class="keyword">break</span>;
                        <span class="keyword">case</span> <span class="string">"v"</span>:
                            r[<span class="number">1</span>] = +(pa[<span class="number">1</span>] - y).toFixed(<span class="number">3</span>);
                            <span class="keyword">break</span>;
                        <span class="keyword">case</span> <span class="string">"m"</span>:
                            mx = pa[<span class="number">1</span>];
                            my = pa[<span class="number">2</span>];
                        <span class="keyword">default</span>:
                            <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">1</span>, jj = pa.length; j &lt; jj; j++) {
                                r[j] = +(pa[j] - ((j % <span class="number">2</span>) ? x : y)).toFixed(<span class="number">3</span>);
                            }
                    }
                } <span class="keyword">else</span> {
                    r = res[i] = [];
                    <span class="keyword">if</span> (pa[<span class="number">0</span>] == <span class="string">"m"</span>) {
                        mx = pa[<span class="number">1</span>] + x;
                        my = pa[<span class="number">2</span>] + y;
                    }
                    <span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>, kk = pa.length; k &lt; kk; k++) {
                        res[i][k] = pa[k];
                    }
                }
                <span class="keyword">var</span> len = res[i].length;
                <span class="keyword">switch</span> (res[i][<span class="number">0</span>]) {
                    <span class="keyword">case</span> <span class="string">"z"</span>:
                        x = mx;
                        y = my;
                        <span class="keyword">break</span>;
                    <span class="keyword">case</span> <span class="string">"h"</span>:
                        x += +res[i][len - <span class="number">1</span>];
                        <span class="keyword">break</span>;
                    <span class="keyword">case</span> <span class="string">"v"</span>:
                        y += +res[i][len - <span class="number">1</span>];
                        <span class="keyword">break</span>;
                    <span class="keyword">default</span>:
                        x += +res[i][len - <span class="number">2</span>];
                        y += +res[i][len - <span class="number">1</span>];
                }
            }
            res.toString = R._path2string;
            pth.rel = pathClone(res);
            <span class="keyword">return</span> res;
        },
        pathToAbsolute = R._pathToAbsolute = <span class="function"><span class="keyword">function</span> <span class="params">(pathArray)</span> {</span>
            <span class="keyword">var</span> pth = paths(pathArray);
            <span class="keyword">if</span> (pth.abs) {
                <span class="keyword">return</span> pathClone(pth.abs);
            }
            <span class="keyword">if</span> (!R.is(pathArray, array) || !R.is(pathArray &amp;&amp; pathArray[<span class="number">0</span>], array)) { <span class="comment">// rough assumption</span>
                pathArray = R.parsePathString(pathArray);
            }
            <span class="keyword">if</span> (!pathArray || !pathArray.length) {
                <span class="keyword">return</span> [[<span class="string">"M"</span>, <span class="number">0</span>, <span class="number">0</span>]];
            }
            <span class="keyword">var</span> res = [],
                x = <span class="number">0</span>,
                y = <span class="number">0</span>,
                mx = <span class="number">0</span>,
                my = <span class="number">0</span>,
                start = <span class="number">0</span>;
            <span class="keyword">if</span> (pathArray[<span class="number">0</span>][<span class="number">0</span>] == <span class="string">"M"</span>) {
                x = +pathArray[<span class="number">0</span>][<span class="number">1</span>];
                y = +pathArray[<span class="number">0</span>][<span class="number">2</span>];
                mx = x;
                my = y;
                start++;
                res[<span class="number">0</span>] = [<span class="string">"M"</span>, x, y];
            }
            <span class="keyword">var</span> crz = pathArray.length == <span class="number">3</span> &amp;&amp; pathArray[<span class="number">0</span>][<span class="number">0</span>] == <span class="string">"M"</span> &amp;&amp; pathArray[<span class="number">1</span>][<span class="number">0</span>].toUpperCase() == <span class="string">"R"</span> &amp;&amp; pathArray[<span class="number">2</span>][<span class="number">0</span>].toUpperCase() == <span class="string">"Z"</span>;
            <span class="keyword">for</span> (<span class="keyword">var</span> r, pa, i = start, ii = pathArray.length; i &lt; ii; i++) {
                res.push(r = []);
                pa = pathArray[i];
                <span class="keyword">if</span> (pa[<span class="number">0</span>] != upperCase.call(pa[<span class="number">0</span>])) {
                    r[<span class="number">0</span>] = upperCase.call(pa[<span class="number">0</span>]);
                    <span class="keyword">switch</span> (r[<span class="number">0</span>]) {
                        <span class="keyword">case</span> <span class="string">"A"</span>:
                            r[<span class="number">1</span>] = pa[<span class="number">1</span>];
                            r[<span class="number">2</span>] = pa[<span class="number">2</span>];
                            r[<span class="number">3</span>] = pa[<span class="number">3</span>];
                            r[<span class="number">4</span>] = pa[<span class="number">4</span>];
                            r[<span class="number">5</span>] = pa[<span class="number">5</span>];
                            r[<span class="number">6</span>] = +(pa[<span class="number">6</span>] + x);
                            r[<span class="number">7</span>] = +(pa[<span class="number">7</span>] + y);
                            <span class="keyword">break</span>;
                        <span class="keyword">case</span> <span class="string">"V"</span>:
                            r[<span class="number">1</span>] = +pa[<span class="number">1</span>] + y;
                            <span class="keyword">break</span>;
                        <span class="keyword">case</span> <span class="string">"H"</span>:
                            r[<span class="number">1</span>] = +pa[<span class="number">1</span>] + x;
                            <span class="keyword">break</span>;
                        <span class="keyword">case</span> <span class="string">"R"</span>:
                            <span class="keyword">var</span> dots = [x, y][concat](pa.slice(<span class="number">1</span>));
                            <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">2</span>, jj = dots.length; j &lt; jj; j++) {
                                dots[j] = +dots[j] + x;
                                dots[++j] = +dots[j] + y;
                            }
                            res.pop();
                            res = res[concat](catmullRom2bezier(dots, crz));
                            <span class="keyword">break</span>;
                        <span class="keyword">case</span> <span class="string">"M"</span>:
                            mx = +pa[<span class="number">1</span>] + x;
                            my = +pa[<span class="number">2</span>] + y;
                        <span class="keyword">default</span>:
                            <span class="keyword">for</span> (j = <span class="number">1</span>, jj = pa.length; j &lt; jj; j++) {
                                r[j] = +pa[j] + ((j % <span class="number">2</span>) ? x : y);
                            }
                    }
                } <span class="keyword">else</span> <span class="keyword">if</span> (pa[<span class="number">0</span>] == <span class="string">"R"</span>) {
                    dots = [x, y][concat](pa.slice(<span class="number">1</span>));
                    res.pop();
                    res = res[concat](catmullRom2bezier(dots, crz));
                    r = [<span class="string">"R"</span>][concat](pa.slice(-<span class="number">2</span>));
                } <span class="keyword">else</span> {
                    <span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>, kk = pa.length; k &lt; kk; k++) {
                        r[k] = pa[k];
                    }
                }
                <span class="keyword">switch</span> (r[<span class="number">0</span>]) {
                    <span class="keyword">case</span> <span class="string">"Z"</span>:
                        x = mx;
                        y = my;
                        <span class="keyword">break</span>;
                    <span class="keyword">case</span> <span class="string">"H"</span>:
                        x = r[<span class="number">1</span>];
                        <span class="keyword">break</span>;
                    <span class="keyword">case</span> <span class="string">"V"</span>:
                        y = r[<span class="number">1</span>];
                        <span class="keyword">break</span>;
                    <span class="keyword">case</span> <span class="string">"M"</span>:
                        mx = r[r.length - <span class="number">2</span>];
                        my = r[r.length - <span class="number">1</span>];
                    <span class="keyword">default</span>:
                        x = r[r.length - <span class="number">2</span>];
                        y = r[r.length - <span class="number">1</span>];
                }
            }
            res.toString = R._path2string;
            pth.abs = pathClone(res);
            <span class="keyword">return</span> res;
        },
        l2c = <span class="function"><span class="keyword">function</span> <span class="params">(x1, y1, x2, y2)</span> {</span>
            <span class="keyword">return</span> [x1, y1, x2, y2, x2, y2];
        },
        q2c = <span class="function"><span class="keyword">function</span> <span class="params">(x1, y1, ax, ay, x2, y2)</span> {</span>
            <span class="keyword">var</span> _13 = <span class="number">1</span> / <span class="number">3</span>,
                _23 = <span class="number">2</span> / <span class="number">3</span>;
            <span class="keyword">return</span> [
                    _13 * x1 + _23 * ax,
                    _13 * y1 + _23 * ay,
                    _13 * x2 + _23 * ax,
                    _13 * y2 + _23 * ay,
                    x2,
                    y2
                ];
        },
        a2c = <span class="function"><span class="keyword">function</span> <span class="params">(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>for more information of where this math came from visit:
<a href="http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes">http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">var</span> _120 = PI * <span class="number">120</span> / <span class="number">180</span>,
                rad = PI / <span class="number">180</span> * (+angle || <span class="number">0</span>),
                res = [],
                xy,
                rotate = cacher(<span class="function"><span class="keyword">function</span> <span class="params">(x, y, rad)</span> {</span>
                    <span class="keyword">var</span> X = x * math.cos(rad) - y * math.sin(rad),
                        Y = x * math.sin(rad) + y * math.cos(rad);
                    <span class="keyword">return</span> {x: X, y: Y};
                });
            <span class="keyword">if</span> (!recursive) {
                xy = rotate(x1, y1, -rad);
                x1 = xy.x;
                y1 = xy.y;
                xy = rotate(x2, y2, -rad);
                x2 = xy.x;
                y2 = xy.y;
                <span class="keyword">var</span> cos = math.cos(PI / <span class="number">180</span> * angle),
                    sin = math.sin(PI / <span class="number">180</span> * angle),
                    x = (x1 - x2) / <span class="number">2</span>,
                    y = (y1 - y2) / <span class="number">2</span>;
                <span class="keyword">var</span> h = (x * x) / (rx * rx) + (y * y) / (ry * ry);
                <span class="keyword">if</span> (h &gt; <span class="number">1</span>) {
                    h = math.sqrt(h);
                    rx = h * rx;
                    ry = h * ry;
                }
                <span class="keyword">var</span> rx2 = rx * rx,
                    ry2 = ry * ry,
                    k = (large_arc_flag == sweep_flag ? -<span class="number">1</span> : <span class="number">1</span>) *
                        math.sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),
                    cx = k * rx * y / ry + (x1 + x2) / <span class="number">2</span>,
                    cy = k * -ry * x / rx + (y1 + y2) / <span class="number">2</span>,
                    f1 = math.asin(((y1 - cy) / ry).toFixed(<span class="number">9</span>)),
                    f2 = math.asin(((y2 - cy) / ry).toFixed(<span class="number">9</span>));

                f1 = x1 &lt; cx ? PI - f1 : f1;
                f2 = x2 &lt; cx ? PI - f2 : f2;
                f1 &lt; <span class="number">0</span> &amp;&amp; (f1 = PI * <span class="number">2</span> + f1);
                f2 &lt; <span class="number">0</span> &amp;&amp; (f2 = PI * <span class="number">2</span> + f2);
                <span class="keyword">if</span> (sweep_flag &amp;&amp; f1 &gt; f2) {
                    f1 = f1 - PI * <span class="number">2</span>;
                }
                <span class="keyword">if</span> (!sweep_flag &amp;&amp; f2 &gt; f1) {
                    f2 = f2 - PI * <span class="number">2</span>;
                }
            } <span class="keyword">else</span> {
                f1 = recursive[<span class="number">0</span>];
                f2 = recursive[<span class="number">1</span>];
                cx = recursive[<span class="number">2</span>];
                cy = recursive[<span class="number">3</span>];
            }
            <span class="keyword">var</span> df = f2 - f1;
            <span class="keyword">if</span> (abs(df) &gt; _120) {
                <span class="keyword">var</span> f2old = f2,
                    x2old = x2,
                    y2old = y2;
                f2 = f1 + _120 * (sweep_flag &amp;&amp; f2 &gt; f1 ? <span class="number">1</span> : -<span class="number">1</span>);
                x2 = cx + rx * math.cos(f2);
                y2 = cy + ry * math.sin(f2);
                res = a2c(x2, y2, rx, ry, angle, <span class="number">0</span>, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
            }
            df = f2 - f1;
            <span class="keyword">var</span> c1 = math.cos(f1),
                s1 = math.sin(f1),
                c2 = math.cos(f2),
                s2 = math.sin(f2),
                t = math.tan(df / <span class="number">4</span>),
                hx = <span class="number">4</span> / <span class="number">3</span> * rx * t,
                hy = <span class="number">4</span> / <span class="number">3</span> * ry * t,
                m1 = [x1, y1],
                m2 = [x1 + hx * s1, y1 - hy * c1],
                m3 = [x2 + hx * s2, y2 - hy * c2],
                m4 = [x2, y2];
            m2[<span class="number">0</span>] = <span class="number">2</span> * m1[<span class="number">0</span>] - m2[<span class="number">0</span>];
            m2[<span class="number">1</span>] = <span class="number">2</span> * m1[<span class="number">1</span>] - m2[<span class="number">1</span>];
            <span class="keyword">if</span> (recursive) {
                <span class="keyword">return</span> [m2, m3, m4][concat](res);
            } <span class="keyword">else</span> {
                res = [m2, m3, m4][concat](res).join()[split](<span class="string">","</span>);
                <span class="keyword">var</span> newres = [];
                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, ii = res.length; i &lt; ii; i++) {
                    newres[i] = i % <span class="number">2</span> ? rotate(res[i - <span class="number">1</span>], res[i], rad).y : rotate(res[i], res[i + <span class="number">1</span>], rad).x;
                }
                <span class="keyword">return</span> newres;
            }
        },
        findDotAtSegment = <span class="function"><span class="keyword">function</span> <span class="params">(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t)</span> {</span>
            <span class="keyword">var</span> t1 = <span class="number">1</span> - t;
            <span class="keyword">return</span> {
                x: pow(t1, <span class="number">3</span>) * p1x + pow(t1, <span class="number">2</span>) * <span class="number">3</span> * t * c1x + t1 * <span class="number">3</span> * t * t * c2x + pow(t, <span class="number">3</span>) * p2x,
                y: pow(t1, <span class="number">3</span>) * p1y + pow(t1, <span class="number">2</span>) * <span class="number">3</span> * t * c1y + t1 * <span class="number">3</span> * t * t * c2y + pow(t, <span class="number">3</span>) * p2y
            };
        },
        curveDim = cacher(<span class="function"><span class="keyword">function</span> <span class="params">(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y)</span> {</span>
            <span class="keyword">var</span> a = (c2x - <span class="number">2</span> * c1x + p1x) - (p2x - <span class="number">2</span> * c2x + c1x),
                b = <span class="number">2</span> * (c1x - p1x) - <span class="number">2</span> * (c2x - c1x),
                c = p1x - c1x,
                t1 = (-b + math.sqrt(b * b - <span class="number">4</span> * a * c)) / <span class="number">2</span> / a,
                t2 = (-b - math.sqrt(b * b - <span class="number">4</span> * a * c)) / <span class="number">2</span> / a,
                y = [p1y, p2y],
                x = [p1x, p2x],
                dot;
            abs(t1) &gt; <span class="string">"1e12"</span> &amp;&amp; (t1 = <span class="number">.5</span>);
            abs(t2) &gt; <span class="string">"1e12"</span> &amp;&amp; (t2 = <span class="number">.5</span>);
            <span class="keyword">if</span> (t1 &gt; <span class="number">0</span> &amp;&amp; t1 &lt; <span class="number">1</span>) {
                dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);
                x.push(dot.x);
                y.push(dot.y);
            }
            <span class="keyword">if</span> (t2 &gt; <span class="number">0</span> &amp;&amp; t2 &lt; <span class="number">1</span>) {
                dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);
                x.push(dot.x);
                y.push(dot.y);
            }
            a = (c2y - <span class="number">2</span> * c1y + p1y) - (p2y - <span class="number">2</span> * c2y + c1y);
            b = <span class="number">2</span> * (c1y - p1y) - <span class="number">2</span> * (c2y - c1y);
            c = p1y - c1y;
            t1 = (-b + math.sqrt(b * b - <span class="number">4</span> * a * c)) / <span class="number">2</span> / a;
            t2 = (-b - math.sqrt(b * b - <span class="number">4</span> * a * c)) / <span class="number">2</span> / a;
            abs(t1) &gt; <span class="string">"1e12"</span> &amp;&amp; (t1 = <span class="number">.5</span>);
            abs(t2) &gt; <span class="string">"1e12"</span> &amp;&amp; (t2 = <span class="number">.5</span>);
            <span class="keyword">if</span> (t1 &gt; <span class="number">0</span> &amp;&amp; t1 &lt; <span class="number">1</span>) {
                dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);
                x.push(dot.x);
                y.push(dot.y);
            }
            <span class="keyword">if</span> (t2 &gt; <span class="number">0</span> &amp;&amp; t2 &lt; <span class="number">1</span>) {
                dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);
                x.push(dot.x);
                y.push(dot.y);
            }
            <span class="keyword">return</span> {
                min: {x: mmin[apply](<span class="number">0</span>, x), y: mmin[apply](<span class="number">0</span>, y)},
                max: {x: mmax[apply](<span class="number">0</span>, x), y: mmax[apply](<span class="number">0</span>, y)}
            };
        }),
        path2curve = R._path2curve = cacher(<span class="function"><span class="keyword">function</span> <span class="params">(path, path2)</span> {</span>
            <span class="keyword">var</span> pth = !path2 &amp;&amp; paths(path);
            <span class="keyword">if</span> (!path2 &amp;&amp; pth.curve) {
                <span class="keyword">return</span> pathClone(pth.curve);
            }
            <span class="keyword">var</span> p = pathToAbsolute(path),
                p2 = path2 &amp;&amp; pathToAbsolute(path2),
                attrs = {x: <span class="number">0</span>, y: <span class="number">0</span>, bx: <span class="number">0</span>, by: <span class="number">0</span>, X: <span class="number">0</span>, Y: <span class="number">0</span>, qx: <span class="literal">null</span>, qy: <span class="literal">null</span>},
                attrs2 = {x: <span class="number">0</span>, y: <span class="number">0</span>, bx: <span class="number">0</span>, by: <span class="number">0</span>, X: <span class="number">0</span>, Y: <span class="number">0</span>, qx: <span class="literal">null</span>, qy: <span class="literal">null</span>},
                processPath = <span class="function"><span class="keyword">function</span> <span class="params">(path, d)</span> {</span>
                    <span class="keyword">var</span> nx, ny;
                    <span class="keyword">if</span> (!path) {
                        <span class="keyword">return</span> [<span class="string">"C"</span>, d.x, d.y, d.x, d.y, d.x, d.y];
                    }
                    !(path[<span class="number">0</span>] <span class="keyword">in</span> {T:<span class="number">1</span>, Q:<span class="number">1</span>}) &amp;&amp; (d.qx = d.qy = <span class="literal">null</span>);
                    <span class="keyword">switch</span> (path[<span class="number">0</span>]) {
                        <span class="keyword">case</span> <span class="string">"M"</span>:
                            d.X = path[<span class="number">1</span>];
                            d.Y = path[<span class="number">2</span>];
                            <span class="keyword">break</span>;
                        <span class="keyword">case</span> <span class="string">"A"</span>:
                            path = [<span class="string">"C"</span>][concat](a2c[apply](<span class="number">0</span>, [d.x, d.y][concat](path.slice(<span class="number">1</span>))));
                            <span class="keyword">break</span>;
                        <span class="keyword">case</span> <span class="string">"S"</span>:
                            nx = d.x + (d.x - (d.bx || d.x));
                            ny = d.y + (d.y - (d.by || d.y));
                            path = [<span class="string">"C"</span>, nx, ny][concat](path.slice(<span class="number">1</span>));
                            <span class="keyword">break</span>;
                        <span class="keyword">case</span> <span class="string">"T"</span>:
                            d.qx = d.x + (d.x - (d.qx || d.x));
                            d.qy = d.y + (d.y - (d.qy || d.y));
                            path = [<span class="string">"C"</span>][concat](q2c(d.x, d.y, d.qx, d.qy, path[<span class="number">1</span>], path[<span class="number">2</span>]));
                            <span class="keyword">break</span>;
                        <span class="keyword">case</span> <span class="string">"Q"</span>:
                            d.qx = path[<span class="number">1</span>];
                            d.qy = path[<span class="number">2</span>];
                            path = [<span class="string">"C"</span>][concat](q2c(d.x, d.y, path[<span class="number">1</span>], path[<span class="number">2</span>], path[<span class="number">3</span>], path[<span class="number">4</span>]));
                            <span class="keyword">break</span>;
                        <span class="keyword">case</span> <span class="string">"L"</span>:
                            path = [<span class="string">"C"</span>][concat](l2c(d.x, d.y, path[<span class="number">1</span>], path[<span class="number">2</span>]));
                            <span class="keyword">break</span>;
                        <span class="keyword">case</span> <span class="string">"H"</span>:
                            path = [<span class="string">"C"</span>][concat](l2c(d.x, d.y, path[<span class="number">1</span>], d.y));
                            <span class="keyword">break</span>;
                        <span class="keyword">case</span> <span class="string">"V"</span>:
                            path = [<span class="string">"C"</span>][concat](l2c(d.x, d.y, d.x, path[<span class="number">1</span>]));
                            <span class="keyword">break</span>;
                        <span class="keyword">case</span> <span class="string">"Z"</span>:
                            path = [<span class="string">"C"</span>][concat](l2c(d.x, d.y, d.X, d.Y));
                            <span class="keyword">break</span>;
                    }
                    <span class="keyword">return</span> path;
                },
                fixArc = <span class="function"><span class="keyword">function</span> <span class="params">(pp, i)</span> {</span>
                    <span class="keyword">if</span> (pp[i].length &gt; <span class="number">7</span>) {
                        pp[i].shift();
                        <span class="keyword">var</span> pi = pp[i];
                        <span class="keyword">while</span> (pi.length) {
                            pp.splice(i++, <span class="number">0</span>, [<span class="string">"C"</span>][concat](pi.splice(<span class="number">0</span>, <span class="number">6</span>)));
                        }
                        pp.splice(i, <span class="number">1</span>);
                        ii = mmax(p.length, p2 &amp;&amp; p2.length || <span class="number">0</span>);
                    }
                },
                fixM = <span class="function"><span class="keyword">function</span> <span class="params">(path1, path2, a1, a2, i)</span> {</span>
                    <span class="keyword">if</span> (path1 &amp;&amp; path2 &amp;&amp; path1[i][<span class="number">0</span>] == <span class="string">"M"</span> &amp;&amp; path2[i][<span class="number">0</span>] != <span class="string">"M"</span>) {
                        path2.splice(i, <span class="number">0</span>, [<span class="string">"M"</span>, a2.x, a2.y]);
                        a1.bx = <span class="number">0</span>;
                        a1.by = <span class="number">0</span>;
                        a1.x = path1[i][<span class="number">1</span>];
                        a1.y = path1[i][<span class="number">2</span>];
                        ii = mmax(p.length, p2 &amp;&amp; p2.length || <span class="number">0</span>);
                    }
                };
            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, ii = mmax(p.length, p2 &amp;&amp; p2.length || <span class="number">0</span>); i &lt; ii; i++) {
                p[i] = processPath(p[i], attrs);
                fixArc(p, i);
                p2 &amp;&amp; (p2[i] = processPath(p2[i], attrs2));
                p2 &amp;&amp; fixArc(p2, i);
                fixM(p, p2, attrs, attrs2, i);
                fixM(p2, p, attrs2, attrs, i);
                <span class="keyword">var</span> seg = p[i],
                    seg2 = p2 &amp;&amp; p2[i],
                    seglen = seg.length,
                    seg2len = p2 &amp;&amp; seg2.length;
                attrs.x = seg[seglen - <span class="number">2</span>];
                attrs.y = seg[seglen - <span class="number">1</span>];
                attrs.bx = toFloat(seg[seglen - <span class="number">4</span>]) || attrs.x;
                attrs.by = toFloat(seg[seglen - <span class="number">3</span>]) || attrs.y;
                attrs2.bx = p2 &amp;&amp; (toFloat(seg2[seg2len - <span class="number">4</span>]) || attrs2.x);
                attrs2.by = p2 &amp;&amp; (toFloat(seg2[seg2len - <span class="number">3</span>]) || attrs2.y);
                attrs2.x = p2 &amp;&amp; seg2[seg2len - <span class="number">2</span>];
                attrs2.y = p2 &amp;&amp; seg2[seg2len - <span class="number">1</span>];
            }
            <span class="keyword">if</span> (!p2) {
                pth.curve = pathClone(p);
            }
            <span class="keyword">return</span> p2 ? [p, p2] : p;
        }, <span class="literal">null</span>, pathClone),
        parseDots = R._parseDots = cacher(<span class="function"><span class="keyword">function</span> <span class="params">(gradient)</span> {</span>
            <span class="keyword">var</span> dots = [];
            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, ii = gradient.length; i &lt; ii; i++) {
                <span class="keyword">var</span> dot = {},
                    par = gradient[i].match(<span class="regexp">/^([^:]*):?([\d\.]*)/</span>);
                dot.color = R.getRGB(par[<span class="number">1</span>]);
                <span class="keyword">if</span> (dot.color.error) {
                    <span class="keyword">return</span> <span class="literal">null</span>;
                }
                dot.color = dot.color.hex;
                par[<span class="number">2</span>] &amp;&amp; (dot.offset = par[<span class="number">2</span>] + <span class="string">"%"</span>);
                dots.push(dot);
            }
            <span class="keyword">for</span> (i = <span class="number">1</span>, ii = dots.length - <span class="number">1</span>; i &lt; ii; i++) {
                <span class="keyword">if</span> (!dots[i].offset) {
                    <span class="keyword">var</span> start = toFloat(dots[i - <span class="number">1</span>].offset || <span class="number">0</span>),
                        end = <span class="number">0</span>;
                    <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; ii; j++) {
                        <span class="keyword">if</span> (dots[j].offset) {
                            end = dots[j].offset;
                            <span class="keyword">break</span>;
                        }
                    }
                    <span class="keyword">if</span> (!end) {
                        end = <span class="number">100</span>;
                        j = ii;
                    }
                    end = toFloat(end);
                    <span class="keyword">var</span> d = (end - start) / (j - i + <span class="number">1</span>);
                    <span class="keyword">for</span> (; i &lt; j; i++) {
                        start += d;
                        dots[i].offset = start + <span class="string">"%"</span>;
                    }
                }
            }
            <span class="keyword">return</span> dots;
        }),
        tear = R._tear = <span class="function"><span class="keyword">function</span> <span class="params">(el, paper)</span> {</span>
            el == paper.top &amp;&amp; (paper.top = el.prev);
            el == paper.bottom &amp;&amp; (paper.bottom = el.next);
            el.next &amp;&amp; (el.next.prev = el.prev);
            el.prev &amp;&amp; (el.prev.next = el.next);
        },
        tofront = R._tofront = <span class="function"><span class="keyword">function</span> <span class="params">(el, paper)</span> {</span>
            <span class="keyword">if</span> (paper.top === el) {
                <span class="keyword">return</span>;
            }
            tear(el, paper);
            el.next = <span class="literal">null</span>;
            el.prev = paper.top;
            paper.top.next = el;
            paper.top = el;
        },
        toback = R._toback = <span class="function"><span class="keyword">function</span> <span class="params">(el, paper)</span> {</span>
            <span class="keyword">if</span> (paper.bottom === el) {
                <span class="keyword">return</span>;
            }
            tear(el, paper);
            el.next = paper.bottom;
            el.prev = <span class="literal">null</span>;
            paper.bottom.prev = el;
            paper.bottom = el;
        },
        insertafter = R._insertafter = <span class="function"><span class="keyword">function</span> <span class="params">(el, el2, paper)</span> {</span>
            tear(el, paper);
            el2 == paper.top &amp;&amp; (paper.top = el);
            el2.next &amp;&amp; (el2.next.prev = el);
            el.next = el2.next;
            el.prev = el2;
            el2.next = el;
        },
        insertbefore = R._insertbefore = <span class="function"><span class="keyword">function</span> <span class="params">(el, el2, paper)</span> {</span>
            tear(el, paper);
            el2 == paper.bottom &amp;&amp; (paper.bottom = el);
            el2.prev &amp;&amp; (el2.prev.next = el);
            el.prev = el2.prev;
            el2.prev = el;
            el.next = el2;
        },
        <span class="comment">/*\
         * Raphael.toMatrix
         [ method ]
         **
         * Utility method
         **
         * Returns matrix of transformations applied to a given path
         &gt; Parameters
         - path (string) path string
         - transform (string|array) transformation string
         = (object) @Matrix
        \*/</span>
        toMatrix = R.toMatrix = <span class="function"><span class="keyword">function</span> <span class="params">(path, transform)</span> {</span>
            <span class="keyword">var</span> bb = pathDimensions(path),
                el = {
                    _: {
                        transform: E
                    },
                    getBBox: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
                        <span class="keyword">return</span> bb;
                    }
                };
            extractTransform(el, transform);
            <span class="keyword">return</span> el.matrix;
        },
        <span class="comment">/*\
         * Raphael.transformPath
         [ method ]
         **
         * Utility method
         **
         * Returns path transformed by a given transformation
         &gt; Parameters
         - path (string) path string
         - transform (string|array) transformation string
         = (string) path
        \*/</span>
        transformPath = R.transformPath = <span class="function"><span class="keyword">function</span> <span class="params">(path, transform)</span> {</span>
            <span class="keyword">return</span> mapPath(path, toMatrix(path, transform));
        },
        extractTransform = R._extractTransform = <span class="function"><span class="keyword">function</span> <span class="params">(el, tstr)</span> {</span>
            <span class="keyword">if</span> (tstr == <span class="literal">null</span>) {
                <span class="keyword">return</span> el._.transform;
            }
            tstr = Str(tstr).replace(<span class="regexp">/\.{3}|\u2026/g</span>, el._.transform || E);
            <span class="keyword">var</span> tdata = R.parseTransformString(tstr),
                deg = <span class="number">0</span>,
                dx = <span class="number">0</span>,
                dy = <span class="number">0</span>,
                sx = <span class="number">1</span>,
                sy = <span class="number">1</span>,
                _ = el._,
                m = <span class="keyword">new</span> Matrix;
            _.transform = tdata || [];
            <span class="keyword">if</span> (tdata) {
                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, ii = tdata.length; i &lt; ii; i++) {
                    <span class="keyword">var</span> t = tdata[i],
                        tlen = t.length,
                        command = Str(t[<span class="number">0</span>]).toLowerCase(),
                        absolute = t[<span class="number">0</span>] != command,
                        inver = absolute ? m.invert() : <span class="number">0</span>,
                        x1,
                        y1,
                        x2,
                        y2,
                        bb;
                    <span class="keyword">if</span> (command == <span class="string">"t"</span> &amp;&amp; tlen == <span class="number">3</span>) {
                        <span class="keyword">if</span> (absolute) {
                            x1 = inver.x(<span class="number">0</span>, <span class="number">0</span>);
                            y1 = inver.y(<span class="number">0</span>, <span class="number">0</span>);
                            x2 = inver.x(t[<span class="number">1</span>], t[<span class="number">2</span>]);
                            y2 = inver.y(t[<span class="number">1</span>], t[<span class="number">2</span>]);
                            m.translate(x2 - x1, y2 - y1);
                        } <span class="keyword">else</span> {
                            m.translate(t[<span class="number">1</span>], t[<span class="number">2</span>]);
                        }
                    } <span class="keyword">else</span> <span class="keyword">if</span> (command == <span class="string">"r"</span>) {
                        <span class="keyword">if</span> (tlen == <span class="number">2</span>) {
                            bb = bb || el.getBBox(<span class="number">1</span>);
                            m.rotate(t[<span class="number">1</span>], bb.x + bb.width / <span class="number">2</span>, bb.y + bb.height / <span class="number">2</span>);
                            deg += t[<span class="number">1</span>];
                        } <span class="keyword">else</span> <span class="keyword">if</span> (tlen == <span class="number">4</span>) {
                            <span class="keyword">if</span> (absolute) {
                                x2 = inver.x(t[<span class="number">2</span>], t[<span class="number">3</span>]);
                                y2 = inver.y(t[<span class="number">2</span>], t[<span class="number">3</span>]);
                                m.rotate(t[<span class="number">1</span>], x2, y2);
                            } <span class="keyword">else</span> {
                                m.rotate(t[<span class="number">1</span>], t[<span class="number">2</span>], t[<span class="number">3</span>]);
                            }
                            deg += t[<span class="number">1</span>];
                        }
                    } <span class="keyword">else</span> <span class="keyword">if</span> (command == <span class="string">"s"</span>) {
                        <span class="keyword">if</span> (tlen == <span class="number">2</span> || tlen == <span class="number">3</span>) {
                            bb = bb || el.getBBox(<span class="number">1</span>);
                            m.scale(t[<span class="number">1</span>], t[tlen - <span class="number">1</span>], bb.x + bb.width / <span class="number">2</span>, bb.y + bb.height / <span class="number">2</span>);
                            sx *= t[<span class="number">1</span>];
                            sy *= t[tlen - <span class="number">1</span>];
                        } <span class="keyword">else</span> <span class="keyword">if</span> (tlen == <span class="number">5</span>) {
                            <span class="keyword">if</span> (absolute) {
                                x2 = inver.x(t[<span class="number">3</span>], t[<span class="number">4</span>]);
                                y2 = inver.y(t[<span class="number">3</span>], t[<span class="number">4</span>]);
                                m.scale(t[<span class="number">1</span>], t[<span class="number">2</span>], x2, y2);
                            } <span class="keyword">else</span> {
                                m.scale(t[<span class="number">1</span>], t[<span class="number">2</span>], t[<span class="number">3</span>], t[<span class="number">4</span>]);
                            }
                            sx *= t[<span class="number">1</span>];
                            sy *= t[<span class="number">2</span>];
                        }
                    } <span class="keyword">else</span> <span class="keyword">if</span> (command == <span class="string">"m"</span> &amp;&amp; tlen == <span class="number">7</span>) {
                        m.add(t[<span class="number">1</span>], t[<span class="number">2</span>], t[<span class="number">3</span>], t[<span class="number">4</span>], t[<span class="number">5</span>], t[<span class="number">6</span>]);
                    }
                    _.dirtyT = <span class="number">1</span>;
                    el.matrix = m;
                }
            }

            <span class="comment">/*\
             * Element.matrix
             [ property (object) ]
             **
             * Keeps @Matrix object, which represents element transformation
            \*/</span>
            el.matrix = m;

            _.sx = sx;
            _.sy = sy;
            _.deg = deg;
            _.dx = dx = m.e;
            _.dy = dy = m.f;

            <span class="keyword">if</span> (sx == <span class="number">1</span> &amp;&amp; sy == <span class="number">1</span> &amp;&amp; !deg &amp;&amp; _.bbox) {
                _.bbox.x += +dx;
                _.bbox.y += +dy;
            } <span class="keyword">else</span> {
                _.dirtyT = <span class="number">1</span>;
            }
        },
        getEmpty = <span class="function"><span class="keyword">function</span> <span class="params">(item)</span> {</span>
            <span class="keyword">var</span> l = item[<span class="number">0</span>];
            <span class="keyword">switch</span> (l.toLowerCase()) {
                <span class="keyword">case</span> <span class="string">"t"</span>: <span class="keyword">return</span> [l, <span class="number">0</span>, <span class="number">0</span>];
                <span class="keyword">case</span> <span class="string">"m"</span>: <span class="keyword">return</span> [l, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>];
                <span class="keyword">case</span> <span class="string">"r"</span>: <span class="keyword">if</span> (item.length == <span class="number">4</span>) {
                    <span class="keyword">return</span> [l, <span class="number">0</span>, item[<span class="number">2</span>], item[<span class="number">3</span>]];
                } <span class="keyword">else</span> {
                    <span class="keyword">return</span> [l, <span class="number">0</span>];
                }
                <span class="keyword">case</span> <span class="string">"s"</span>: <span class="keyword">if</span> (item.length == <span class="number">5</span>) {
                    <span class="keyword">return</span> [l, <span class="number">1</span>, <span class="number">1</span>, item[<span class="number">3</span>], item[<span class="number">4</span>]];
                } <span class="keyword">else</span> <span class="keyword">if</span> (item.length == <span class="number">3</span>) {
                    <span class="keyword">return</span> [l, <span class="number">1</span>, <span class="number">1</span>];
                } <span class="keyword">else</span> {
                    <span class="keyword">return</span> [l, <span class="number">1</span>];
                }
            }
        },
        equaliseTransform = R._equaliseTransform = <span class="function"><span class="keyword">function</span> <span class="params">(t1, t2)</span> {</span>
            t2 = Str(t2).replace(<span class="regexp">/\.{3}|\u2026/g</span>, t1);
            t1 = R.parseTransformString(t1) || [];
            t2 = R.parseTransformString(t2) || [];
            <span class="keyword">var</span> maxlength = mmax(t1.length, t2.length),
                from = [],
                to = [],
                i = <span class="number">0</span>, j, jj,
                tt1, tt2;
            <span class="keyword">for</span> (; i &lt; maxlength; i++) {
                tt1 = t1[i] || getEmpty(t2[i]);
                tt2 = t2[i] || getEmpty(tt1);
                <span class="keyword">if</span> ((tt1[<span class="number">0</span>] != tt2[<span class="number">0</span>]) ||
                    (tt1[<span class="number">0</span>].toLowerCase() == <span class="string">"r"</span> &amp;&amp; (tt1[<span class="number">2</span>] != tt2[<span class="number">2</span>] || tt1[<span class="number">3</span>] != tt2[<span class="number">3</span>])) ||
                    (tt1[<span class="number">0</span>].toLowerCase() == <span class="string">"s"</span> &amp;&amp; (tt1[<span class="number">3</span>] != tt2[<span class="number">3</span>] || tt1[<span class="number">4</span>] != tt2[<span class="number">4</span>]))
                    ) {
                    <span class="keyword">return</span>;
                }
                from[i] = [];
                to[i] = [];
                <span class="keyword">for</span> (j = <span class="number">0</span>, jj = mmax(tt1.length, tt2.length); j &lt; jj; j++) {
                    j <span class="keyword">in</span> tt1 &amp;&amp; (from[i][j] = tt1[j]);
                    j <span class="keyword">in</span> tt2 &amp;&amp; (to[i][j] = tt2[j]);
                }
            }
            <span class="keyword">return</span> {
                from: from,
                to: to
            };
        };
    R._getContainer = <span class="function"><span class="keyword">function</span> <span class="params">(x, y, w, h)</span> {</span>
        <span class="keyword">var</span> container;
        container = h == <span class="literal">null</span> &amp;&amp; !R.is(x, <span class="string">"object"</span>) ? g.doc.getElementById(x) : x;
        <span class="keyword">if</span> (container == <span class="literal">null</span>) {
            <span class="keyword">return</span>;
        }
        <span class="keyword">if</span> (container.tagName) {
            <span class="keyword">if</span> (y == <span class="literal">null</span>) {
                <span class="keyword">return</span> {
                    container: container,
                    width: container.style.pixelWidth || container.offsetWidth,
                    height: container.style.pixelHeight || container.offsetHeight
                };
            } <span class="keyword">else</span> {
                <span class="keyword">return</span> {
                    container: container,
                    width: y,
                    height: w
                };
            }
        }
        <span class="keyword">return</span> {
            container: <span class="number">1</span>,
            x: x,
            y: y,
            width: w,
            height: h
        };
    };
    <span class="comment">/*\
     * Raphael.pathToRelative
     [ method ]
     **
     * Utility method
     **
     * Converts path to relative form
     &gt; Parameters
     - pathString (string|array) path string or array of segments
     = (array) array of segments.
    \*/</span>
    R.pathToRelative = pathToRelative;
    R._engine = {};
    <span class="comment">/*\
     * Raphael.path2curve
     [ method ]
     **
     * Utility method
     **
     * Converts path to a new path where all segments are cubic bezier curves.
     &gt; Parameters
     - pathString (string|array) path string or array of segments
     = (array) array of segments.
    \*/</span>
    R.path2curve = path2curve;
    <span class="comment">/*\
     * Raphael.matrix
     [ method ]
     **
     * Utility method
     **
     * Returns matrix based on given parameters.
     &gt; Parameters
     - a (number)
     - b (number)
     - c (number)
     - d (number)
     - e (number)
     - f (number)
     = (object) @Matrix
    \*/</span>
    R.matrix = <span class="function"><span class="keyword">function</span> <span class="params">(a, b, c, d, e, f)</span> {</span>
        <span class="keyword">return</span> <span class="keyword">new</span> Matrix(a, b, c, d, e, f);
    };
    <span class="function"><span class="keyword">function</span> <span class="title">Matrix</span><span class="params">(a, b, c, d, e, f)</span> {</span>
        <span class="keyword">if</span> (a != <span class="literal">null</span>) {
            <span class="keyword">this</span>.a = +a;
            <span class="keyword">this</span>.b = +b;
            <span class="keyword">this</span>.c = +c;
            <span class="keyword">this</span>.d = +d;
            <span class="keyword">this</span>.e = +e;
            <span class="keyword">this</span>.f = +f;
        } <span class="keyword">else</span> {
            <span class="keyword">this</span>.a = <span class="number">1</span>;
            <span class="keyword">this</span>.b = <span class="number">0</span>;
            <span class="keyword">this</span>.c = <span class="number">0</span>;
            <span class="keyword">this</span>.d = <span class="number">1</span>;
            <span class="keyword">this</span>.e = <span class="number">0</span>;
            <span class="keyword">this</span>.f = <span class="number">0</span>;
        }
    }
    (<span class="function"><span class="keyword">function</span> <span class="params">(matrixproto)</span> {</span>
        <span class="comment">/*\
         * Matrix.add
         [ method ]
         **
         * Adds given matrix to existing one.
         &gt; Parameters
         - a (number)
         - b (number)
         - c (number)
         - d (number)
         - e (number)
         - f (number)
         or
         - matrix (object) @Matrix
        \*/</span>
        matrixproto.add = <span class="function"><span class="keyword">function</span> <span class="params">(a, b, c, d, e, f)</span> {</span>
            <span class="keyword">var</span> out = [[], [], []],
                m = [[<span class="keyword">this</span>.a, <span class="keyword">this</span>.c, <span class="keyword">this</span>.e], [<span class="keyword">this</span>.b, <span class="keyword">this</span>.d, <span class="keyword">this</span>.f], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]],
                matrix = [[a, c, e], [b, d, f], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]],
                x, y, z, res;

            <span class="keyword">if</span> (a &amp;&amp; a <span class="keyword">instanceof</span> Matrix) {
                matrix = [[a.a, a.c, a.e], [a.b, a.d, a.f], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]];
            }

            <span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; <span class="number">3</span>; x++) {
                <span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; <span class="number">3</span>; y++) {
                    res = <span class="number">0</span>;
                    <span class="keyword">for</span> (z = <span class="number">0</span>; z &lt; <span class="number">3</span>; z++) {
                        res += m[x][z] * matrix[z][y];
                    }
                    out[x][y] = res;
                }
            }
            <span class="keyword">this</span>.a = out[<span class="number">0</span>][<span class="number">0</span>];
            <span class="keyword">this</span>.b = out[<span class="number">1</span>][<span class="number">0</span>];
            <span class="keyword">this</span>.c = out[<span class="number">0</span>][<span class="number">1</span>];
            <span class="keyword">this</span>.d = out[<span class="number">1</span>][<span class="number">1</span>];
            <span class="keyword">this</span>.e = out[<span class="number">0</span>][<span class="number">2</span>];
            <span class="keyword">this</span>.f = out[<span class="number">1</span>][<span class="number">2</span>];
        };
        <span class="comment">/*\
         * Matrix.invert
         [ method ]
         **
         * Returns inverted version of the matrix
         = (object) @Matrix
        \*/</span>
        matrixproto.invert = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
            <span class="keyword">var</span> me = <span class="keyword">this</span>,
                x = me.a * me.d - me.b * me.c;
            <span class="keyword">return</span> <span class="keyword">new</span> Matrix(me.d / x, -me.b / x, -me.c / x, me.a / x, (me.c * me.f - me.d * me.e) / x, (me.b * me.e - me.a * me.f) / x);
        };
        <span class="comment">/*\
         * Matrix.clone
         [ method ]
         **
         * Returns copy of the matrix
         = (object) @Matrix
        \*/</span>
        matrixproto.clone = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
            <span class="keyword">return</span> <span class="keyword">new</span> Matrix(<span class="keyword">this</span>.a, <span class="keyword">this</span>.b, <span class="keyword">this</span>.c, <span class="keyword">this</span>.d, <span class="keyword">this</span>.e, <span class="keyword">this</span>.f);
        };
        <span class="comment">/*\
         * Matrix.translate
         [ method ]
         **
         * Translate the matrix
         &gt; Parameters
         - x (number)
         - y (number)
        \*/</span>
        matrixproto.translate = <span class="function"><span class="keyword">function</span> <span class="params">(x, y)</span> {</span>
            <span class="keyword">this</span>.add(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, x, y);
        };
        <span class="comment">/*\
         * Matrix.scale
         [ method ]
         **
         * Scales the matrix
         &gt; Parameters
         - x (number)
         - y (number) #optional
         - cx (number) #optional
         - cy (number) #optional
        \*/</span>
        matrixproto.scale = <span class="function"><span class="keyword">function</span> <span class="params">(x, y, cx, cy)</span> {</span>
            y == <span class="literal">null</span> &amp;&amp; (y = x);
            (cx || cy) &amp;&amp; <span class="keyword">this</span>.add(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, cx, cy);
            <span class="keyword">this</span>.add(x, <span class="number">0</span>, <span class="number">0</span>, y, <span class="number">0</span>, <span class="number">0</span>);
            (cx || cy) &amp;&amp; <span class="keyword">this</span>.add(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -cx, -cy);
        };
        <span class="comment">/*\
         * Matrix.rotate
         [ method ]
         **
         * Rotates the matrix
         &gt; Parameters
         - a (number)
         - x (number)
         - y (number)
        \*/</span>
        matrixproto.rotate = <span class="function"><span class="keyword">function</span> <span class="params">(a, x, y)</span> {</span>
            a = R.rad(a);
            x = x || <span class="number">0</span>;
            y = y || <span class="number">0</span>;
            <span class="keyword">var</span> cos = +math.cos(a).toFixed(<span class="number">9</span>),
                sin = +math.sin(a).toFixed(<span class="number">9</span>);
            <span class="keyword">this</span>.add(cos, sin, -sin, cos, x, y);
            <span class="keyword">this</span>.add(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -x, -y);
        };
        <span class="comment">/*\
         * Matrix.x
         [ method ]
         **
         * Return x coordinate for given point after transformation described by the matrix. See also @Matrix.y
         &gt; Parameters
         - x (number)
         - y (number)
         = (number) x
        \*/</span>
        matrixproto.x = <span class="function"><span class="keyword">function</span> <span class="params">(x, y)</span> {</span>
            <span class="keyword">return</span> x * <span class="keyword">this</span>.a + y * <span class="keyword">this</span>.c + <span class="keyword">this</span>.e;
        };
        <span class="comment">/*\
         * Matrix.y
         [ method ]
         **
         * Return y coordinate for given point after transformation described by the matrix. See also @Matrix.x
         &gt; Parameters
         - x (number)
         - y (number)
         = (number) y
        \*/</span>
        matrixproto.y = <span class="function"><span class="keyword">function</span> <span class="params">(x, y)</span> {</span>
            <span class="keyword">return</span> x * <span class="keyword">this</span>.b + y * <span class="keyword">this</span>.d + <span class="keyword">this</span>.f;
        };
        matrixproto.get = <span class="function"><span class="keyword">function</span> <span class="params">(i)</span> {</span>
            <span class="keyword">return</span> +<span class="keyword">this</span>[Str.fromCharCode(<span class="number">97</span> + i)].toFixed(<span class="number">4</span>);
        };
        matrixproto.toString = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
            <span class="keyword">return</span> R.svg ?
                <span class="string">"matrix("</span> + [<span class="keyword">this</span>.get(<span class="number">0</span>), <span class="keyword">this</span>.get(<span class="number">1</span>), <span class="keyword">this</span>.get(<span class="number">2</span>), <span class="keyword">this</span>.get(<span class="number">3</span>), <span class="keyword">this</span>.get(<span class="number">4</span>), <span class="keyword">this</span>.get(<span class="number">5</span>)].join() + <span class="string">")"</span> :
                [<span class="keyword">this</span>.get(<span class="number">0</span>), <span class="keyword">this</span>.get(<span class="number">2</span>), <span class="keyword">this</span>.get(<span class="number">1</span>), <span class="keyword">this</span>.get(<span class="number">3</span>), <span class="number">0</span>, <span class="number">0</span>].join();
        };
        matrixproto.toFilter = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
            <span class="keyword">return</span> <span class="string">"progid:DXImageTransform.Microsoft.Matrix(M11="</span> + <span class="keyword">this</span>.get(<span class="number">0</span>) +
                <span class="string">", M12="</span> + <span class="keyword">this</span>.get(<span class="number">2</span>) + <span class="string">", M21="</span> + <span class="keyword">this</span>.get(<span class="number">1</span>) + <span class="string">", M22="</span> + <span class="keyword">this</span>.get(<span class="number">3</span>) +
                <span class="string">", Dx="</span> + <span class="keyword">this</span>.get(<span class="number">4</span>) + <span class="string">", Dy="</span> + <span class="keyword">this</span>.get(<span class="number">5</span>) + <span class="string">", sizingmethod='auto expand')"</span>;
        };
        matrixproto.offset = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
            <span class="keyword">return</span> [<span class="keyword">this</span>.e.toFixed(<span class="number">4</span>), <span class="keyword">this</span>.f.toFixed(<span class="number">4</span>)];
        };
        <span class="function"><span class="keyword">function</span> <span class="title">norm</span><span class="params">(a)</span> {</span>
            <span class="keyword">return</span> a[<span class="number">0</span>] * a[<span class="number">0</span>] + a[<span class="number">1</span>] * a[<span class="number">1</span>];
        }
        <span class="function"><span class="keyword">function</span> <span class="title">normalize</span><span class="params">(a)</span> {</span>
            <span class="keyword">var</span> mag = math.sqrt(norm(a));
            a[<span class="number">0</span>] &amp;&amp; (a[<span class="number">0</span>] /= mag);
            a[<span class="number">1</span>] &amp;&amp; (a[<span class="number">1</span>] /= mag);
        }
        <span class="comment">/*\
         * Matrix.split
         [ method ]
         **
         * Splits matrix into primitive transformations
         = (object) in format:
         o dx (number) translation by x
         o dy (number) translation by y
         o scalex (number) scale by x
         o scaley (number) scale by y
         o shear (number) shear
         o rotate (number) rotation in deg
         o isSimple (boolean) could it be represented via simple transformations
        \*/</span>
        matrixproto.split = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
            <span class="keyword">var</span> out = {};</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>translation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            out.dx = <span class="keyword">this</span>.e;
            out.dy = <span class="keyword">this</span>.f;</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>scale and shear</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">var</span> row = [[<span class="keyword">this</span>.a, <span class="keyword">this</span>.c], [<span class="keyword">this</span>.b, <span class="keyword">this</span>.d]];
            out.scalex = math.sqrt(norm(row[<span class="number">0</span>]));
            normalize(row[<span class="number">0</span>]);

            out.shear = row[<span class="number">0</span>][<span class="number">0</span>] * row[<span class="number">1</span>][<span class="number">0</span>] + row[<span class="number">0</span>][<span class="number">1</span>] * row[<span class="number">1</span>][<span class="number">1</span>];
            row[<span class="number">1</span>] = [row[<span class="number">1</span>][<span class="number">0</span>] - row[<span class="number">0</span>][<span class="number">0</span>] * out.shear, row[<span class="number">1</span>][<span class="number">1</span>] - row[<span class="number">0</span>][<span class="number">1</span>] * out.shear];

            out.scaley = math.sqrt(norm(row[<span class="number">1</span>]));
            normalize(row[<span class="number">1</span>]);
            out.shear /= out.scaley;</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>rotation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">var</span> sin = -row[<span class="number">0</span>][<span class="number">1</span>],
                cos = row[<span class="number">1</span>][<span class="number">1</span>];
            <span class="keyword">if</span> (cos &lt; <span class="number">0</span>) {
                out.rotate = R.deg(math.acos(cos));
                <span class="keyword">if</span> (sin &lt; <span class="number">0</span>) {
                    out.rotate = <span class="number">360</span> - out.rotate;
                }
            } <span class="keyword">else</span> {
                out.rotate = R.deg(math.asin(sin));
            }

            out.isSimple = !+out.shear.toFixed(<span class="number">9</span>) &amp;&amp; (out.scalex.toFixed(<span class="number">9</span>) == out.scaley.toFixed(<span class="number">9</span>) || !out.rotate);
            out.isSuperSimple = !+out.shear.toFixed(<span class="number">9</span>) &amp;&amp; out.scalex.toFixed(<span class="number">9</span>) == out.scaley.toFixed(<span class="number">9</span>) &amp;&amp; !out.rotate;
            out.noRotation = !+out.shear.toFixed(<span class="number">9</span>) &amp;&amp; !out.rotate;
            <span class="keyword">return</span> out;
        };
        <span class="comment">/*\
         * Matrix.toTransformString
         [ method ]
         **
         * Return transform string that represents given matrix
         = (string) transform string
        \*/</span>
        matrixproto.toTransformString = <span class="function"><span class="keyword">function</span> <span class="params">(shorter)</span> {</span>
            <span class="keyword">var</span> s = shorter || <span class="keyword">this</span>[split]();
            <span class="keyword">if</span> (s.isSimple) {
                s.scalex = +s.scalex.toFixed(<span class="number">4</span>);
                s.scaley = +s.scaley.toFixed(<span class="number">4</span>);
                s.rotate = +s.rotate.toFixed(<span class="number">4</span>);
                <span class="keyword">return</span>  (s.dx || s.dy ? <span class="string">"t"</span> + [s.dx, s.dy] : E) +
                        (s.scalex != <span class="number">1</span> || s.scaley != <span class="number">1</span> ? <span class="string">"s"</span> + [s.scalex, s.scaley, <span class="number">0</span>, <span class="number">0</span>] : E) +
                        (s.rotate ? <span class="string">"r"</span> + [s.rotate, <span class="number">0</span>, <span class="number">0</span>] : E);
            } <span class="keyword">else</span> {
                <span class="keyword">return</span> <span class="string">"m"</span> + [<span class="keyword">this</span>.get(<span class="number">0</span>), <span class="keyword">this</span>.get(<span class="number">1</span>), <span class="keyword">this</span>.get(<span class="number">2</span>), <span class="keyword">this</span>.get(<span class="number">3</span>), <span class="keyword">this</span>.get(<span class="number">4</span>), <span class="keyword">this</span>.get(<span class="number">5</span>)];
            }
        };
    })(Matrix.prototype);</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>WebKit rendering bug workaround method</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> version = navigator.userAgent.match(<span class="regexp">/Version\/(.*?)\s/</span>) || navigator.userAgent.match(<span class="regexp">/Chrome\/(\d+)/</span>);
    <span class="keyword">if</span> ((navigator.vendor == <span class="string">"Apple Computer, Inc."</span>) &amp;&amp; (version &amp;&amp; version[<span class="number">1</span>] &lt; <span class="number">4</span> || navigator.platform.slice(<span class="number">0</span>, <span class="number">2</span>) == <span class="string">"iP"</span>) ||
        (navigator.vendor == <span class="string">"Google Inc."</span> &amp;&amp; version &amp;&amp; version[<span class="number">1</span>] &lt; <span class="number">8</span>)) {
        <span class="comment">/*\
         * Paper.safari
         [ method ]
         **
         * There is an inconvenient rendering bug in Safari (WebKit):
         * sometimes the rendering should be forced.
         * This method should help with dealing with this bug.
        \*/</span>
        paperproto.safari = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
            <span class="keyword">var</span> rect = <span class="keyword">this</span>.rect(-<span class="number">99</span>, -<span class="number">99</span>, <span class="keyword">this</span>.width + <span class="number">99</span>, <span class="keyword">this</span>.height + <span class="number">99</span>).attr({stroke: <span class="string">"none"</span>});
            setTimeout(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>rect.remove();});
        };
    } <span class="keyword">else</span> {
        paperproto.safari = fun;
    }

    <span class="keyword">var</span> preventDefault = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">this</span>.returnValue = <span class="literal">false</span>;
    },
    preventTouch = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">return</span> <span class="keyword">this</span>.originalEvent.preventDefault();
    },
    stopPropagation = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">this</span>.cancelBubble = <span class="literal">true</span>;
    },
    stopTouch = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">return</span> <span class="keyword">this</span>.originalEvent.stopPropagation();
    },
    getEventPosition = <span class="function"><span class="keyword">function</span> <span class="params">(e)</span> {</span>
        <span class="keyword">var</span> scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
            scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft;

        <span class="keyword">return</span> {
            x: e.clientX + scrollX,
            y: e.clientY + scrollY
        };
    },
    addEvent = (<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">if</span> (g.doc.addEventListener) {
            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(obj, type, fn, element)</span> {</span>
                <span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> <span class="params">(e)</span> {</span>
                    <span class="keyword">var</span> pos = getEventPosition(e);
                    <span class="keyword">return</span> fn.call(element, e, pos.x, pos.y);
                };
                obj.addEventListener(type, f, <span class="literal">false</span>);

                <span class="keyword">if</span> (supportsTouch &amp;&amp; touchMap[type]) {
                    <span class="keyword">var</span> _f = <span class="function"><span class="keyword">function</span> <span class="params">(e)</span> {</span>
                        <span class="keyword">var</span> pos = getEventPosition(e),
                            olde = e;

                        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, ii = e.targetTouches &amp;&amp; e.targetTouches.length; i &lt; ii; i++) {
                            <span class="keyword">if</span> (e.targetTouches[i].target == obj) {
                                e = e.targetTouches[i];
                                e.originalEvent = olde;
                                e.preventDefault = preventTouch;
                                e.stopPropagation = stopTouch;
                                <span class="keyword">break</span>;
                            }
                        }

                        <span class="keyword">return</span> fn.call(element, e, pos.x, pos.y);
                    };

                    obj.addEventListener(touchMap[type], _f, <span class="literal">false</span>);
                }

                <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
                    obj.removeEventListener(type, f, <span class="literal">false</span>);

                    <span class="keyword">if</span> (supportsTouch &amp;&amp; touchMap[type])
                        obj.removeEventListener(touchMap[type], f, <span class="literal">false</span>);

                    <span class="keyword">return</span> <span class="literal">true</span>;
                };
            };
        } <span class="keyword">else</span> <span class="keyword">if</span> (g.doc.attachEvent) {
            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(obj, type, fn, element)</span> {</span>
                <span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> <span class="params">(e)</span> {</span>
                    e = e || g.win.event;
                    <span class="keyword">var</span> scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
                        scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft,
                        x = e.clientX + scrollX,
                        y = e.clientY + scrollY;
                    e.preventDefault = e.preventDefault || preventDefault;
                    e.stopPropagation = e.stopPropagation || stopPropagation;
                    <span class="keyword">return</span> fn.call(element, e, x, y);
                };
                obj.attachEvent(<span class="string">"on"</span> + type, f);
                <span class="keyword">var</span> detacher = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
                    obj.detachEvent(<span class="string">"on"</span> + type, f);
                    <span class="keyword">return</span> <span class="literal">true</span>;
                };
                <span class="keyword">return</span> detacher;
            };
        }
    })(),
    drag = [],
    dragMove = <span class="function"><span class="keyword">function</span> <span class="params">(e)</span> {</span>
        <span class="keyword">var</span> x = e.clientX,
            y = e.clientY,
            scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
            scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft,
            dragi,
            j = drag.length;
        <span class="keyword">while</span> (j--) {
            dragi = drag[j];
            <span class="keyword">if</span> (supportsTouch &amp;&amp; e.touches) {
                <span class="keyword">var</span> i = e.touches.length,
                    touch;
                <span class="keyword">while</span> (i--) {
                    touch = e.touches[i];
                    <span class="keyword">if</span> (touch.identifier == dragi.el._drag.id) {
                        x = touch.clientX;
                        y = touch.clientY;
                        (e.originalEvent ? e.originalEvent : e).preventDefault();
                        <span class="keyword">break</span>;
                    }
                }
            } <span class="keyword">else</span> {
                e.preventDefault();
            }
            <span class="keyword">var</span> node = dragi.el.node,
                o,
                next = node.nextSibling,
                parent = node.parentNode,
                display = node.style.display;
            g.win.opera &amp;&amp; parent.removeChild(node);
            node.style.display = <span class="string">"none"</span>;
            o = dragi.el.paper.getElementByPoint(x, y);
            node.style.display = display;
            g.win.opera &amp;&amp; (next ? parent.insertBefore(node, next) : parent.appendChild(node));
            o &amp;&amp; eve(<span class="string">"raphael.drag.over."</span> + dragi.el.id, dragi.el, o);
            x += scrollX;
            y += scrollY;
            eve(<span class="string">"raphael.drag.move."</span> + dragi.el.id, dragi.move_scope || dragi.el, x - dragi.el._drag.x, y - dragi.el._drag.y, x, y, e);
        }
    },
    dragUp = <span class="function"><span class="keyword">function</span> <span class="params">(e)</span> {</span>
        R.unmousemove(dragMove).unmouseup(dragUp);
        <span class="keyword">var</span> i = drag.length,
            dragi;
        <span class="keyword">while</span> (i--) {
            dragi = drag[i];
            dragi.el._drag = {};
            eve(<span class="string">"raphael.drag.end."</span> + dragi.el.id, dragi.end_scope || dragi.start_scope || dragi.move_scope || dragi.el, e);
        }
        drag = [];
    },
    <span class="comment">/*\
     * Raphael.el
     [ property (object) ]
     **
     * You can add your own method to elements. This is usefull when you want to hack default functionality or
     * want to wrap some common transformation or attributes in one method. In difference to canvas methods,
     * you can redefine element method at any time. Expending element methods wouldn’t affect set.
     &gt; Usage
     | Raphael.el.red = function () {
     |     this.attr({fill: "#f00"});
     | };
     | // then use it
     | paper.circle(100, 100, 20).red();
    \*/</span>
    elproto = R.el = {};
    <span class="comment">/*\
     * Element.click
     [ method ]
     **
     * Adds event handler for click for the element.
     &gt; Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/</span>
    <span class="comment">/*\
     * Element.unclick
     [ method ]
     **
     * Removes event handler for click for the element.
     &gt; Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
    \*/</span>

    <span class="comment">/*\
     * Element.dblclick
     [ method ]
     **
     * Adds event handler for double click for the element.
     &gt; Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/</span>
    <span class="comment">/*\
     * Element.undblclick
     [ method ]
     **
     * Removes event handler for double click for the element.
     &gt; Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
    \*/</span>

    <span class="comment">/*\
     * Element.mousedown
     [ method ]
     **
     * Adds event handler for mousedown for the element.
     &gt; Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/</span>
    <span class="comment">/*\
     * Element.unmousedown
     [ method ]
     **
     * Removes event handler for mousedown for the element.
     &gt; Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
    \*/</span>

    <span class="comment">/*\
     * Element.mousemove
     [ method ]
     **
     * Adds event handler for mousemove for the element.
     &gt; Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/</span>
    <span class="comment">/*\
     * Element.unmousemove
     [ method ]
     **
     * Removes event handler for mousemove for the element.
     &gt; Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
    \*/</span>

    <span class="comment">/*\
     * Element.mouseout
     [ method ]
     **
     * Adds event handler for mouseout for the element.
     &gt; Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/</span>
    <span class="comment">/*\
     * Element.unmouseout
     [ method ]
     **
     * Removes event handler for mouseout for the element.
     &gt; Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
    \*/</span>

    <span class="comment">/*\
     * Element.mouseover
     [ method ]
     **
     * Adds event handler for mouseover for the element.
     &gt; Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/</span>
    <span class="comment">/*\
     * Element.unmouseover
     [ method ]
     **
     * Removes event handler for mouseover for the element.
     &gt; Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
    \*/</span>

    <span class="comment">/*\
     * Element.mouseup
     [ method ]
     **
     * Adds event handler for mouseup for the element.
     &gt; Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/</span>
    <span class="comment">/*\
     * Element.unmouseup
     [ method ]
     **
     * Removes event handler for mouseup for the element.
     &gt; Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
    \*/</span>

    <span class="comment">/*\
     * Element.touchstart
     [ method ]
     **
     * Adds event handler for touchstart for the element.
     &gt; Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/</span>
    <span class="comment">/*\
     * Element.untouchstart
     [ method ]
     **
     * Removes event handler for touchstart for the element.
     &gt; Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
    \*/</span>

    <span class="comment">/*\
     * Element.touchmove
     [ method ]
     **
     * Adds event handler for touchmove for the element.
     &gt; Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/</span>
    <span class="comment">/*\
     * Element.untouchmove
     [ method ]
     **
     * Removes event handler for touchmove for the element.
     &gt; Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
    \*/</span>

    <span class="comment">/*\
     * Element.touchend
     [ method ]
     **
     * Adds event handler for touchend for the element.
     &gt; Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/</span>
    <span class="comment">/*\
     * Element.untouchend
     [ method ]
     **
     * Removes event handler for touchend for the element.
     &gt; Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
    \*/</span>

    <span class="comment">/*\
     * Element.touchcancel
     [ method ]
     **
     * Adds event handler for touchcancel for the element.
     &gt; Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/</span>
    <span class="comment">/*\
     * Element.untouchcancel
     [ method ]
     **
     * Removes event handler for touchcancel for the element.
     &gt; Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
    \*/</span>
    <span class="keyword">for</span> (<span class="keyword">var</span> i = events.length; i--;) {
        (<span class="function"><span class="keyword">function</span> <span class="params">(eventName)</span> {</span>
            R[eventName] = elproto[eventName] = <span class="function"><span class="keyword">function</span> <span class="params">(fn, scope)</span> {</span>
                <span class="keyword">if</span> (R.is(fn, <span class="string">"function"</span>)) {
                    <span class="keyword">this</span>.events = <span class="keyword">this</span>.events || [];
                    <span class="keyword">this</span>.events.push({name: eventName, f: fn, unbind: addEvent(<span class="keyword">this</span>.shape || <span class="keyword">this</span>.node || g.doc, eventName, fn, scope || <span class="keyword">this</span>)});
                }
                <span class="keyword">return</span> <span class="keyword">this</span>;
            };
            R[<span class="string">"un"</span> + eventName] = elproto[<span class="string">"un"</span> + eventName] = <span class="function"><span class="keyword">function</span> <span class="params">(fn)</span> {</span>
                <span class="keyword">var</span> events = <span class="keyword">this</span>.events || [],
                    l = events.length;
                <span class="keyword">while</span> (l--){
                    <span class="keyword">if</span> (events[l].name == eventName &amp;&amp; (R.is(fn, <span class="string">"undefined"</span>) || events[l].f == fn)) {
                        events[l].unbind();
                        events.splice(l, <span class="number">1</span>);
                        !events.length &amp;&amp; <span class="keyword">delete</span> <span class="keyword">this</span>.events;
                    }
                }
                <span class="keyword">return</span> <span class="keyword">this</span>;
            };
        })(events[i]);
    }

    <span class="comment">/*\
     * Element.data
     [ method ]
     **
     * Adds or retrieves given value asociated with given key.
     ** 
     * See also @Element.removeData
     &gt; Parameters
     - key (string) key to store data
     - value (any) #optional value to store
     = (object) @Element
     * or, if value is not specified:
     = (any) value
     * or, if key and value are not specified:
     = (object) Key/value pairs for all the data associated with the element.
     &gt; Usage
     | for (var i = 0, i &lt; 5, i++) {
     |     paper.circle(10 + 15 * i, 10, 10)
     |          .attr({fill: "#000"})
     |          .data("i", i)
     |          .click(function () {
     |             alert(this.data("i"));
     |          });
     | }
    \*/</span>
    elproto.data = <span class="function"><span class="keyword">function</span> <span class="params">(key, value)</span> {</span>
        <span class="keyword">var</span> data = eldata[<span class="keyword">this</span>.id] = eldata[<span class="keyword">this</span>.id] || {};
        <span class="keyword">if</span> (arguments.length == <span class="number">0</span>) {
            <span class="keyword">return</span> data;
        }
        <span class="keyword">if</span> (arguments.length == <span class="number">1</span>) {
            <span class="keyword">if</span> (R.is(key, <span class="string">"object"</span>)) {
                <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> key) <span class="keyword">if</span> (key[has](i)) {
                    <span class="keyword">this</span>.data(i, key[i]);
                }
                <span class="keyword">return</span> <span class="keyword">this</span>;
            }
            eve(<span class="string">"raphael.data.get."</span> + <span class="keyword">this</span>.id, <span class="keyword">this</span>, data[key], key);
            <span class="keyword">return</span> data[key];
        }
        data[key] = value;
        eve(<span class="string">"raphael.data.set."</span> + <span class="keyword">this</span>.id, <span class="keyword">this</span>, value, key);
        <span class="keyword">return</span> <span class="keyword">this</span>;
    };
    <span class="comment">/*\
     * Element.removeData
     [ method ]
     **
     * Removes value associated with an element by given key.
     * If key is not provided, removes all the data of the element.
     &gt; Parameters
     - key (string) #optional key
     = (object) @Element
    \*/</span>
    elproto.removeData = <span class="function"><span class="keyword">function</span> <span class="params">(key)</span> {</span>
        <span class="keyword">if</span> (key == <span class="literal">null</span>) {
            eldata[<span class="keyword">this</span>.id] = {};
        } <span class="keyword">else</span> {
            eldata[<span class="keyword">this</span>.id] &amp;&amp; <span class="keyword">delete</span> eldata[<span class="keyword">this</span>.id][key];
        }
        <span class="keyword">return</span> <span class="keyword">this</span>;
    };
     <span class="comment">/*\
     * Element.getData
     [ method ]
     **
     * Retrieves the element data
     = (object) data
    \*/</span>
    elproto.getData = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">return</span> clone(eldata[<span class="keyword">this</span>.id] || {});
    };
    <span class="comment">/*\
     * Element.hover
     [ method ]
     **
     * Adds event handlers for hover for the element.
     &gt; Parameters
     - f_in (function) handler for hover in
     - f_out (function) handler for hover out
     - icontext (object) #optional context for hover in handler
     - ocontext (object) #optional context for hover out handler
     = (object) @Element
    \*/</span>
    elproto.hover = <span class="function"><span class="keyword">function</span> <span class="params">(f_in, f_out, scope_in, scope_out)</span> {</span>
        <span class="keyword">return</span> <span class="keyword">this</span>.mouseover(f_in, scope_in).mouseout(f_out, scope_out || scope_in);
    };
    <span class="comment">/*\
     * Element.unhover
     [ method ]
     **
     * Removes event handlers for hover for the element.
     &gt; Parameters
     - f_in (function) handler for hover in
     - f_out (function) handler for hover out
     = (object) @Element
    \*/</span>
    elproto.unhover = <span class="function"><span class="keyword">function</span> <span class="params">(f_in, f_out)</span> {</span>
        <span class="keyword">return</span> <span class="keyword">this</span>.unmouseover(f_in).unmouseout(f_out);
    };
    <span class="keyword">var</span> draggable = [];
    <span class="comment">/*\
     * Element.drag
     [ method ]
     **
     * Adds event handlers for drag of the element.
     &gt; Parameters
     - onmove (function) handler for moving
     - onstart (function) handler for drag start
     - onend (function) handler for drag end
     - mcontext (object) #optional context for moving handler
     - scontext (object) #optional context for drag start handler
     - econtext (object) #optional context for drag end handler
     * Additionaly following `drag` events will be triggered: `drag.start.&lt;id&gt;` on start, 
     * `drag.end.&lt;id&gt;` on end and `drag.move.&lt;id&gt;` on every move. When element will be dragged over another element 
     * `drag.over.&lt;id&gt;` will be fired as well.
     *
     * Start event and start handler will be called in specified context or in context of the element with following parameters:
     o x (number) x position of the mouse
     o y (number) y position of the mouse
     o event (object) DOM event object
     * Move event and move handler will be called in specified context or in context of the element with following parameters:
     o dx (number) shift by x from the start point
     o dy (number) shift by y from the start point
     o x (number) x position of the mouse
     o y (number) y position of the mouse
     o event (object) DOM event object
     * End event and end handler will be called in specified context or in context of the element with following parameters:
     o event (object) DOM event object
     = (object) @Element
    \*/</span>
    elproto.drag = <span class="function"><span class="keyword">function</span> <span class="params">(onmove, onstart, onend, move_scope, start_scope, end_scope)</span> {</span>
        <span class="function"><span class="keyword">function</span> <span class="title">start</span><span class="params">(e)</span> {</span>
            (e.originalEvent || e).preventDefault();
            <span class="keyword">var</span> scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
                scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft;
            <span class="keyword">this</span>._drag.x = e.clientX + scrollX;
            <span class="keyword">this</span>._drag.y = e.clientY + scrollY;
            <span class="keyword">this</span>._drag.id = e.identifier;
            !drag.length &amp;&amp; R.mousemove(dragMove).mouseup(dragUp);
            drag.push({el: <span class="keyword">this</span>, move_scope: move_scope, start_scope: start_scope, end_scope: end_scope});
            onstart &amp;&amp; eve.on(<span class="string">"raphael.drag.start."</span> + <span class="keyword">this</span>.id, onstart);
            onmove &amp;&amp; eve.on(<span class="string">"raphael.drag.move."</span> + <span class="keyword">this</span>.id, onmove);
            onend &amp;&amp; eve.on(<span class="string">"raphael.drag.end."</span> + <span class="keyword">this</span>.id, onend);
            eve(<span class="string">"raphael.drag.start."</span> + <span class="keyword">this</span>.id, start_scope || move_scope || <span class="keyword">this</span>, e.clientX + scrollX, e.clientY + scrollY, e);
        }
        <span class="keyword">this</span>._drag = {};
        draggable.push({el: <span class="keyword">this</span>, start: start});
        <span class="keyword">this</span>.mousedown(start);
        <span class="keyword">return</span> <span class="keyword">this</span>;
    };
    <span class="comment">/*\
     * Element.onDragOver
     [ method ]
     **
     * Shortcut for assigning event handler for `drag.over.&lt;id&gt;` event, where id is id of the element (see @Element.id).
     &gt; Parameters
     - f (function) handler for event, first argument would be the element you are dragging over
    \*/</span>
    elproto.onDragOver = <span class="function"><span class="keyword">function</span> <span class="params">(f)</span> {</span>
        f ? eve.on(<span class="string">"raphael.drag.over."</span> + <span class="keyword">this</span>.id, f) : eve.unbind(<span class="string">"raphael.drag.over."</span> + <span class="keyword">this</span>.id);
    };
    <span class="comment">/*\
     * Element.undrag
     [ method ]
     **
     * Removes all drag event handlers from given element.
    \*/</span>
    elproto.undrag = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">var</span> i = draggable.length;
        <span class="keyword">while</span> (i--) <span class="keyword">if</span> (draggable[i].el == <span class="keyword">this</span>) {
            <span class="keyword">this</span>.unmousedown(draggable[i].start);
            draggable.splice(i, <span class="number">1</span>);
            eve.unbind(<span class="string">"raphael.drag.*."</span> + <span class="keyword">this</span>.id);
        }
        !draggable.length &amp;&amp; R.unmousemove(dragMove).unmouseup(dragUp);
        drag = [];
    };
    <span class="comment">/*\
     * Paper.circle
     [ method ]
     **
     * Draws a circle.
     **
     &gt; Parameters
     **
     - x (number) x coordinate of the centre
     - y (number) y coordinate of the centre
     - r (number) radius
     = (object) Raphaël element object with type “circle”
     **
     &gt; Usage
     | var c = paper.circle(50, 50, 40);
    \*/</span>
    paperproto.circle = <span class="function"><span class="keyword">function</span> <span class="params">(x, y, r)</span> {</span>
        <span class="keyword">var</span> out = R._engine.circle(<span class="keyword">this</span>, x || <span class="number">0</span>, y || <span class="number">0</span>, r || <span class="number">0</span>);
        <span class="keyword">this</span>.__set__ &amp;&amp; <span class="keyword">this</span>.__set__.push(out);
        <span class="keyword">return</span> out;
    };
    <span class="comment">/*\
     * Paper.rect
     [ method ]
     *
     * Draws a rectangle.
     **
     &gt; Parameters
     **
     - x (number) x coordinate of the top left corner
     - y (number) y coordinate of the top left corner
     - width (number) width
     - height (number) height
     - r (number) #optional radius for rounded corners, default is 0
     = (object) Raphaël element object with type “rect”
     **
     &gt; Usage
     | // regular rectangle
     | var c = paper.rect(10, 10, 50, 50);
     | // rectangle with rounded corners
     | var c = paper.rect(40, 40, 50, 50, 10);
    \*/</span>
    paperproto.rect = <span class="function"><span class="keyword">function</span> <span class="params">(x, y, w, h, r)</span> {</span>
        <span class="keyword">var</span> out = R._engine.rect(<span class="keyword">this</span>, x || <span class="number">0</span>, y || <span class="number">0</span>, w || <span class="number">0</span>, h || <span class="number">0</span>, r || <span class="number">0</span>);
        <span class="keyword">this</span>.__set__ &amp;&amp; <span class="keyword">this</span>.__set__.push(out);
        <span class="keyword">return</span> out;
    };
    <span class="comment">/*\
     * Paper.ellipse
     [ method ]
     **
     * Draws an ellipse.
     **
     &gt; Parameters
     **
     - x (number) x coordinate of the centre
     - y (number) y coordinate of the centre
     - rx (number) horizontal radius
     - ry (number) vertical radius
     = (object) Raphaël element object with type “ellipse”
     **
     &gt; Usage
     | var c = paper.ellipse(50, 50, 40, 20);
    \*/</span>
    paperproto.ellipse = <span class="function"><span class="keyword">function</span> <span class="params">(x, y, rx, ry)</span> {</span>
        <span class="keyword">var</span> out = R._engine.ellipse(<span class="keyword">this</span>, x || <span class="number">0</span>, y || <span class="number">0</span>, rx || <span class="number">0</span>, ry || <span class="number">0</span>);
        <span class="keyword">this</span>.__set__ &amp;&amp; <span class="keyword">this</span>.__set__.push(out);
        <span class="keyword">return</span> out;
    };
    <span class="comment">/*\
     * Paper.path
     [ method ]
     **
     * Creates a path element by given path data string.
     &gt; Parameters
     - pathString (string) #optional path string in SVG format.
     * Path string consists of one-letter commands, followed by comma seprarated arguments in numercal form. Example:
     | "M10,20L30,40"
     * Here we can see two commands: “M”, with arguments `(10, 20)` and “L” with arguments `(30, 40)`. Upper case letter mean command is absolute, lower case—relative.
     *
     # &lt;p&gt;Here is short list of commands available, for more details see &lt;a href="http://www.w3.org/TR/SVG/paths.html#PathData" title="Details of a path's data attribute's format are described in the SVG specification."&gt;SVG path string format&lt;/a&gt;.&lt;/p&gt;
     # &lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Command&lt;/th&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Parameters&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;
     # &lt;tr&gt;&lt;td&gt;M&lt;/td&gt;&lt;td&gt;moveto&lt;/td&gt;&lt;td&gt;(x y)+&lt;/td&gt;&lt;/tr&gt;
     # &lt;tr&gt;&lt;td&gt;Z&lt;/td&gt;&lt;td&gt;closepath&lt;/td&gt;&lt;td&gt;(none)&lt;/td&gt;&lt;/tr&gt;
     # &lt;tr&gt;&lt;td&gt;L&lt;/td&gt;&lt;td&gt;lineto&lt;/td&gt;&lt;td&gt;(x y)+&lt;/td&gt;&lt;/tr&gt;
     # &lt;tr&gt;&lt;td&gt;H&lt;/td&gt;&lt;td&gt;horizontal lineto&lt;/td&gt;&lt;td&gt;x+&lt;/td&gt;&lt;/tr&gt;
     # &lt;tr&gt;&lt;td&gt;V&lt;/td&gt;&lt;td&gt;vertical lineto&lt;/td&gt;&lt;td&gt;y+&lt;/td&gt;&lt;/tr&gt;
     # &lt;tr&gt;&lt;td&gt;C&lt;/td&gt;&lt;td&gt;curveto&lt;/td&gt;&lt;td&gt;(x1 y1 x2 y2 x y)+&lt;/td&gt;&lt;/tr&gt;
     # &lt;tr&gt;&lt;td&gt;S&lt;/td&gt;&lt;td&gt;smooth curveto&lt;/td&gt;&lt;td&gt;(x2 y2 x y)+&lt;/td&gt;&lt;/tr&gt;
     # &lt;tr&gt;&lt;td&gt;Q&lt;/td&gt;&lt;td&gt;quadratic Bézier curveto&lt;/td&gt;&lt;td&gt;(x1 y1 x y)+&lt;/td&gt;&lt;/tr&gt;
     # &lt;tr&gt;&lt;td&gt;T&lt;/td&gt;&lt;td&gt;smooth quadratic Bézier curveto&lt;/td&gt;&lt;td&gt;(x y)+&lt;/td&gt;&lt;/tr&gt;
     # &lt;tr&gt;&lt;td&gt;A&lt;/td&gt;&lt;td&gt;elliptical arc&lt;/td&gt;&lt;td&gt;(rx ry x-axis-rotation large-arc-flag sweep-flag x y)+&lt;/td&gt;&lt;/tr&gt;
     # &lt;tr&gt;&lt;td&gt;R&lt;/td&gt;&lt;td&gt;&lt;a href="http://en.wikipedia.org/wiki/Catmull–Rom_spline#Catmull.E2.80.93Rom_spline"&gt;Catmull-Rom curveto&lt;/a&gt;*&lt;/td&gt;&lt;td&gt;x1 y1 (x y)+&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
     * * “Catmull-Rom curveto” is a not standard SVG command and added in 2.0 to make life easier.
     * Note: there is a special case when path consist of just three commands: “M10,10R…z”. In this case path will smoothly connects to its beginning.
     &gt; Usage
     | var c = paper.path("M10 10L90 90");
     | // draw a diagonal line:
     | // move to 10,10, line to 90,90
     * For example of path strings, check out these icons: http://raphaeljs.com/icons/
    \*/</span>
    paperproto.path = <span class="function"><span class="keyword">function</span> <span class="params">(pathString)</span> {</span>
        pathString &amp;&amp; !R.is(pathString, string) &amp;&amp; !R.is(pathString[<span class="number">0</span>], array) &amp;&amp; (pathString += E);
        <span class="keyword">var</span> out = R._engine.path(R.format[apply](R, arguments), <span class="keyword">this</span>);
        <span class="keyword">this</span>.__set__ &amp;&amp; <span class="keyword">this</span>.__set__.push(out);
        <span class="keyword">return</span> out;
    };
    <span class="comment">/*\
     * Paper.image
     [ method ]
     **
     * Embeds an image into the surface.
     **
     &gt; Parameters
     **
     - src (string) URI of the source image
     - x (number) x coordinate position
     - y (number) y coordinate position
     - width (number) width of the image
     - height (number) height of the image
     = (object) Raphaël element object with type “image”
     **
     &gt; Usage
     | var c = paper.image("apple.png", 10, 10, 80, 80);
    \*/</span>
    paperproto.image = <span class="function"><span class="keyword">function</span> <span class="params">(src, x, y, w, h)</span> {</span>
        <span class="keyword">var</span> out = R._engine.image(<span class="keyword">this</span>, src || <span class="string">"about:blank"</span>, x || <span class="number">0</span>, y || <span class="number">0</span>, w || <span class="number">0</span>, h || <span class="number">0</span>);
        <span class="keyword">this</span>.__set__ &amp;&amp; <span class="keyword">this</span>.__set__.push(out);
        <span class="keyword">return</span> out;
    };
    <span class="comment">/*\
     * Paper.text
     [ method ]
     **
     * Draws a text string. If you need line breaks, put “\n” in the string.
     **
     &gt; Parameters
     **
     - x (number) x coordinate position
     - y (number) y coordinate position
     - text (string) The text string to draw
     = (object) Raphaël element object with type “text”
     **
     &gt; Usage
     | var t = paper.text(50, 50, "Raphaël\nkicks\nbutt!");
    \*/</span>
    paperproto.text = <span class="function"><span class="keyword">function</span> <span class="params">(x, y, text)</span> {</span>
        <span class="keyword">var</span> out = R._engine.text(<span class="keyword">this</span>, x || <span class="number">0</span>, y || <span class="number">0</span>, Str(text));
        <span class="keyword">this</span>.__set__ &amp;&amp; <span class="keyword">this</span>.__set__.push(out);
        <span class="keyword">return</span> out;
    };
    <span class="comment">/*\
     * Paper.set
     [ method ]
     **
     * Creates array-like object to keep and operate several elements at once.
     * Warning: it doesn’t create any elements for itself in the page, it just groups existing elements.
     * Sets act as pseudo elements — all methods available to an element can be used on a set.
     = (object) array-like object that represents set of elements
     **
     &gt; Usage
     | var st = paper.set();
     | st.push(
     |     paper.circle(10, 10, 5),
     |     paper.circle(30, 10, 5)
     | );
     | st.attr({fill: "red"}); // changes the fill of both circles
    \*/</span>
    paperproto.set = <span class="function"><span class="keyword">function</span> <span class="params">(itemsArray)</span> {</span>
        !R.is(itemsArray, <span class="string">"array"</span>) &amp;&amp; (itemsArray = Array.prototype.splice.call(arguments, <span class="number">0</span>, arguments.length));
        <span class="keyword">var</span> out = <span class="keyword">new</span> Set(itemsArray);
        <span class="keyword">this</span>.__set__ &amp;&amp; <span class="keyword">this</span>.__set__.push(out);
        out[<span class="string">"paper"</span>] = <span class="keyword">this</span>;
        out[<span class="string">"type"</span>] = <span class="string">"set"</span>;
        <span class="keyword">return</span> out;
    };
    <span class="comment">/*\
     * Paper.setStart
     [ method ]
     **
     * Creates @Paper.set. All elements that will be created after calling this method and before calling
     * @Paper.setFinish will be added to the set.
     **
     &gt; Usage
     | paper.setStart();
     | paper.circle(10, 10, 5),
     | paper.circle(30, 10, 5)
     | var st = paper.setFinish();
     | st.attr({fill: "red"}); // changes the fill of both circles
    \*/</span>
    paperproto.setStart = <span class="function"><span class="keyword">function</span> <span class="params">(set)</span> {</span>
        <span class="keyword">this</span>.__set__ = set || <span class="keyword">this</span>.set();
    };
    <span class="comment">/*\
     * Paper.setFinish
     [ method ]
     **
     * See @Paper.setStart. This method finishes catching and returns resulting set.
     **
     = (object) set
    \*/</span>
    paperproto.setFinish = <span class="function"><span class="keyword">function</span> <span class="params">(set)</span> {</span>
        <span class="keyword">var</span> out = <span class="keyword">this</span>.__set__;
        <span class="keyword">delete</span> <span class="keyword">this</span>.__set__;
        <span class="keyword">return</span> out;
    };
    <span class="comment">/*\
     * Paper.setSize
     [ method ]
     **
     * If you need to change dimensions of the canvas call this method
     **
     &gt; Parameters
     **
     - width (number) new width of the canvas
     - height (number) new height of the canvas
    \*/</span>
    paperproto.setSize = <span class="function"><span class="keyword">function</span> <span class="params">(width, height)</span> {</span>
        <span class="keyword">return</span> R._engine.setSize.call(<span class="keyword">this</span>, width, height);
    };
    <span class="comment">/*\
     * Paper.setViewBox
     [ method ]
     **
     * Sets the view box of the paper. Practically it gives you ability to zoom and pan whole paper surface by 
     * specifying new boundaries.
     **
     &gt; Parameters
     **
     - x (number) new x position, default is `0`
     - y (number) new y position, default is `0`
     - w (number) new width of the canvas
     - h (number) new height of the canvas
     - fit (boolean) `true` if you want graphics to fit into new boundary box
    \*/</span>
    paperproto.setViewBox = <span class="function"><span class="keyword">function</span> <span class="params">(x, y, w, h, fit)</span> {</span>
        <span class="keyword">return</span> R._engine.setViewBox.call(<span class="keyword">this</span>, x, y, w, h, fit);
    };
    <span class="comment">/*\
     * Paper.top
     [ property ]
     **
     * Points to the topmost element on the paper
    \*/</span>
    <span class="comment">/*\
     * Paper.bottom
     [ property ]
     **
     * Points to the bottom element on the paper
    \*/</span>
    paperproto.top = paperproto.bottom = <span class="literal">null</span>;
    <span class="comment">/*\
     * Paper.raphael
     [ property ]
     **
     * Points to the @Raphael object/function
    \*/</span>
    paperproto.raphael = R;
    <span class="keyword">var</span> getOffset = <span class="function"><span class="keyword">function</span> <span class="params">(elem)</span> {</span>
        <span class="keyword">var</span> box = elem.getBoundingClientRect(),
            doc = elem.ownerDocument,
            body = doc.body,
            docElem = doc.documentElement,
            clientTop = docElem.clientTop || body.clientTop || <span class="number">0</span>, clientLeft = docElem.clientLeft || body.clientLeft || <span class="number">0</span>,
            top  = box.top  + (g.win.pageYOffset || docElem.scrollTop || body.scrollTop ) - clientTop,
            left = box.left + (g.win.pageXOffset || docElem.scrollLeft || body.scrollLeft) - clientLeft;
        <span class="keyword">return</span> {
            y: top,
            x: left
        };
    };
    <span class="comment">/*\
     * Paper.getElementByPoint
     [ method ]
     **
     * Returns you topmost element under given point.
     **
     = (object) Raphaël element object
     &gt; Parameters
     **
     - x (number) x coordinate from the top left corner of the window
     - y (number) y coordinate from the top left corner of the window
     &gt; Usage
     | paper.getElementByPoint(mouseX, mouseY).attr({stroke: "#f00"});
    \*/</span>
    paperproto.getElementByPoint = <span class="function"><span class="keyword">function</span> <span class="params">(x, y)</span> {</span>
        <span class="keyword">var</span> paper = <span class="keyword">this</span>,
            svg = paper.canvas,
            target = g.doc.elementFromPoint(x, y);
        <span class="keyword">if</span> (g.win.opera &amp;&amp; target.tagName == <span class="string">"svg"</span>) {
            <span class="keyword">var</span> so = getOffset(svg),
                sr = svg.createSVGRect();
            sr.x = x - so.x;
            sr.y = y - so.y;
            sr.width = sr.height = <span class="number">1</span>;
            <span class="keyword">var</span> hits = svg.getIntersectionList(sr, <span class="literal">null</span>);
            <span class="keyword">if</span> (hits.length) {
                target = hits[hits.length - <span class="number">1</span>];
            }
        }
        <span class="keyword">if</span> (!target) {
            <span class="keyword">return</span> <span class="literal">null</span>;
        }
        <span class="keyword">while</span> (target.parentNode &amp;&amp; target != svg.parentNode &amp;&amp; !target.raphael) {
            target = target.parentNode;
        }
        target == paper.canvas.parentNode &amp;&amp; (target = svg);
        target = target &amp;&amp; target.raphael ? paper.getById(target.raphaelid) : <span class="literal">null</span>;
        <span class="keyword">return</span> target;
    };

    <span class="comment">/*\
     * Paper.getElementsByBBox
     [ method ]
     **
     * Returns set of elements that have an intersecting bounding box
     **
     &gt; Parameters
     **
     - bbox (object) bbox to check with
     = (object) @Set
     \*/</span>
    paperproto.getElementsByBBox = <span class="function"><span class="keyword">function</span> <span class="params">(bbox)</span> {</span>
        <span class="keyword">var</span> set = <span class="keyword">this</span>.set();
        <span class="keyword">this</span>.forEach(<span class="function"><span class="keyword">function</span> <span class="params">(el)</span> {</span>
            <span class="keyword">if</span> (R.isBBoxIntersect(el.getBBox(), bbox)) {
                set.push(el);
            }
        });
        <span class="keyword">return</span> set;
    };

    <span class="comment">/*\
     * Paper.getById
     [ method ]
     **
     * Returns you element by its internal ID.
     **
     &gt; Parameters
     **
     - id (number) id
     = (object) Raphaël element object
    \*/</span>
    paperproto.getById = <span class="function"><span class="keyword">function</span> <span class="params">(id)</span> {</span>
        <span class="keyword">var</span> bot = <span class="keyword">this</span>.bottom;
        <span class="keyword">while</span> (bot) {
            <span class="keyword">if</span> (bot.id == id) {
                <span class="keyword">return</span> bot;
            }
            bot = bot.next;
        }
        <span class="keyword">return</span> <span class="literal">null</span>;
    };
    <span class="comment">/*\
     * Paper.forEach
     [ method ]
     **
     * Executes given function for each element on the paper
     *
     * If callback function returns `false` it will stop loop running.
     **
     &gt; Parameters
     **
     - callback (function) function to run
     - thisArg (object) context object for the callback
     = (object) Paper object
     &gt; Usage
     | paper.forEach(function (el) {
     |     el.attr({ stroke: "blue" });
     | });
    \*/</span>
    paperproto.forEach = <span class="function"><span class="keyword">function</span> <span class="params">(callback, thisArg)</span> {</span>
        <span class="keyword">var</span> bot = <span class="keyword">this</span>.bottom;
        <span class="keyword">while</span> (bot) {
            <span class="keyword">if</span> (callback.call(thisArg, bot) === <span class="literal">false</span>) {
                <span class="keyword">return</span> <span class="keyword">this</span>;
            }
            bot = bot.next;
        }
        <span class="keyword">return</span> <span class="keyword">this</span>;
    };
    <span class="comment">/*\
     * Paper.getElementsByPoint
     [ method ]
     **
     * Returns set of elements that have common point inside
     **
     &gt; Parameters
     **
     - x (number) x coordinate of the point
     - y (number) y coordinate of the point
     = (object) @Set
    \*/</span>
    paperproto.getElementsByPoint = <span class="function"><span class="keyword">function</span> <span class="params">(x, y)</span> {</span>
        <span class="keyword">var</span> set = <span class="keyword">this</span>.set();
        <span class="keyword">this</span>.forEach(<span class="function"><span class="keyword">function</span> <span class="params">(el)</span> {</span>
            <span class="keyword">if</span> (el.isPointInside(x, y)) {
                set.push(el);
            }
        });
        <span class="keyword">return</span> set;
    };
    <span class="function"><span class="keyword">function</span> <span class="title">x_y</span><span class="params">()</span> {</span>
        <span class="keyword">return</span> <span class="keyword">this</span>.x + S + <span class="keyword">this</span>.y;
    }
    <span class="function"><span class="keyword">function</span> <span class="title">x_y_w_h</span><span class="params">()</span> {</span>
        <span class="keyword">return</span> <span class="keyword">this</span>.x + S + <span class="keyword">this</span>.y + S + <span class="keyword">this</span>.width + <span class="string">" \xd7 "</span> + <span class="keyword">this</span>.height;
    }
    <span class="comment">/*\
     * Element.isPointInside
     [ method ]
     **
     * Determine if given point is inside this element’s shape
     **
     &gt; Parameters
     **
     - x (number) x coordinate of the point
     - y (number) y coordinate of the point
     = (boolean) `true` if point inside the shape
    \*/</span>
    elproto.isPointInside = <span class="function"><span class="keyword">function</span> <span class="params">(x, y)</span> {</span>
        <span class="keyword">var</span> rp = <span class="keyword">this</span>.realPath = <span class="keyword">this</span>.realPath || getPath[<span class="keyword">this</span>.type](<span class="keyword">this</span>);
        <span class="keyword">return</span> R.isPointInsidePath(rp, x, y);
    };
    <span class="comment">/*\
     * Element.getBBox
     [ method ]
     **
     * Return bounding box for a given element
     **
     &gt; Parameters
     **
     - isWithoutTransform (boolean) flag, `true` if you want to have bounding box before transformations. Default is `false`.
     = (object) Bounding box object:
     o {
     o     x: (number) top left corner x
     o     y: (number) top left corner y
     o     x2: (number) bottom right corner x
     o     y2: (number) bottom right corner y
     o     width: (number) width
     o     height: (number) height
     o }
    \*/</span>
    elproto.getBBox = <span class="function"><span class="keyword">function</span> <span class="params">(isWithoutTransform)</span> {</span>
        <span class="keyword">if</span> (<span class="keyword">this</span>.removed) {
            <span class="keyword">return</span> {};
        }
        <span class="keyword">var</span> _ = <span class="keyword">this</span>._;
        <span class="keyword">if</span> (isWithoutTransform) {
            <span class="keyword">if</span> (_.dirty || !_.bboxwt) {
                <span class="keyword">this</span>.realPath = getPath[<span class="keyword">this</span>.type](<span class="keyword">this</span>);
                _.bboxwt = pathDimensions(<span class="keyword">this</span>.realPath);
                _.bboxwt.toString = x_y_w_h;
                _.dirty = <span class="number">0</span>;
            }
            <span class="keyword">return</span> _.bboxwt;
        }
        <span class="keyword">if</span> (_.dirty || _.dirtyT || !_.bbox) {
            <span class="keyword">if</span> (_.dirty || !<span class="keyword">this</span>.realPath) {
                _.bboxwt = <span class="number">0</span>;
                <span class="keyword">this</span>.realPath = getPath[<span class="keyword">this</span>.type](<span class="keyword">this</span>);
            }
            _.bbox = pathDimensions(mapPath(<span class="keyword">this</span>.realPath, <span class="keyword">this</span>.matrix));
            _.bbox.toString = x_y_w_h;
            _.dirty = _.dirtyT = <span class="number">0</span>;
        }
        <span class="keyword">return</span> _.bbox;
    };
    <span class="comment">/*\
     * Element.clone
     [ method ]
     **
     = (object) clone of a given element
     **
    \*/</span>
    elproto.clone = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">if</span> (<span class="keyword">this</span>.removed) {
            <span class="keyword">return</span> <span class="literal">null</span>;
        }
        <span class="keyword">var</span> out = <span class="keyword">this</span>.paper[<span class="keyword">this</span>.type]().attr(<span class="keyword">this</span>.attr());
        <span class="keyword">this</span>.__set__ &amp;&amp; <span class="keyword">this</span>.__set__.push(out);
        <span class="keyword">return</span> out;
    };
    <span class="comment">/*\
     * Element.glow
     [ method ]
     **
     * Return set of elements that create glow-like effect around given element. See @Paper.set.
     *
     * Note: Glow is not connected to the element. If you change element attributes it won’t adjust itself.
     **
     &gt; Parameters
     **
     - glow (object) #optional parameters object with all properties optional:
     o {
     o     width (number) size of the glow, default is `10`
     o     fill (boolean) will it be filled, default is `false`
     o     opacity (number) opacity, default is `0.5`
     o     offsetx (number) horizontal offset, default is `0`
     o     offsety (number) vertical offset, default is `0`
     o     color (string) glow colour, default is `black`
     o }
     = (object) @Paper.set of elements that represents glow
    \*/</span>
    elproto.glow = <span class="function"><span class="keyword">function</span> <span class="params">(glow)</span> {</span>
        <span class="keyword">if</span> (<span class="keyword">this</span>.type == <span class="string">"text"</span>) {
            <span class="keyword">return</span> <span class="literal">null</span>;
        }
        glow = glow || {};
        <span class="keyword">var</span> s = {
            width: (glow.width || <span class="number">10</span>) + (+<span class="keyword">this</span>.attr(<span class="string">"stroke-width"</span>) || <span class="number">1</span>),
            fill: glow.fill || <span class="literal">false</span>,
            opacity: glow.opacity || <span class="number">.5</span>,
            offsetx: glow.offsetx || <span class="number">0</span>,
            offsety: glow.offsety || <span class="number">0</span>,
            color: glow.color || <span class="string">"#000"</span>
        },
            c = s.width / <span class="number">2</span>,
            r = <span class="keyword">this</span>.paper,
            out = r.set(),
            path = <span class="keyword">this</span>.realPath || getPath[<span class="keyword">this</span>.type](<span class="keyword">this</span>);
        path = <span class="keyword">this</span>.matrix ? mapPath(path, <span class="keyword">this</span>.matrix) : path;
        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; c + <span class="number">1</span>; i++) {
            out.push(r.path(path).attr({
                stroke: s.color,
                fill: s.fill ? s.color : <span class="string">"none"</span>,
                <span class="string">"stroke-linejoin"</span>: <span class="string">"round"</span>,
                <span class="string">"stroke-linecap"</span>: <span class="string">"round"</span>,
                <span class="string">"stroke-width"</span>: +(s.width / c * i).toFixed(<span class="number">3</span>),
                opacity: +(s.opacity / c).toFixed(<span class="number">3</span>)
            }));
        }
        <span class="keyword">return</span> out.insertBefore(<span class="keyword">this</span>).translate(s.offsetx, s.offsety);
    };
    <span class="keyword">var</span> curveslengths = {},
    getPointAtSegmentLength = <span class="function"><span class="keyword">function</span> <span class="params">(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length)</span> {</span>
        <span class="keyword">if</span> (length == <span class="literal">null</span>) {
            <span class="keyword">return</span> bezlen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y);
        } <span class="keyword">else</span> {
            <span class="keyword">return</span> R.findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, getTatLen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length));
        }
    },
    getLengthFactory = <span class="function"><span class="keyword">function</span> <span class="params">(istotal, subpath)</span> {</span>
        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(path, length, onlystart)</span> {</span>
            path = path2curve(path);
            <span class="keyword">var</span> x, y, p, l, sp = <span class="string">""</span>, subpaths = {}, point,
                len = <span class="number">0</span>;
            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, ii = path.length; i &lt; ii; i++) {
                p = path[i];
                <span class="keyword">if</span> (p[<span class="number">0</span>] == <span class="string">"M"</span>) {
                    x = +p[<span class="number">1</span>];
                    y = +p[<span class="number">2</span>];
                } <span class="keyword">else</span> {
                    l = getPointAtSegmentLength(x, y, p[<span class="number">1</span>], p[<span class="number">2</span>], p[<span class="number">3</span>], p[<span class="number">4</span>], p[<span class="number">5</span>], p[<span class="number">6</span>]);
                    <span class="keyword">if</span> (len + l &gt; length) {
                        <span class="keyword">if</span> (subpath &amp;&amp; !subpaths.start) {
                            point = getPointAtSegmentLength(x, y, p[<span class="number">1</span>], p[<span class="number">2</span>], p[<span class="number">3</span>], p[<span class="number">4</span>], p[<span class="number">5</span>], p[<span class="number">6</span>], length - len);
                            sp += [<span class="string">"C"</span> + point.start.x, point.start.y, point.m.x, point.m.y, point.x, point.y];
                            <span class="keyword">if</span> (onlystart) {<span class="keyword">return</span> sp;}
                            subpaths.start = sp;
                            sp = [<span class="string">"M"</span> + point.x, point.y + <span class="string">"C"</span> + point.n.x, point.n.y, point.end.x, point.end.y, p[<span class="number">5</span>], p[<span class="number">6</span>]].join();
                            len += l;
                            x = +p[<span class="number">5</span>];
                            y = +p[<span class="number">6</span>];
                            <span class="keyword">continue</span>;
                        }
                        <span class="keyword">if</span> (!istotal &amp;&amp; !subpath) {
                            point = getPointAtSegmentLength(x, y, p[<span class="number">1</span>], p[<span class="number">2</span>], p[<span class="number">3</span>], p[<span class="number">4</span>], p[<span class="number">5</span>], p[<span class="number">6</span>], length - len);
                            <span class="keyword">return</span> {x: point.x, y: point.y, alpha: point.alpha};
                        }
                    }
                    len += l;
                    x = +p[<span class="number">5</span>];
                    y = +p[<span class="number">6</span>];
                }
                sp += p.shift() + p;
            }
            subpaths.end = sp;
            point = istotal ? len : subpath ? subpaths : R.findDotsAtSegment(x, y, p[<span class="number">0</span>], p[<span class="number">1</span>], p[<span class="number">2</span>], p[<span class="number">3</span>], p[<span class="number">4</span>], p[<span class="number">5</span>], <span class="number">1</span>);
            point.alpha &amp;&amp; (point = {x: point.x, y: point.y, alpha: point.alpha});
            <span class="keyword">return</span> point;
        };
    };
    <span class="keyword">var</span> getTotalLength = getLengthFactory(<span class="number">1</span>),
        getPointAtLength = getLengthFactory(),
        getSubpathsAtLength = getLengthFactory(<span class="number">0</span>, <span class="number">1</span>);
    <span class="comment">/*\
     * Raphael.getTotalLength
     [ method ]
     **
     * Returns length of the given path in pixels.
     **
     &gt; Parameters
     **
     - path (string) SVG path string.
     **
     = (number) length.
    \*/</span>
    R.getTotalLength = getTotalLength;
    <span class="comment">/*\
     * Raphael.getPointAtLength
     [ method ]
     **
     * Return coordinates of the point located at the given length on the given path.
     **
     &gt; Parameters
     **
     - path (string) SVG path string
     - length (number)
     **
     = (object) representation of the point:
     o {
     o     x: (number) x coordinate
     o     y: (number) y coordinate
     o     alpha: (number) angle of derivative
     o }
    \*/</span>
    R.getPointAtLength = getPointAtLength;
    <span class="comment">/*\
     * Raphael.getSubpath
     [ method ]
     **
     * Return subpath of a given path from given length to given length.
     **
     &gt; Parameters
     **
     - path (string) SVG path string
     - from (number) position of the start of the segment
     - to (number) position of the end of the segment
     **
     = (string) pathstring for the segment
    \*/</span>
    R.getSubpath = <span class="function"><span class="keyword">function</span> <span class="params">(path, from, to)</span> {</span>
        <span class="keyword">if</span> (<span class="keyword">this</span>.getTotalLength(path) - to &lt; <span class="number">1e-6</span>) {
            <span class="keyword">return</span> getSubpathsAtLength(path, from).end;
        }
        <span class="keyword">var</span> a = getSubpathsAtLength(path, to, <span class="number">1</span>);
        <span class="keyword">return</span> from ? getSubpathsAtLength(a, from).end : a;
    };
    <span class="comment">/*\
     * Element.getTotalLength
     [ method ]
     **
     * Returns length of the path in pixels. Only works for element of “path” type.
     = (number) length.
    \*/</span>
    elproto.getTotalLength = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">var</span> path = <span class="keyword">this</span>.getPath();
        <span class="keyword">if</span> (!path) {
            <span class="keyword">return</span>;
        }

        <span class="keyword">if</span> (<span class="keyword">this</span>.node.getTotalLength) {
            <span class="keyword">return</span> <span class="keyword">this</span>.node.getTotalLength();
        }

        <span class="keyword">return</span> getTotalLength(path);
    };
    <span class="comment">/*\
     * Element.getPointAtLength
     [ method ]
     **
     * Return coordinates of the point located at the given length on the given path. Only works for element of “path” type.
     **
     &gt; Parameters
     **
     - length (number)
     **
     = (object) representation of the point:
     o {
     o     x: (number) x coordinate
     o     y: (number) y coordinate
     o     alpha: (number) angle of derivative
     o }
    \*/</span>
    elproto.getPointAtLength = <span class="function"><span class="keyword">function</span> <span class="params">(length)</span> {</span>
        <span class="keyword">var</span> path = <span class="keyword">this</span>.getPath();
        <span class="keyword">if</span> (!path) {
            <span class="keyword">return</span>;
        }

        <span class="keyword">return</span> getPointAtLength(path, length);
    };
    <span class="comment">/*\
     * Element.getPath
     [ method ]
     **
     * Returns path of the element. Only works for elements of “path” type and simple elements like circle.
     = (object) path
     **
    \*/</span>
    elproto.getPath = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">var</span> path,
            getPath = R._getPath[<span class="keyword">this</span>.type];
        
        <span class="keyword">if</span> (<span class="keyword">this</span>.type == <span class="string">"text"</span> || <span class="keyword">this</span>.type == <span class="string">"set"</span>) {
            <span class="keyword">return</span>;
        }

        <span class="keyword">if</span> (getPath) {
            path = getPath(<span class="keyword">this</span>);
        }

        <span class="keyword">return</span> path;
    };
    <span class="comment">/*\
     * Element.getSubpath
     [ method ]
     **
     * Return subpath of a given element from given length to given length. Only works for element of “path” type.
     **
     &gt; Parameters
     **
     - from (number) position of the start of the segment
     - to (number) position of the end of the segment
     **
     = (string) pathstring for the segment
    \*/</span>
    elproto.getSubpath = <span class="function"><span class="keyword">function</span> <span class="params">(from, to)</span> {</span>
        <span class="keyword">var</span> path = <span class="keyword">this</span>.getPath();
        <span class="keyword">if</span> (!path) {
            <span class="keyword">return</span>;
        }

        <span class="keyword">return</span> R.getSubpath(path, from, to);
    };
    <span class="comment">/*\
     * Raphael.easing_formulas
     [ property ]
     **
     * Object that contains easing formulas for animation. You could extend it with your own. By default it has following list of easing:
     # &lt;ul&gt;
     #     &lt;li&gt;“linear”&lt;/li&gt;
     #     &lt;li&gt;“&amp;lt;” or “easeIn” or “ease-in”&lt;/li&gt;
     #     &lt;li&gt;“&gt;” or “easeOut” or “ease-out”&lt;/li&gt;
     #     &lt;li&gt;“&amp;lt;&gt;” or “easeInOut” or “ease-in-out”&lt;/li&gt;
     #     &lt;li&gt;“backIn” or “back-in”&lt;/li&gt;
     #     &lt;li&gt;“backOut” or “back-out”&lt;/li&gt;
     #     &lt;li&gt;“elastic”&lt;/li&gt;
     #     &lt;li&gt;“bounce”&lt;/li&gt;
     # &lt;/ul&gt;
     # &lt;p&gt;See also &lt;a href="http://raphaeljs.com/easing.html"&gt;Easing demo&lt;/a&gt;.&lt;/p&gt;
    \*/</span>
    <span class="keyword">var</span> ef = R.easing_formulas = {
        linear: <span class="function"><span class="keyword">function</span> <span class="params">(n)</span> {</span>
            <span class="keyword">return</span> n;
        },
        <span class="string">"&lt;"</span>: <span class="function"><span class="keyword">function</span> <span class="params">(n)</span> {</span>
            <span class="keyword">return</span> pow(n, <span class="number">1.7</span>);
        },
        <span class="string">"&gt;"</span>: <span class="function"><span class="keyword">function</span> <span class="params">(n)</span> {</span>
            <span class="keyword">return</span> pow(n, <span class="number">.48</span>);
        },
        <span class="string">"&lt;&gt;"</span>: <span class="function"><span class="keyword">function</span> <span class="params">(n)</span> {</span>
            <span class="keyword">var</span> q = <span class="number">.48</span> - n / <span class="number">1.04</span>,
                Q = math.sqrt(<span class="number">.1734</span> + q * q),
                x = Q - q,
                X = pow(abs(x), <span class="number">1</span> / <span class="number">3</span>) * (x &lt; <span class="number">0</span> ? -<span class="number">1</span> : <span class="number">1</span>),
                y = -Q - q,
                Y = pow(abs(y), <span class="number">1</span> / <span class="number">3</span>) * (y &lt; <span class="number">0</span> ? -<span class="number">1</span> : <span class="number">1</span>),
                t = X + Y + <span class="number">.5</span>;
            <span class="keyword">return</span> (<span class="number">1</span> - t) * <span class="number">3</span> * t * t + t * t * t;
        },
        backIn: <span class="function"><span class="keyword">function</span> <span class="params">(n)</span> {</span>
            <span class="keyword">var</span> s = <span class="number">1.70158</span>;
            <span class="keyword">return</span> n * n * ((s + <span class="number">1</span>) * n - s);
        },
        backOut: <span class="function"><span class="keyword">function</span> <span class="params">(n)</span> {</span>
            n = n - <span class="number">1</span>;
            <span class="keyword">var</span> s = <span class="number">1.70158</span>;
            <span class="keyword">return</span> n * n * ((s + <span class="number">1</span>) * n + s) + <span class="number">1</span>;
        },
        elastic: <span class="function"><span class="keyword">function</span> <span class="params">(n)</span> {</span>
            <span class="keyword">if</span> (n == !!n) {
                <span class="keyword">return</span> n;
            }
            <span class="keyword">return</span> pow(<span class="number">2</span>, -<span class="number">10</span> * n) * math.sin((n - <span class="number">.075</span>) * (<span class="number">2</span> * PI) / <span class="number">.3</span>) + <span class="number">1</span>;
        },
        bounce: <span class="function"><span class="keyword">function</span> <span class="params">(n)</span> {</span>
            <span class="keyword">var</span> s = <span class="number">7.5625</span>,
                p = <span class="number">2.75</span>,
                l;
            <span class="keyword">if</span> (n &lt; (<span class="number">1</span> / p)) {
                l = s * n * n;
            } <span class="keyword">else</span> {
                <span class="keyword">if</span> (n &lt; (<span class="number">2</span> / p)) {
                    n -= (<span class="number">1.5</span> / p);
                    l = s * n * n + <span class="number">.75</span>;
                } <span class="keyword">else</span> {
                    <span class="keyword">if</span> (n &lt; (<span class="number">2.5</span> / p)) {
                        n -= (<span class="number">2.25</span> / p);
                        l = s * n * n + <span class="number">.9375</span>;
                    } <span class="keyword">else</span> {
                        n -= (<span class="number">2.625</span> / p);
                        l = s * n * n + <span class="number">.984375</span>;
                    }
                }
            }
            <span class="keyword">return</span> l;
        }
    };
    ef.easeIn = ef[<span class="string">"ease-in"</span>] = ef[<span class="string">"&lt;"</span>];
    ef.easeOut = ef[<span class="string">"ease-out"</span>] = ef[<span class="string">"&gt;"</span>];
    ef.easeInOut = ef[<span class="string">"ease-in-out"</span>] = ef[<span class="string">"&lt;&gt;"</span>];
    ef[<span class="string">"back-in"</span>] = ef.backIn;
    ef[<span class="string">"back-out"</span>] = ef.backOut;

    <span class="keyword">var</span> animationElements = [],
        requestAnimFrame = window.requestAnimationFrame       ||
                           window.webkitRequestAnimationFrame ||
                           window.mozRequestAnimationFrame    ||
                           window.oRequestAnimationFrame      ||
                           window.msRequestAnimationFrame     ||
                           <span class="function"><span class="keyword">function</span> <span class="params">(callback)</span> {</span>
                               setTimeout(callback, <span class="number">16</span>);
                           },
        animation = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
            <span class="keyword">var</span> Now = +<span class="keyword">new</span> Date,
                l = <span class="number">0</span>;
            <span class="keyword">for</span> (; l &lt; animationElements.length; l++) {
                <span class="keyword">var</span> e = animationElements[l];
                <span class="keyword">if</span> (e.el.removed || e.paused) {
                    <span class="keyword">continue</span>;
                }
                <span class="keyword">var</span> time = Now - e.start,
                    ms = e.ms,
                    easing = e.easing,
                    from = e.from,
                    diff = e.diff,
                    to = e.to,
                    t = e.t,
                    that = e.el,
                    set = {},
                    now,
                    init = {},
                    key;
                <span class="keyword">if</span> (e.initstatus) {
                    time = (e.initstatus * e.anim.top - e.prev) / (e.percent - e.prev) * ms;
                    e.status = e.initstatus;
                    <span class="keyword">delete</span> e.initstatus;
                    e.stop &amp;&amp; animationElements.splice(l--, <span class="number">1</span>);
                } <span class="keyword">else</span> {
                    e.status = (e.prev + (e.percent - e.prev) * (time / ms)) / e.anim.top;
                }
                <span class="keyword">if</span> (time &lt; <span class="number">0</span>) {
                    <span class="keyword">continue</span>;
                }
                <span class="keyword">if</span> (time &lt; ms) {
                    <span class="keyword">var</span> pos = easing(time / ms);
                    <span class="keyword">for</span> (<span class="keyword">var</span> attr <span class="keyword">in</span> from) <span class="keyword">if</span> (from[has](attr)) {
                        <span class="keyword">switch</span> (availableAnimAttrs[attr]) {
                            <span class="keyword">case</span> nu:
                                now = +from[attr] + pos * ms * diff[attr];
                                <span class="keyword">break</span>;
                            <span class="keyword">case</span> <span class="string">"colour"</span>:
                                now = <span class="string">"rgb("</span> + [
                                    upto255(round(from[attr].r + pos * ms * diff[attr].r)),
                                    upto255(round(from[attr].g + pos * ms * diff[attr].g)),
                                    upto255(round(from[attr].b + pos * ms * diff[attr].b))
                                ].join(<span class="string">","</span>) + <span class="string">")"</span>;
                                <span class="keyword">break</span>;
                            <span class="keyword">case</span> <span class="string">"path"</span>:
                                now = [];
                                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, ii = from[attr].length; i &lt; ii; i++) {
                                    now[i] = [from[attr][i][<span class="number">0</span>]];
                                    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">1</span>, jj = from[attr][i].length; j &lt; jj; j++) {
                                        now[i][j] = +from[attr][i][j] + pos * ms * diff[attr][i][j];
                                    }
                                    now[i] = now[i].join(S);
                                }
                                now = now.join(S);
                                <span class="keyword">break</span>;
                            <span class="keyword">case</span> <span class="string">"transform"</span>:
                                <span class="keyword">if</span> (diff[attr].real) {
                                    now = [];
                                    <span class="keyword">for</span> (i = <span class="number">0</span>, ii = from[attr].length; i &lt; ii; i++) {
                                        now[i] = [from[attr][i][<span class="number">0</span>]];
                                        <span class="keyword">for</span> (j = <span class="number">1</span>, jj = from[attr][i].length; j &lt; jj; j++) {
                                            now[i][j] = from[attr][i][j] + pos * ms * diff[attr][i][j];
                                        }
                                    }
                                } <span class="keyword">else</span> {
                                    <span class="keyword">var</span> get = <span class="function"><span class="keyword">function</span> <span class="params">(i)</span> {</span>
                                        <span class="keyword">return</span> +from[attr][i] + pos * ms * diff[attr][i];
                                    };</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>now = [[&quot;r&quot;, get(2), 0, 0], [&quot;t&quot;, get(3), get(4)], [&quot;s&quot;, get(0), get(1), 0, 0]];</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                                    now = [[<span class="string">"m"</span>, get(<span class="number">0</span>), get(<span class="number">1</span>), get(<span class="number">2</span>), get(<span class="number">3</span>), get(<span class="number">4</span>), get(<span class="number">5</span>)]];
                                }
                                <span class="keyword">break</span>;
                            <span class="keyword">case</span> <span class="string">"csv"</span>:
                                <span class="keyword">if</span> (attr == <span class="string">"clip-rect"</span>) {
                                    now = [];
                                    i = <span class="number">4</span>;
                                    <span class="keyword">while</span> (i--) {
                                        now[i] = +from[attr][i] + pos * ms * diff[attr][i];
                                    }
                                }
                                <span class="keyword">break</span>;
                            <span class="keyword">default</span>:
                                <span class="keyword">var</span> from2 = [][concat](from[attr]);
                                now = [];
                                i = that.paper.customAttributes[attr].length;
                                <span class="keyword">while</span> (i--) {
                                    now[i] = +from2[i] + pos * ms * diff[attr][i];
                                }
                                <span class="keyword">break</span>;
                        }
                        set[attr] = now;
                    }
                    that.attr(set);
                    (<span class="function"><span class="keyword">function</span> <span class="params">(id, that, anim)</span> {</span>
                        setTimeout(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
                            eve(<span class="string">"raphael.anim.frame."</span> + id, that, anim);
                        });
                    })(that.id, that, e.anim);
                } <span class="keyword">else</span> {
                    (<span class="keyword">function</span>(f, el, a) {
                        setTimeout(<span class="keyword">function</span>() {
                            eve(<span class="string">"raphael.anim.frame."</span> + el.id, el, a);
                            eve(<span class="string">"raphael.anim.finish."</span> + el.id, el, a);
                            R.is(f, <span class="string">"function"</span>) &amp;&amp; f.call(el);
                        });
                    })(e.callback, that, e.anim);
                    that.attr(to);
                    animationElements.splice(l--, <span class="number">1</span>);
                    <span class="keyword">if</span> (e.repeat &gt; <span class="number">1</span> &amp;&amp; !e.next) {
                        <span class="keyword">for</span> (key <span class="keyword">in</span> to) <span class="keyword">if</span> (to[has](key)) {
                            init[key] = e.totalOrigin[key];
                        }
                        e.el.attr(init);
                        runAnimation(e.anim, e.el, e.anim.percents[<span class="number">0</span>], <span class="literal">null</span>, e.totalOrigin, e.repeat - <span class="number">1</span>);
                    }
                    <span class="keyword">if</span> (e.next &amp;&amp; !e.stop) {
                        runAnimation(e.anim, e.el, e.next, <span class="literal">null</span>, e.totalOrigin, e.repeat);
                    }
                }
            }
            R.svg &amp;&amp; that &amp;&amp; that.paper &amp;&amp; that.paper.safari();
            animationElements.length &amp;&amp; requestAnimFrame(animation);
        },
        upto255 = <span class="function"><span class="keyword">function</span> <span class="params">(color)</span> {</span>
            <span class="keyword">return</span> color &gt; <span class="number">255</span> ? <span class="number">255</span> : color &lt; <span class="number">0</span> ? <span class="number">0</span> : color;
        };
    <span class="comment">/*\
     * Element.animateWith
     [ method ]
     **
     * Acts similar to @Element.animate, but ensure that given animation runs in sync with another given element.
     **
     &gt; Parameters
     **
     - el (object) element to sync with
     - anim (object) animation to sync with
     - params (object) #optional final attributes for the element, see also @Element.attr
     - ms (number) #optional number of milliseconds for animation to run
     - easing (string) #optional easing type. Accept on of @Raphael.easing_formulas or CSS format: `cubic&amp;#x2010;bezier(XX,&amp;#160;XX,&amp;#160;XX,&amp;#160;XX)`
     - callback (function) #optional callback function. Will be called at the end of animation.
     * or
     - element (object) element to sync with
     - anim (object) animation to sync with
     - animation (object) #optional animation object, see @Raphael.animation
     **
     = (object) original element
    \*/</span>
    elproto.animateWith = <span class="function"><span class="keyword">function</span> <span class="params">(el, anim, params, ms, easing, callback)</span> {</span>
        <span class="keyword">var</span> element = <span class="keyword">this</span>;
        <span class="keyword">if</span> (element.removed) {
            callback &amp;&amp; callback.call(element);
            <span class="keyword">return</span> element;
        }
        <span class="keyword">var</span> a = params <span class="keyword">instanceof</span> Animation ? params : R.animation(params, ms, easing, callback),
            x, y;
        runAnimation(a, element, a.percents[<span class="number">0</span>], <span class="literal">null</span>, element.attr());
        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, ii = animationElements.length; i &lt; ii; i++) {
            <span class="keyword">if</span> (animationElements[i].anim == anim &amp;&amp; animationElements[i].el == el) {
                animationElements[ii - <span class="number">1</span>].start = animationElements[i].start;
                <span class="keyword">break</span>;
            }
        }
        <span class="keyword">return</span> element;</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>var a = params ? R.animation(params, ms, easing, callback) : anim,
    status = element.status(anim);
return this.animate(a).status(a, status * anim.ms / a.ms);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    };
    <span class="function"><span class="keyword">function</span> <span class="title">CubicBezierAtTime</span><span class="params">(t, p1x, p1y, p2x, p2y, duration)</span> {</span>
        <span class="keyword">var</span> cx = <span class="number">3</span> * p1x,
            bx = <span class="number">3</span> * (p2x - p1x) - cx,
            ax = <span class="number">1</span> - cx - bx,
            cy = <span class="number">3</span> * p1y,
            by = <span class="number">3</span> * (p2y - p1y) - cy,
            ay = <span class="number">1</span> - cy - by;
        <span class="function"><span class="keyword">function</span> <span class="title">sampleCurveX</span><span class="params">(t)</span> {</span>
            <span class="keyword">return</span> ((ax * t + bx) * t + cx) * t;
        }
        <span class="function"><span class="keyword">function</span> <span class="title">solve</span><span class="params">(x, epsilon)</span> {</span>
            <span class="keyword">var</span> t = solveCurveX(x, epsilon);
            <span class="keyword">return</span> ((ay * t + by) * t + cy) * t;
        }
        <span class="function"><span class="keyword">function</span> <span class="title">solveCurveX</span><span class="params">(x, epsilon)</span> {</span>
            <span class="keyword">var</span> t0, t1, t2, x2, d2, i;
            <span class="keyword">for</span>(t2 = x, i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) {
                x2 = sampleCurveX(t2) - x;
                <span class="keyword">if</span> (abs(x2) &lt; epsilon) {
                    <span class="keyword">return</span> t2;
                }
                d2 = (<span class="number">3</span> * ax * t2 + <span class="number">2</span> * bx) * t2 + cx;
                <span class="keyword">if</span> (abs(d2) &lt; <span class="number">1e-6</span>) {
                    <span class="keyword">break</span>;
                }
                t2 = t2 - x2 / d2;
            }
            t0 = <span class="number">0</span>;
            t1 = <span class="number">1</span>;
            t2 = x;
            <span class="keyword">if</span> (t2 &lt; t0) {
                <span class="keyword">return</span> t0;
            }
            <span class="keyword">if</span> (t2 &gt; t1) {
                <span class="keyword">return</span> t1;
            }
            <span class="keyword">while</span> (t0 &lt; t1) {
                x2 = sampleCurveX(t2);
                <span class="keyword">if</span> (abs(x2 - x) &lt; epsilon) {
                    <span class="keyword">return</span> t2;
                }
                <span class="keyword">if</span> (x &gt; x2) {
                    t0 = t2;
                } <span class="keyword">else</span> {
                    t1 = t2;
                }
                t2 = (t1 - t0) / <span class="number">2</span> + t0;
            }
            <span class="keyword">return</span> t2;
        }
        <span class="keyword">return</span> solve(t, <span class="number">1</span> / (<span class="number">200</span> * duration));
    }
    elproto.onAnimation = <span class="function"><span class="keyword">function</span> <span class="params">(f)</span> {</span>
        f ? eve.on(<span class="string">"raphael.anim.frame."</span> + <span class="keyword">this</span>.id, f) : eve.unbind(<span class="string">"raphael.anim.frame."</span> + <span class="keyword">this</span>.id);
        <span class="keyword">return</span> <span class="keyword">this</span>;
    };
    <span class="function"><span class="keyword">function</span> <span class="title">Animation</span><span class="params">(anim, ms)</span> {</span>
        <span class="keyword">var</span> percents = [],
            newAnim = {};
        <span class="keyword">this</span>.ms = ms;
        <span class="keyword">this</span>.times = <span class="number">1</span>;
        <span class="keyword">if</span> (anim) {
            <span class="keyword">for</span> (<span class="keyword">var</span> attr <span class="keyword">in</span> anim) <span class="keyword">if</span> (anim[has](attr)) {
                newAnim[toFloat(attr)] = anim[attr];
                percents.push(toFloat(attr));
            }
            percents.sort(sortByNumber);
        }
        <span class="keyword">this</span>.anim = newAnim;
        <span class="keyword">this</span>.top = percents[percents.length - <span class="number">1</span>];
        <span class="keyword">this</span>.percents = percents;
    }
    <span class="comment">/*\
     * Animation.delay
     [ method ]
     **
     * Creates a copy of existing animation object with given delay.
     **
     &gt; Parameters
     **
     - delay (number) number of ms to pass between animation start and actual animation
     **
     = (object) new altered Animation object
     | var anim = Raphael.animation({cx: 10, cy: 20}, 2e3);
     | circle1.animate(anim); // run the given animation immediately
     | circle2.animate(anim.delay(500)); // run the given animation after 500 ms
    \*/</span>
    Animation.prototype.delay = <span class="function"><span class="keyword">function</span> <span class="params">(delay)</span> {</span>
        <span class="keyword">var</span> a = <span class="keyword">new</span> Animation(<span class="keyword">this</span>.anim, <span class="keyword">this</span>.ms);
        a.times = <span class="keyword">this</span>.times;
        a.del = +delay || <span class="number">0</span>;
        <span class="keyword">return</span> a;
    };
    <span class="comment">/*\
     * Animation.repeat
     [ method ]
     **
     * Creates a copy of existing animation object with given repetition.
     **
     &gt; Parameters
     **
     - repeat (number) number iterations of animation. For infinite animation pass `Infinity`
     **
     = (object) new altered Animation object
    \*/</span>
    Animation.prototype.repeat = <span class="function"><span class="keyword">function</span> <span class="params">(times)</span> {</span>
        <span class="keyword">var</span> a = <span class="keyword">new</span> Animation(<span class="keyword">this</span>.anim, <span class="keyword">this</span>.ms);
        a.del = <span class="keyword">this</span>.del;
        a.times = math.floor(mmax(times, <span class="number">0</span>)) || <span class="number">1</span>;
        <span class="keyword">return</span> a;
    };
    <span class="function"><span class="keyword">function</span> <span class="title">runAnimation</span><span class="params">(anim, element, percent, status, totalOrigin, times)</span> {</span>
        percent = toFloat(percent);
        <span class="keyword">var</span> params,
            isInAnim,
            isInAnimSet,
            percents = [],
            next,
            prev,
            timestamp,
            ms = anim.ms,
            from = {},
            to = {},
            diff = {};
        <span class="keyword">if</span> (status) {
            <span class="keyword">for</span> (i = <span class="number">0</span>, ii = animationElements.length; i &lt; ii; i++) {
                <span class="keyword">var</span> e = animationElements[i];
                <span class="keyword">if</span> (e.el.id == element.id &amp;&amp; e.anim == anim) {
                    <span class="keyword">if</span> (e.percent != percent) {
                        animationElements.splice(i, <span class="number">1</span>);
                        isInAnimSet = <span class="number">1</span>;
                    } <span class="keyword">else</span> {
                        isInAnim = e;
                    }
                    element.attr(e.totalOrigin);
                    <span class="keyword">break</span>;
                }
            }
        } <span class="keyword">else</span> {
            status = +to; <span class="comment">// NaN</span>
        }
        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, ii = anim.percents.length; i &lt; ii; i++) {
            <span class="keyword">if</span> (anim.percents[i] == percent || anim.percents[i] &gt; status * anim.top) {
                percent = anim.percents[i];
                prev = anim.percents[i - <span class="number">1</span>] || <span class="number">0</span>;
                ms = ms / anim.top * (percent - prev);
                next = anim.percents[i + <span class="number">1</span>];
                params = anim.anim[percent];
                <span class="keyword">break</span>;
            } <span class="keyword">else</span> <span class="keyword">if</span> (status) {
                element.attr(anim.anim[anim.percents[i]]);
            }
        }
        <span class="keyword">if</span> (!params) {
            <span class="keyword">return</span>;
        }
        <span class="keyword">if</span> (!isInAnim) {
            <span class="keyword">for</span> (<span class="keyword">var</span> attr <span class="keyword">in</span> params) <span class="keyword">if</span> (params[has](attr)) {
                <span class="keyword">if</span> (availableAnimAttrs[has](attr) || element.paper.customAttributes[has](attr)) {
                    from[attr] = element.attr(attr);
                    (from[attr] == <span class="literal">null</span>) &amp;&amp; (from[attr] = availableAttrs[attr]);
                    to[attr] = params[attr];
                    <span class="keyword">switch</span> (availableAnimAttrs[attr]) {
                        <span class="keyword">case</span> nu:
                            diff[attr] = (to[attr] - from[attr]) / ms;
                            <span class="keyword">break</span>;
                        <span class="keyword">case</span> <span class="string">"colour"</span>:
                            from[attr] = R.getRGB(from[attr]);
                            <span class="keyword">var</span> toColour = R.getRGB(to[attr]);
                            diff[attr] = {
                                r: (toColour.r - from[attr].r) / ms,
                                g: (toColour.g - from[attr].g) / ms,
                                b: (toColour.b - from[attr].b) / ms
                            };
                            <span class="keyword">break</span>;
                        <span class="keyword">case</span> <span class="string">"path"</span>:
                            <span class="keyword">var</span> pathes = path2curve(from[attr], to[attr]),
                                toPath = pathes[<span class="number">1</span>];
                            from[attr] = pathes[<span class="number">0</span>];
                            diff[attr] = [];
                            <span class="keyword">for</span> (i = <span class="number">0</span>, ii = from[attr].length; i &lt; ii; i++) {
                                diff[attr][i] = [<span class="number">0</span>];
                                <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">1</span>, jj = from[attr][i].length; j &lt; jj; j++) {
                                    diff[attr][i][j] = (toPath[i][j] - from[attr][i][j]) / ms;
                                }
                            }
                            <span class="keyword">break</span>;
                        <span class="keyword">case</span> <span class="string">"transform"</span>:
                            <span class="keyword">var</span> _ = element._,
                                eq = equaliseTransform(_[attr], to[attr]);
                            <span class="keyword">if</span> (eq) {
                                from[attr] = eq.from;
                                to[attr] = eq.to;
                                diff[attr] = [];
                                diff[attr].real = <span class="literal">true</span>;
                                <span class="keyword">for</span> (i = <span class="number">0</span>, ii = from[attr].length; i &lt; ii; i++) {
                                    diff[attr][i] = [from[attr][i][<span class="number">0</span>]];
                                    <span class="keyword">for</span> (j = <span class="number">1</span>, jj = from[attr][i].length; j &lt; jj; j++) {
                                        diff[attr][i][j] = (to[attr][i][j] - from[attr][i][j]) / ms;
                                    }
                                }
                            } <span class="keyword">else</span> {
                                <span class="keyword">var</span> m = (element.matrix || <span class="keyword">new</span> Matrix),
                                    to2 = {
                                        _: {transform: _.transform},
                                        getBBox: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
                                            <span class="keyword">return</span> element.getBBox(<span class="number">1</span>);
                                        }
                                    };
                                from[attr] = [
                                    m.a,
                                    m.b,
                                    m.c,
                                    m.d,
                                    m.e,
                                    m.f
                                ];
                                extractTransform(to2, to[attr]);
                                to[attr] = to2._.transform;
                                diff[attr] = [
                                    (to2.matrix.a - m.a) / ms,
                                    (to2.matrix.b - m.b) / ms,
                                    (to2.matrix.c - m.c) / ms,
                                    (to2.matrix.d - m.d) / ms,
                                    (to2.matrix.e - m.e) / ms,
                                    (to2.matrix.f - m.f) / ms
                                ];</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>from[attr] = [<em>.sx, </em>.sy, <em>.deg, </em>.dx, <em>.dy];
var to2 = {</em>:{}, getBBox: function () { return element.getBBox(); }};
extractTransform(to2, to[attr]);
diff[attr] = [
    (to2.<em>.sx - </em>.sx) / ms,
    (to2.<em>.sy - </em>.sy) / ms,
    (to2.<em>.deg - </em>.deg) / ms,
    (to2.<em>.dx - </em>.dx) / ms,
    (to2.<em>.dy - </em>.dy) / ms
];</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                            }
                            <span class="keyword">break</span>;
                        <span class="keyword">case</span> <span class="string">"csv"</span>:
                            <span class="keyword">var</span> values = Str(params[attr])[split](separator),
                                from2 = Str(from[attr])[split](separator);
                            <span class="keyword">if</span> (attr == <span class="string">"clip-rect"</span>) {
                                from[attr] = from2;
                                diff[attr] = [];
                                i = from2.length;
                                <span class="keyword">while</span> (i--) {
                                    diff[attr][i] = (values[i] - from[attr][i]) / ms;
                                }
                            }
                            to[attr] = values;
                            <span class="keyword">break</span>;
                        <span class="keyword">default</span>:
                            values = [][concat](params[attr]);
                            from2 = [][concat](from[attr]);
                            diff[attr] = [];
                            i = element.paper.customAttributes[attr].length;
                            <span class="keyword">while</span> (i--) {
                                diff[attr][i] = ((values[i] || <span class="number">0</span>) - (from2[i] || <span class="number">0</span>)) / ms;
                            }
                            <span class="keyword">break</span>;
                    }
                }
            }
            <span class="keyword">var</span> easing = params.easing,
                easyeasy = R.easing_formulas[easing];
            <span class="keyword">if</span> (!easyeasy) {
                easyeasy = Str(easing).match(bezierrg);
                <span class="keyword">if</span> (easyeasy &amp;&amp; easyeasy.length == <span class="number">5</span>) {
                    <span class="keyword">var</span> curve = easyeasy;
                    easyeasy = <span class="function"><span class="keyword">function</span> <span class="params">(t)</span> {</span>
                        <span class="keyword">return</span> CubicBezierAtTime(t, +curve[<span class="number">1</span>], +curve[<span class="number">2</span>], +curve[<span class="number">3</span>], +curve[<span class="number">4</span>], ms);
                    };
                } <span class="keyword">else</span> {
                    easyeasy = pipe;
                }
            }
            timestamp = params.start || anim.start || +<span class="keyword">new</span> Date;
            e = {
                anim: anim,
                percent: percent,
                timestamp: timestamp,
                start: timestamp + (anim.del || <span class="number">0</span>),
                status: <span class="number">0</span>,
                initstatus: status || <span class="number">0</span>,
                stop: <span class="literal">false</span>,
                ms: ms,
                easing: easyeasy,
                from: from,
                diff: diff,
                to: to,
                el: element,
                callback: params.callback,
                prev: prev,
                next: next,
                repeat: times || anim.times,
                origin: element.attr(),
                totalOrigin: totalOrigin
            };
            animationElements.push(e);
            <span class="keyword">if</span> (status &amp;&amp; !isInAnim &amp;&amp; !isInAnimSet) {
                e.stop = <span class="literal">true</span>;
                e.start = <span class="keyword">new</span> Date - ms * status;
                <span class="keyword">if</span> (animationElements.length == <span class="number">1</span>) {
                    <span class="keyword">return</span> animation();
                }
            }
            <span class="keyword">if</span> (isInAnimSet) {
                e.start = <span class="keyword">new</span> Date - e.ms * status;
            }
            animationElements.length == <span class="number">1</span> &amp;&amp; requestAnimFrame(animation);
        } <span class="keyword">else</span> {
            isInAnim.initstatus = status;
            isInAnim.start = <span class="keyword">new</span> Date - isInAnim.ms * status;
        }
        eve(<span class="string">"raphael.anim.start."</span> + element.id, element, anim);
    }
    <span class="comment">/*\
     * Raphael.animation
     [ method ]
     **
     * Creates an animation object that can be passed to the @Element.animate or @Element.animateWith methods.
     * See also @Animation.delay and @Animation.repeat methods.
     **
     &gt; Parameters
     **
     - params (object) final attributes for the element, see also @Element.attr
     - ms (number) number of milliseconds for animation to run
     - easing (string) #optional easing type. Accept one of @Raphael.easing_formulas or CSS format: `cubic&amp;#x2010;bezier(XX,&amp;#160;XX,&amp;#160;XX,&amp;#160;XX)`
     - callback (function) #optional callback function. Will be called at the end of animation.
     **
     = (object) @Animation
    \*/</span>
    R.animation = <span class="function"><span class="keyword">function</span> <span class="params">(params, ms, easing, callback)</span> {</span>
        <span class="keyword">if</span> (params <span class="keyword">instanceof</span> Animation) {
            <span class="keyword">return</span> params;
        }
        <span class="keyword">if</span> (R.is(easing, <span class="string">"function"</span>) || !easing) {
            callback = callback || easing || <span class="literal">null</span>;
            easing = <span class="literal">null</span>;
        }
        params = Object(params);
        ms = +ms || <span class="number">0</span>;
        <span class="keyword">var</span> p = {},
            json,
            attr;
        <span class="keyword">for</span> (attr <span class="keyword">in</span> params) <span class="keyword">if</span> (params[has](attr) &amp;&amp; toFloat(attr) != attr &amp;&amp; toFloat(attr) + <span class="string">"%"</span> != attr) {
            json = <span class="literal">true</span>;
            p[attr] = params[attr];
        }
        <span class="keyword">if</span> (!json) {
            <span class="keyword">return</span> <span class="keyword">new</span> Animation(params, ms);
        } <span class="keyword">else</span> {
            easing &amp;&amp; (p.easing = easing);
            callback &amp;&amp; (p.callback = callback);
            <span class="keyword">return</span> <span class="keyword">new</span> Animation({<span class="number">100</span>: p}, ms);
        }
    };
    <span class="comment">/*\
     * Element.animate
     [ method ]
     **
     * Creates and starts animation for given element.
     **
     &gt; Parameters
     **
     - params (object) final attributes for the element, see also @Element.attr
     - ms (number) number of milliseconds for animation to run
     - easing (string) #optional easing type. Accept one of @Raphael.easing_formulas or CSS format: `cubic&amp;#x2010;bezier(XX,&amp;#160;XX,&amp;#160;XX,&amp;#160;XX)`
     - callback (function) #optional callback function. Will be called at the end of animation.
     * or
     - animation (object) animation object, see @Raphael.animation
     **
     = (object) original element
    \*/</span>
    elproto.animate = <span class="function"><span class="keyword">function</span> <span class="params">(params, ms, easing, callback)</span> {</span>
        <span class="keyword">var</span> element = <span class="keyword">this</span>;
        <span class="keyword">if</span> (element.removed) {
            callback &amp;&amp; callback.call(element);
            <span class="keyword">return</span> element;
        }
        <span class="keyword">var</span> anim = params <span class="keyword">instanceof</span> Animation ? params : R.animation(params, ms, easing, callback);
        runAnimation(anim, element, anim.percents[<span class="number">0</span>], <span class="literal">null</span>, element.attr());
        <span class="keyword">return</span> element;
    };
    <span class="comment">/*\
     * Element.setTime
     [ method ]
     **
     * Sets the status of animation of the element in milliseconds. Similar to @Element.status method.
     **
     &gt; Parameters
     **
     - anim (object) animation object
     - value (number) number of milliseconds from the beginning of the animation
     **
     = (object) original element if `value` is specified
     * Note, that during animation following events are triggered:
     *
     * On each animation frame event `anim.frame.&lt;id&gt;`, on start `anim.start.&lt;id&gt;` and on end `anim.finish.&lt;id&gt;`.
    \*/</span>
    elproto.setTime = <span class="function"><span class="keyword">function</span> <span class="params">(anim, value)</span> {</span>
        <span class="keyword">if</span> (anim &amp;&amp; value != <span class="literal">null</span>) {
            <span class="keyword">this</span>.status(anim, mmin(value, anim.ms) / anim.ms);
        }
        <span class="keyword">return</span> <span class="keyword">this</span>;
    };
    <span class="comment">/*\
     * Element.status
     [ method ]
     **
     * Gets or sets the status of animation of the element.
     **
     &gt; Parameters
     **
     - anim (object) #optional animation object
     - value (number) #optional 0 – 1. If specified, method works like a setter and sets the status of a given animation to the value. This will cause animation to jump to the given position.
     **
     = (number) status
     * or
     = (array) status if `anim` is not specified. Array of objects in format:
     o {
     o     anim: (object) animation object
     o     status: (number) status
     o }
     * or
     = (object) original element if `value` is specified
    \*/</span>
    elproto.status = <span class="function"><span class="keyword">function</span> <span class="params">(anim, value)</span> {</span>
        <span class="keyword">var</span> out = [],
            i = <span class="number">0</span>,
            len,
            e;
        <span class="keyword">if</span> (value != <span class="literal">null</span>) {
            runAnimation(anim, <span class="keyword">this</span>, -<span class="number">1</span>, mmin(value, <span class="number">1</span>));
            <span class="keyword">return</span> <span class="keyword">this</span>;
        } <span class="keyword">else</span> {
            len = animationElements.length;
            <span class="keyword">for</span> (; i &lt; len; i++) {
                e = animationElements[i];
                <span class="keyword">if</span> (e.el.id == <span class="keyword">this</span>.id &amp;&amp; (!anim || e.anim == anim)) {
                    <span class="keyword">if</span> (anim) {
                        <span class="keyword">return</span> e.status;
                    }
                    out.push({
                        anim: e.anim,
                        status: e.status
                    });
                }
            }
            <span class="keyword">if</span> (anim) {
                <span class="keyword">return</span> <span class="number">0</span>;
            }
            <span class="keyword">return</span> out;
        }
    };
    <span class="comment">/*\
     * Element.pause
     [ method ]
     **
     * Stops animation of the element with ability to resume it later on.
     **
     &gt; Parameters
     **
     - anim (object) #optional animation object
     **
     = (object) original element
    \*/</span>
    elproto.pause = <span class="function"><span class="keyword">function</span> <span class="params">(anim)</span> {</span>
        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; animationElements.length; i++) <span class="keyword">if</span> (animationElements[i].el.id == <span class="keyword">this</span>.id &amp;&amp; (!anim || animationElements[i].anim == anim)) {
            <span class="keyword">if</span> (eve(<span class="string">"raphael.anim.pause."</span> + <span class="keyword">this</span>.id, <span class="keyword">this</span>, animationElements[i].anim) !== <span class="literal">false</span>) {
                animationElements[i].paused = <span class="literal">true</span>;
            }
        }
        <span class="keyword">return</span> <span class="keyword">this</span>;
    };
    <span class="comment">/*\
     * Element.resume
     [ method ]
     **
     * Resumes animation if it was paused with @Element.pause method.
     **
     &gt; Parameters
     **
     - anim (object) #optional animation object
     **
     = (object) original element
    \*/</span>
    elproto.resume = <span class="function"><span class="keyword">function</span> <span class="params">(anim)</span> {</span>
        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; animationElements.length; i++) <span class="keyword">if</span> (animationElements[i].el.id == <span class="keyword">this</span>.id &amp;&amp; (!anim || animationElements[i].anim == anim)) {
            <span class="keyword">var</span> e = animationElements[i];
            <span class="keyword">if</span> (eve(<span class="string">"raphael.anim.resume."</span> + <span class="keyword">this</span>.id, <span class="keyword">this</span>, e.anim) !== <span class="literal">false</span>) {
                <span class="keyword">delete</span> e.paused;
                <span class="keyword">this</span>.status(e.anim, e.status);
            }
        }
        <span class="keyword">return</span> <span class="keyword">this</span>;
    };
    <span class="comment">/*\
     * Element.stop
     [ method ]
     **
     * Stops animation of the element.
     **
     &gt; Parameters
     **
     - anim (object) #optional animation object
     **
     = (object) original element
    \*/</span>
    elproto.stop = <span class="function"><span class="keyword">function</span> <span class="params">(anim)</span> {</span>
        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; animationElements.length; i++) <span class="keyword">if</span> (animationElements[i].el.id == <span class="keyword">this</span>.id &amp;&amp; (!anim || animationElements[i].anim == anim)) {
            <span class="keyword">if</span> (eve(<span class="string">"raphael.anim.stop."</span> + <span class="keyword">this</span>.id, <span class="keyword">this</span>, animationElements[i].anim) !== <span class="literal">false</span>) {
                animationElements.splice(i--, <span class="number">1</span>);
            }
        }
        <span class="keyword">return</span> <span class="keyword">this</span>;
    };
    <span class="function"><span class="keyword">function</span> <span class="title">stopAnimation</span><span class="params">(paper)</span> {</span>
        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; animationElements.length; i++) <span class="keyword">if</span> (animationElements[i].el.paper == paper) {
            animationElements.splice(i--, <span class="number">1</span>);
        }
    }
    eve.on(<span class="string">"raphael.remove"</span>, stopAnimation);
    eve.on(<span class="string">"raphael.clear"</span>, stopAnimation);
    elproto.toString = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">return</span> <span class="string">"Rapha\xebl\u2019s object"</span>;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>Set</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> Set = <span class="function"><span class="keyword">function</span> <span class="params">(items)</span> {</span>
        <span class="keyword">this</span>.items = [];
        <span class="keyword">this</span>.length = <span class="number">0</span>;
        <span class="keyword">this</span>.type = <span class="string">"set"</span>;
        <span class="keyword">if</span> (items) {
            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, ii = items.length; i &lt; ii; i++) {
                <span class="keyword">if</span> (items[i] &amp;&amp; (items[i].constructor == elproto.constructor || items[i].constructor == Set)) {
                    <span class="keyword">this</span>[<span class="keyword">this</span>.items.length] = <span class="keyword">this</span>.items[<span class="keyword">this</span>.items.length] = items[i];
                    <span class="keyword">this</span>.length++;
                }
            }
        }
    },
    setproto = Set.prototype;
    <span class="comment">/*\
     * Set.push
     [ method ]
     **
     * Adds each argument to the current set.
     = (object) original element
    \*/</span>
    setproto.push = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">var</span> item,
            len;
        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, ii = arguments.length; i &lt; ii; i++) {
            item = arguments[i];
            <span class="keyword">if</span> (item &amp;&amp; (item.constructor == elproto.constructor || item.constructor == Set)) {
                len = <span class="keyword">this</span>.items.length;
                <span class="keyword">this</span>[len] = <span class="keyword">this</span>.items[len] = item;
                <span class="keyword">this</span>.length++;
            }
        }
        <span class="keyword">return</span> <span class="keyword">this</span>;
    };
    <span class="comment">/*\
     * Set.pop
     [ method ]
     **
     * Removes last element and returns it.
     = (object) element
    \*/</span>
    setproto.pop = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">this</span>.length &amp;&amp; <span class="keyword">delete</span> <span class="keyword">this</span>[<span class="keyword">this</span>.length--];
        <span class="keyword">return</span> <span class="keyword">this</span>.items.pop();
    };
    <span class="comment">/*\
     * Set.forEach
     [ method ]
     **
     * Executes given function for each element in the set.
     *
     * If function returns `false` it will stop loop running.
     **
     &gt; Parameters
     **
     - callback (function) function to run
     - thisArg (object) context object for the callback
     = (object) Set object
    \*/</span>
    setproto.forEach = <span class="function"><span class="keyword">function</span> <span class="params">(callback, thisArg)</span> {</span>
        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, ii = <span class="keyword">this</span>.items.length; i &lt; ii; i++) {
            <span class="keyword">if</span> (callback.call(thisArg, <span class="keyword">this</span>.items[i], i) === <span class="literal">false</span>) {
                <span class="keyword">return</span> <span class="keyword">this</span>;
            }
        }
        <span class="keyword">return</span> <span class="keyword">this</span>;
    };
    <span class="keyword">for</span> (<span class="keyword">var</span> method <span class="keyword">in</span> elproto) <span class="keyword">if</span> (elproto[has](method)) {
        setproto[method] = (<span class="function"><span class="keyword">function</span> <span class="params">(methodname)</span> {</span>
            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
                <span class="keyword">var</span> arg = arguments;
                <span class="keyword">return</span> <span class="keyword">this</span>.forEach(<span class="function"><span class="keyword">function</span> <span class="params">(el)</span> {</span>
                    el[methodname][apply](el, arg);
                });
            };
        })(method);
    }
    setproto.attr = <span class="function"><span class="keyword">function</span> <span class="params">(name, value)</span> {</span>
        <span class="keyword">if</span> (name &amp;&amp; R.is(name, array) &amp;&amp; R.is(name[<span class="number">0</span>], <span class="string">"object"</span>)) {
            <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>, jj = name.length; j &lt; jj; j++) {
                <span class="keyword">this</span>.items[j].attr(name[j]);
            }
        } <span class="keyword">else</span> {
            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, ii = <span class="keyword">this</span>.items.length; i &lt; ii; i++) {
                <span class="keyword">this</span>.items[i].attr(name, value);
            }
        }
        <span class="keyword">return</span> <span class="keyword">this</span>;
    };
    <span class="comment">/*\
     * Set.clear
     [ method ]
     **
     * Removeds all elements from the set
    \*/</span>
    setproto.clear = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">while</span> (<span class="keyword">this</span>.length) {
            <span class="keyword">this</span>.pop();
        }
    };
    <span class="comment">/*\
     * Set.splice
     [ method ]
     **
     * Removes given element from the set
     **
     &gt; Parameters
     **
     - index (number) position of the deletion
     - count (number) number of element to remove
     - insertion… (object) #optional elements to insert
     = (object) set elements that were deleted
    \*/</span>
    setproto.splice = <span class="function"><span class="keyword">function</span> <span class="params">(index, count, insertion)</span> {</span>
        index = index &lt; <span class="number">0</span> ? mmax(<span class="keyword">this</span>.length + index, <span class="number">0</span>) : index;
        count = mmax(<span class="number">0</span>, mmin(<span class="keyword">this</span>.length - index, count));
        <span class="keyword">var</span> tail = [],
            todel = [],
            args = [],
            i;
        <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; arguments.length; i++) {
            args.push(arguments[i]);
        }
        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) {
            todel.push(<span class="keyword">this</span>[index + i]);
        }
        <span class="keyword">for</span> (; i &lt; <span class="keyword">this</span>.length - index; i++) {
            tail.push(<span class="keyword">this</span>[index + i]);
        }
        <span class="keyword">var</span> arglen = args.length;
        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; arglen + tail.length; i++) {
            <span class="keyword">this</span>.items[index + i] = <span class="keyword">this</span>[index + i] = i &lt; arglen ? args[i] : tail[i - arglen];
        }
        i = <span class="keyword">this</span>.items.length = <span class="keyword">this</span>.length -= count - arglen;
        <span class="keyword">while</span> (<span class="keyword">this</span>[i]) {
            <span class="keyword">delete</span> <span class="keyword">this</span>[i++];
        }
        <span class="keyword">return</span> <span class="keyword">new</span> Set(todel);
    };
    <span class="comment">/*\
     * Set.exclude
     [ method ]
     **
     * Removes given element from the set
     **
     &gt; Parameters
     **
     - element (object) element to remove
     = (boolean) `true` if object was found &amp; removed from the set
    \*/</span>
    setproto.exclude = <span class="function"><span class="keyword">function</span> <span class="params">(el)</span> {</span>
        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, ii = <span class="keyword">this</span>.length; i &lt; ii; i++) <span class="keyword">if</span> (<span class="keyword">this</span>[i] == el) {
            <span class="keyword">this</span>.splice(i, <span class="number">1</span>);
            <span class="keyword">return</span> <span class="literal">true</span>;
        }
    };
    setproto.animate = <span class="function"><span class="keyword">function</span> <span class="params">(params, ms, easing, callback)</span> {</span>
        (R.is(easing, <span class="string">"function"</span>) || !easing) &amp;&amp; (callback = easing || <span class="literal">null</span>);
        <span class="keyword">var</span> len = <span class="keyword">this</span>.items.length,
            i = len,
            item,
            set = <span class="keyword">this</span>,
            collector;
        <span class="keyword">if</span> (!len) {
            <span class="keyword">return</span> <span class="keyword">this</span>;
        }
        callback &amp;&amp; (collector = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
            !--len &amp;&amp; callback.call(set);
        });
        easing = R.is(easing, string) ? easing : collector;
        <span class="keyword">var</span> anim = R.animation(params, ms, easing, collector);
        item = <span class="keyword">this</span>.items[--i].animate(anim);
        <span class="keyword">while</span> (i--) {
            <span class="keyword">this</span>.items[i] &amp;&amp; !<span class="keyword">this</span>.items[i].removed &amp;&amp; <span class="keyword">this</span>.items[i].animateWith(item, anim, anim);
            (<span class="keyword">this</span>.items[i] &amp;&amp; !<span class="keyword">this</span>.items[i].removed) || len--;
        }
        <span class="keyword">return</span> <span class="keyword">this</span>;
    };
    setproto.insertAfter = <span class="function"><span class="keyword">function</span> <span class="params">(el)</span> {</span>
        <span class="keyword">var</span> i = <span class="keyword">this</span>.items.length;
        <span class="keyword">while</span> (i--) {
            <span class="keyword">this</span>.items[i].insertAfter(el);
        }
        <span class="keyword">return</span> <span class="keyword">this</span>;
    };
    setproto.getBBox = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">var</span> x = [],
            y = [],
            x2 = [],
            y2 = [];
        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="keyword">this</span>.items.length; i--;) <span class="keyword">if</span> (!<span class="keyword">this</span>.items[i].removed) {
            <span class="keyword">var</span> box = <span class="keyword">this</span>.items[i].getBBox();
            x.push(box.x);
            y.push(box.y);
            x2.push(box.x + box.width);
            y2.push(box.y + box.height);
        }
        x = mmin[apply](<span class="number">0</span>, x);
        y = mmin[apply](<span class="number">0</span>, y);
        x2 = mmax[apply](<span class="number">0</span>, x2);
        y2 = mmax[apply](<span class="number">0</span>, y2);
        <span class="keyword">return</span> {
            x: x,
            y: y,
            x2: x2,
            y2: y2,
            width: x2 - x,
            height: y2 - y
        };
    };
    setproto.clone = <span class="function"><span class="keyword">function</span> <span class="params">(s)</span> {</span>
        s = <span class="keyword">this</span>.paper.set();
        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, ii = <span class="keyword">this</span>.items.length; i &lt; ii; i++) {
            s.push(<span class="keyword">this</span>.items[i].clone());
        }
        <span class="keyword">return</span> s;
    };
    setproto.toString = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">return</span> <span class="string">"Rapha\xebl\u2018s set"</span>;
    };

    setproto.glow = <span class="keyword">function</span>(glowConfig) {
        <span class="keyword">var</span> ret = <span class="keyword">this</span>.paper.set();
        <span class="keyword">this</span>.forEach(<span class="keyword">function</span>(shape, index){
            <span class="keyword">var</span> g = shape.glow(glowConfig);
            <span class="keyword">if</span>(g != <span class="literal">null</span>){
                g.forEach(<span class="keyword">function</span>(shape2, index2){
                    ret.push(shape2);
                });
            }
        });
        <span class="keyword">return</span> ret;
    };


    <span class="comment">/*\
     * Set.isPointInside
     [ method ]
     **
     * Determine if given point is inside this set’s elements
     **
     &gt; Parameters
     **
     - x (number) x coordinate of the point
     - y (number) y coordinate of the point
     = (boolean) `true` if point is inside any of the set's elements
     \*/</span>
    setproto.isPointInside = <span class="function"><span class="keyword">function</span> <span class="params">(x, y)</span> {</span>
        <span class="keyword">var</span> isPointInside = <span class="literal">false</span>;
        <span class="keyword">this</span>.forEach(<span class="function"><span class="keyword">function</span> <span class="params">(el)</span> {</span>
            <span class="keyword">if</span> (el.isPointInside(x, y)) {
                console.log(<span class="string">'runned'</span>);
                isPointInside = <span class="literal">true</span>;
                <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// stop loop</span>
            }
        });
        <span class="keyword">return</span> isPointInside;
    };

    <span class="comment">/*\
     * Raphael.registerFont
     [ method ]
     **
     * Adds given font to the registered set of fonts for Raphaël. Should be used as an internal call from within Cufón’s font file.
     * Returns original parameter, so it could be used with chaining.
     # &lt;a href="http://wiki.github.com/sorccu/cufon/about"&gt;More about Cufón and how to convert your font form TTF, OTF, etc to JavaScript file.&lt;/a&gt;
     **
     &gt; Parameters
     **
     - font (object) the font to register
     = (object) the font you passed in
     &gt; Usage
     | Cufon.registerFont(Raphael.registerFont({…}));
    \*/</span>
    R.registerFont = <span class="function"><span class="keyword">function</span> <span class="params">(font)</span> {</span>
        <span class="keyword">if</span> (!font.face) {
            <span class="keyword">return</span> font;
        }
        <span class="keyword">this</span>.fonts = <span class="keyword">this</span>.fonts || {};
        <span class="keyword">var</span> fontcopy = {
                w: font.w,
                face: {},
                glyphs: {}
            },
            family = font.face[<span class="string">"font-family"</span>];
        <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> font.face) <span class="keyword">if</span> (font.face[has](prop)) {
            fontcopy.face[prop] = font.face[prop];
        }
        <span class="keyword">if</span> (<span class="keyword">this</span>.fonts[family]) {
            <span class="keyword">this</span>.fonts[family].push(fontcopy);
        } <span class="keyword">else</span> {
            <span class="keyword">this</span>.fonts[family] = [fontcopy];
        }
        <span class="keyword">if</span> (!font.svg) {
            fontcopy.face[<span class="string">"units-per-em"</span>] = toInt(font.face[<span class="string">"units-per-em"</span>], <span class="number">10</span>);
            <span class="keyword">for</span> (<span class="keyword">var</span> glyph <span class="keyword">in</span> font.glyphs) <span class="keyword">if</span> (font.glyphs[has](glyph)) {
                <span class="keyword">var</span> path = font.glyphs[glyph];
                fontcopy.glyphs[glyph] = {
                    w: path.w,
                    k: {},
                    d: path.d &amp;&amp; <span class="string">"M"</span> + path.d.replace(<span class="regexp">/[mlcxtrv]/g</span>, <span class="function"><span class="keyword">function</span> <span class="params">(command)</span> {</span>
                            <span class="keyword">return</span> {l: <span class="string">"L"</span>, c: <span class="string">"C"</span>, x: <span class="string">"z"</span>, t: <span class="string">"m"</span>, r: <span class="string">"l"</span>, v: <span class="string">"c"</span>}[command] || <span class="string">"M"</span>;
                        }) + <span class="string">"z"</span>
                };
                <span class="keyword">if</span> (path.k) {
                    <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> path.k) <span class="keyword">if</span> (path[has](k)) {
                        fontcopy.glyphs[glyph].k[k] = path.k[k];
                    }
                }
            }
        }
        <span class="keyword">return</span> font;
    };
    <span class="comment">/*\
     * Paper.getFont
     [ method ]
     **
     * Finds font object in the registered fonts by given parameters. You could specify only one word from the font name, like “Myriad” for “Myriad Pro”.
     **
     &gt; Parameters
     **
     - family (string) font family name or any word from it
     - weight (string) #optional font weight
     - style (string) #optional font style
     - stretch (string) #optional font stretch
     = (object) the font object
     &gt; Usage
     | paper.print(100, 100, "Test string", paper.getFont("Times", 800), 30);
    \*/</span>
    paperproto.getFont = <span class="function"><span class="keyword">function</span> <span class="params">(family, weight, style, stretch)</span> {</span>
        stretch = stretch || <span class="string">"normal"</span>;
        style = style || <span class="string">"normal"</span>;
        weight = +weight || {normal: <span class="number">400</span>, bold: <span class="number">700</span>, lighter: <span class="number">300</span>, bolder: <span class="number">800</span>}[weight] || <span class="number">400</span>;
        <span class="keyword">if</span> (!R.fonts) {
            <span class="keyword">return</span>;
        }
        <span class="keyword">var</span> font = R.fonts[family];
        <span class="keyword">if</span> (!font) {
            <span class="keyword">var</span> name = <span class="keyword">new</span> RegExp(<span class="string">"(^|\\s)"</span> + family.replace(<span class="regexp">/[^\w\d\s+!~.:_-]/g</span>, E) + <span class="string">"(\\s|$)"</span>, <span class="string">"i"</span>);
            <span class="keyword">for</span> (<span class="keyword">var</span> fontName <span class="keyword">in</span> R.fonts) <span class="keyword">if</span> (R.fonts[has](fontName)) {
                <span class="keyword">if</span> (name.test(fontName)) {
                    font = R.fonts[fontName];
                    <span class="keyword">break</span>;
                }
            }
        }
        <span class="keyword">var</span> thefont;
        <span class="keyword">if</span> (font) {
            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, ii = font.length; i &lt; ii; i++) {
                thefont = font[i];
                <span class="keyword">if</span> (thefont.face[<span class="string">"font-weight"</span>] == weight &amp;&amp; (thefont.face[<span class="string">"font-style"</span>] == style || !thefont.face[<span class="string">"font-style"</span>]) &amp;&amp; thefont.face[<span class="string">"font-stretch"</span>] == stretch) {
                    <span class="keyword">break</span>;
                }
            }
        }
        <span class="keyword">return</span> thefont;
    };
    <span class="comment">/*\
     * Paper.print
     [ method ]
     **
     * Creates path that represent given text written using given font at given position with given size.
     * Result of the method is path element that contains whole text as a separate path.
     **
     &gt; Parameters
     **
     - x (number) x position of the text
     - y (number) y position of the text
     - string (string) text to print
     - font (object) font object, see @Paper.getFont
     - size (number) #optional size of the font, default is `16`
     - origin (string) #optional could be `"baseline"` or `"middle"`, default is `"middle"`
     - letter_spacing (number) #optional number in range `-1..1`, default is `0`
     - line_spacing (number) #optional number in range `1..3`, default is `1`
     = (object) resulting path element, which consist of all letters
     &gt; Usage
     | var txt = r.print(10, 50, "print", r.getFont("Museo"), 30).attr({fill: "#fff"});
    \*/</span>
    paperproto.print = <span class="function"><span class="keyword">function</span> <span class="params">(x, y, string, font, size, origin, letter_spacing, line_spacing)</span> {</span>
        origin = origin || <span class="string">"middle"</span>; <span class="comment">// baseline|middle</span>
        letter_spacing = mmax(mmin(letter_spacing || <span class="number">0</span>, <span class="number">1</span>), -<span class="number">1</span>);
        line_spacing = mmax(mmin(line_spacing || <span class="number">1</span>, <span class="number">3</span>), <span class="number">1</span>);
        <span class="keyword">var</span> letters = Str(string)[split](E),
            shift = <span class="number">0</span>,
            notfirst = <span class="number">0</span>,
            path = E,
            scale;
        R.is(font, <span class="string">"string"</span>) &amp;&amp; (font = <span class="keyword">this</span>.getFont(font));
        <span class="keyword">if</span> (font) {
            scale = (size || <span class="number">16</span>) / font.face[<span class="string">"units-per-em"</span>];
            <span class="keyword">var</span> bb = font.face.bbox[split](separator),
                top = +bb[<span class="number">0</span>],
                lineHeight = bb[<span class="number">3</span>] - bb[<span class="number">1</span>],
                shifty = <span class="number">0</span>,
                height = +bb[<span class="number">1</span>] + (origin == <span class="string">"baseline"</span> ? lineHeight + (+font.face.descent) : lineHeight / <span class="number">2</span>);
            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, ii = letters.length; i &lt; ii; i++) {
                <span class="keyword">if</span> (letters[i] == <span class="string">"\n"</span>) {
                    shift = <span class="number">0</span>;
                    curr = <span class="number">0</span>;
                    notfirst = <span class="number">0</span>;
                    shifty += lineHeight * line_spacing;
                } <span class="keyword">else</span> {
                    <span class="keyword">var</span> prev = notfirst &amp;&amp; font.glyphs[letters[i - <span class="number">1</span>]] || {},
                        curr = font.glyphs[letters[i]];
                    shift += notfirst ? (prev.w || font.w) + (prev.k &amp;&amp; prev.k[letters[i]] || <span class="number">0</span>) + (font.w * letter_spacing) : <span class="number">0</span>;
                    notfirst = <span class="number">1</span>;
                }
                <span class="keyword">if</span> (curr &amp;&amp; curr.d) {
                    path += R.transformPath(curr.d, [<span class="string">"t"</span>, shift * scale, shifty * scale, <span class="string">"s"</span>, scale, scale, top, height, <span class="string">"t"</span>, (x - top) / scale, (y - height) / scale]);
                }
            }
        }
        <span class="keyword">return</span> <span class="keyword">this</span>.path(path).attr({
            fill: <span class="string">"#000"</span>,
            stroke: <span class="string">"none"</span>
        });
    };

    <span class="comment">/*\
     * Paper.add
     [ method ]
     **
     * Imports elements in JSON array in format `{type: type, &lt;attributes&gt;}`
     **
     &gt; Parameters
     **
     - json (array)
     = (object) resulting set of imported elements
     &gt; Usage
     | paper.add([
     |     {
     |         type: "circle",
     |         cx: 10,
     |         cy: 10,
     |         r: 5
     |     },
     |     {
     |         type: "rect",
     |         x: 10,
     |         y: 10,
     |         width: 10,
     |         height: 10,
     |         fill: "#fc0"
     |     }
     | ]);
    \*/</span>
    paperproto.add = <span class="function"><span class="keyword">function</span> <span class="params">(json)</span> {</span>
        <span class="keyword">if</span> (R.is(json, <span class="string">"array"</span>)) {
            <span class="keyword">var</span> res = <span class="keyword">this</span>.set(),
                i = <span class="number">0</span>,
                ii = json.length,
                j;
            <span class="keyword">for</span> (; i &lt; ii; i++) {
                j = json[i] || {};
                elements[has](j.type) &amp;&amp; res.push(<span class="keyword">this</span>[j.type]().attr(j));
            }
        }
        <span class="keyword">return</span> res;
    };

    <span class="comment">/*\
     * Raphael.format
     [ method ]
     **
     * Simple format function. Replaces construction of type “`{&lt;number&gt;}`” to the corresponding argument.
     **
     &gt; Parameters
     **
     - token (string) string to format
     - … (string) rest of arguments will be treated as parameters for replacement
     = (string) formated string
     &gt; Usage
     | var x = 10,
     |     y = 20,
     |     width = 40,
     |     height = 50;
     | // this will draw a rectangular shape equivalent to "M10,20h40v50h-40z"
     | paper.path(Raphael.format("M{0},{1}h{2}v{3}h{4}z", x, y, width, height, -width));
    \*/</span>
    R.format = <span class="function"><span class="keyword">function</span> <span class="params">(token, params)</span> {</span>
        <span class="keyword">var</span> args = R.is(params, array) ? [<span class="number">0</span>][concat](params) : arguments;
        token &amp;&amp; R.is(token, string) &amp;&amp; args.length - <span class="number">1</span> &amp;&amp; (token = token.replace(formatrg, <span class="function"><span class="keyword">function</span> <span class="params">(str, i)</span> {</span>
            <span class="keyword">return</span> args[++i] == <span class="literal">null</span> ? E : args[i];
        }));
        <span class="keyword">return</span> token || E;
    };
    <span class="comment">/*\
     * Raphael.fullfill
     [ method ]
     **
     * A little bit more advanced format function than @Raphael.format. Replaces construction of type “`{&lt;name&gt;}`” to the corresponding argument.
     **
     &gt; Parameters
     **
     - token (string) string to format
     - json (object) object which properties will be used as a replacement
     = (string) formated string
     &gt; Usage
     | // this will draw a rectangular shape equivalent to "M10,20h40v50h-40z"
     | paper.path(Raphael.fullfill("M{x},{y}h{dim.width}v{dim.height}h{dim['negative width']}z", {
     |     x: 10,
     |     y: 20,
     |     dim: {
     |         width: 40,
     |         height: 50,
     |         "negative width": -40
     |     }
     | }));
    \*/</span>
    R.fullfill = (<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">var</span> tokenRegex = <span class="regexp">/\{([^\}]+)\}/g</span>,
            objNotationRegex = <span class="regexp">/(?:(?:^|\.)(.+?)(?=\[|\.|$|\()|\[('|")(.+?)\2\])(\(\))?/g</span>, <span class="comment">// matches .xxxxx or ["xxxxx"] to run over object properties</span>
            replacer = <span class="function"><span class="keyword">function</span> <span class="params">(all, key, obj)</span> {</span>
                <span class="keyword">var</span> res = obj;
                key.replace(objNotationRegex, <span class="function"><span class="keyword">function</span> <span class="params">(all, name, quote, quotedName, isFunc)</span> {</span>
                    name = name || quotedName;
                    <span class="keyword">if</span> (res) {
                        <span class="keyword">if</span> (name <span class="keyword">in</span> res) {
                            res = res[name];
                        }
                        <span class="keyword">typeof</span> res == <span class="string">"function"</span> &amp;&amp; isFunc &amp;&amp; (res = res());
                    }
                });
                res = (res == <span class="literal">null</span> || res == obj ? all : res) + <span class="string">""</span>;
                <span class="keyword">return</span> res;
            };
        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(str, obj)</span> {</span>
            <span class="keyword">return</span> String(str).replace(tokenRegex, <span class="function"><span class="keyword">function</span> <span class="params">(all, key)</span> {</span>
                <span class="keyword">return</span> replacer(all, key, obj);
            });
        };
    })();
    <span class="comment">/*\
     * Raphael.ninja
     [ method ]
     **
     * If you want to leave no trace of Raphaël (Well, Raphaël creates only one global variable `Raphael`, but anyway.) You can use `ninja` method.
     * Beware, that in this case plugins could stop working, because they are depending on global variable existance.
     **
     = (object) Raphael object
     &gt; Usage
     | (function (local_raphael) {
     |     var paper = local_raphael(10, 10, 320, 200);
     |     …
     | })(Raphael.ninja());
    \*/</span>
    R.ninja = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        oldRaphael.was ? (g.win.Raphael = oldRaphael.is) : <span class="keyword">delete</span> Raphael;
        <span class="keyword">return</span> R;
    };
    <span class="comment">/*\
     * Raphael.st
     [ property (object) ]
     **
     * You can add your own method to elements and sets. It is wise to add a set method for each element method
     * you added, so you will be able to call the same method on sets too.
     **
     * See also @Raphael.el.
     &gt; Usage
     | Raphael.el.red = function () {
     |     this.attr({fill: "#f00"});
     | };
     | Raphael.st.red = function () {
     |     this.forEach(function (el) {
     |         el.red();
     |     });
     | };
     | // then use it
     | paper.set(paper.circle(100, 100, 20), paper.circle(110, 100, 20)).red();
    \*/</span>
    R.st = setproto;</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>Firefox &lt;3.6 fix: <a href="http://webreflection.blogspot.com/2009/11/195-chars-to-help-lazy-loading.html">http://webreflection.blogspot.com/2009/11/195-chars-to-help-lazy-loading.html</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    (<span class="function"><span class="keyword">function</span> <span class="params">(doc, loaded, f)</span> {</span>
        <span class="keyword">if</span> (doc.readyState == <span class="literal">null</span> &amp;&amp; doc.addEventListener){
            doc.addEventListener(loaded, f = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
                doc.removeEventListener(loaded, f, <span class="literal">false</span>);
                doc.readyState = <span class="string">"complete"</span>;
            }, <span class="literal">false</span>);
            doc.readyState = <span class="string">"loading"</span>;
        }
        <span class="function"><span class="keyword">function</span> <span class="title">isLoaded</span><span class="params">()</span> {</span>
            (<span class="regexp">/in/</span>).test(doc.readyState) ? setTimeout(isLoaded, <span class="number">9</span>) : R.eve(<span class="string">"raphael.DOMload"</span>);
        }
        isLoaded();
    })(document, <span class="string">"DOMContentLoaded"</span>);

    eve.on(<span class="string">"raphael.DOMload"</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        loaded = <span class="literal">true</span>;
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>┌─────────────────────────────────────────────────────────────────────┐ \
│ Raphaël - JavaScript Vector Library                                 │ \
├─────────────────────────────────────────────────────────────────────┤ \
│ SVG Module                                                          │ \
├─────────────────────────────────────────────────────────────────────┤ \
│ Copyright (c) 2008-2011 Dmitry Baranovskiy (<a href="http://raphaeljs.com">http://raphaeljs.com</a>)   │ \
│ Copyright (c) 2008-2011 Sencha Labs (<a href="http://sencha.com">http://sencha.com</a>)             │ \
│ Licensed under the MIT (<a href="http://raphaeljs.com/license.html">http://raphaeljs.com/license.html</a>) license. │ \
└─────────────────────────────────────────────────────────────────────┘ \</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>(<span class="keyword">function</span>(){
    <span class="keyword">if</span> (!R.svg) {
        <span class="keyword">return</span>;
    }
    <span class="keyword">var</span> has = <span class="string">"hasOwnProperty"</span>,
        Str = String,
        toFloat = parseFloat,
        toInt = parseInt,
        math = Math,
        mmax = math.max,
        abs = math.abs,
        pow = math.pow,
        separator = <span class="regexp">/[, ]+/</span>,
        eve = R.eve,
        E = <span class="string">""</span>,
        S = <span class="string">" "</span>;
    <span class="keyword">var</span> xlink = <span class="string">"http://www.w3.org/1999/xlink"</span>,
        markers = {
            block: <span class="string">"M5,0 0,2.5 5,5z"</span>,
            classic: <span class="string">"M5,0 0,2.5 5,5 3.5,3 3.5,2z"</span>,
            diamond: <span class="string">"M2.5,0 5,2.5 2.5,5 0,2.5z"</span>,
            open: <span class="string">"M6,1 1,3.5 6,6"</span>,
            oval: <span class="string">"M2.5,0A2.5,2.5,0,0,1,2.5,5 2.5,2.5,0,0,1,2.5,0z"</span>
        },
        markerCounter = {};
    R.toString = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">return</span>  <span class="string">"Your browser supports SVG.\nYou are running Rapha\xebl "</span> + <span class="keyword">this</span>.version;
    };
    <span class="keyword">var</span> $ = <span class="function"><span class="keyword">function</span> <span class="params">(el, attr)</span> {</span>
        <span class="keyword">if</span> (attr) {
            <span class="keyword">if</span> (<span class="keyword">typeof</span> el == <span class="string">"string"</span>) {
                el = $(el);
            }
            <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> attr) <span class="keyword">if</span> (attr[has](key)) {
                <span class="keyword">if</span> (key.substring(<span class="number">0</span>, <span class="number">6</span>) == <span class="string">"xlink:"</span>) {
                    el.setAttributeNS(xlink, key.substring(<span class="number">6</span>), Str(attr[key]));
                } <span class="keyword">else</span> {
                    el.setAttribute(key, Str(attr[key]));
                }
            }
        } <span class="keyword">else</span> {
            el = R._g.doc.createElementNS(<span class="string">"http://www.w3.org/2000/svg"</span>, el);
            el.style &amp;&amp; (el.style.webkitTapHighlightColor = <span class="string">"rgba(0,0,0,0)"</span>);
        }
        <span class="keyword">return</span> el;
    },
    addGradientFill = <span class="function"><span class="keyword">function</span> <span class="params">(element, gradient)</span> {</span>
        <span class="keyword">var</span> type = <span class="string">"linear"</span>,
            id = element.id + gradient,
            fx = <span class="number">.5</span>, fy = <span class="number">.5</span>,
            o = element.node,
            SVG = element.paper,
            s = o.style,
            el = R._g.doc.getElementById(id);
        <span class="keyword">if</span> (!el) {
            gradient = Str(gradient).replace(R._radial_gradient, <span class="function"><span class="keyword">function</span> <span class="params">(all, _fx, _fy)</span> {</span>
                type = <span class="string">"radial"</span>;
                <span class="keyword">if</span> (_fx &amp;&amp; _fy) {
                    fx = toFloat(_fx);
                    fy = toFloat(_fy);
                    <span class="keyword">var</span> dir = ((fy &gt; <span class="number">.5</span>) * <span class="number">2</span> - <span class="number">1</span>);
                    pow(fx - <span class="number">.5</span>, <span class="number">2</span>) + pow(fy - <span class="number">.5</span>, <span class="number">2</span>) &gt; <span class="number">.25</span> &amp;&amp;
                        (fy = math.sqrt(<span class="number">.25</span> - pow(fx - <span class="number">.5</span>, <span class="number">2</span>)) * dir + <span class="number">.5</span>) &amp;&amp;
                        fy != <span class="number">.5</span> &amp;&amp;
                        (fy = fy.toFixed(<span class="number">5</span>) - <span class="number">1e-5</span> * dir);
                }
                <span class="keyword">return</span> E;
            });
            gradient = gradient.split(<span class="regexp">/\s*\-\s*/</span>);
            <span class="keyword">if</span> (type == <span class="string">"linear"</span>) {
                <span class="keyword">var</span> angle = gradient.shift();
                angle = -toFloat(angle);
                <span class="keyword">if</span> (isNaN(angle)) {
                    <span class="keyword">return</span> <span class="literal">null</span>;
                }
                <span class="keyword">var</span> vector = [<span class="number">0</span>, <span class="number">0</span>, math.cos(R.rad(angle)), math.sin(R.rad(angle))],
                    max = <span class="number">1</span> / (mmax(abs(vector[<span class="number">2</span>]), abs(vector[<span class="number">3</span>])) || <span class="number">1</span>);
                vector[<span class="number">2</span>] *= max;
                vector[<span class="number">3</span>] *= max;
                <span class="keyword">if</span> (vector[<span class="number">2</span>] &lt; <span class="number">0</span>) {
                    vector[<span class="number">0</span>] = -vector[<span class="number">2</span>];
                    vector[<span class="number">2</span>] = <span class="number">0</span>;
                }
                <span class="keyword">if</span> (vector[<span class="number">3</span>] &lt; <span class="number">0</span>) {
                    vector[<span class="number">1</span>] = -vector[<span class="number">3</span>];
                    vector[<span class="number">3</span>] = <span class="number">0</span>;
                }
            }
            <span class="keyword">var</span> dots = R._parseDots(gradient);
            <span class="keyword">if</span> (!dots) {
                <span class="keyword">return</span> <span class="literal">null</span>;
            }
            id = id.replace(<span class="regexp">/[\(\)\s,\xb0#]/g</span>, <span class="string">"_"</span>);
            
            <span class="keyword">if</span> (element.gradient &amp;&amp; id != element.gradient.id) {
                SVG.defs.removeChild(element.gradient);
                <span class="keyword">delete</span> element.gradient;
            }

            <span class="keyword">if</span> (!element.gradient) {
                el = $(type + <span class="string">"Gradient"</span>, {id: id});
                element.gradient = el;
                $(el, type == <span class="string">"radial"</span> ? {
                    fx: fx,
                    fy: fy
                } : {
                    x1: vector[<span class="number">0</span>],
                    y1: vector[<span class="number">1</span>],
                    x2: vector[<span class="number">2</span>],
                    y2: vector[<span class="number">3</span>],
                    gradientTransform: element.matrix.invert()
                });
                SVG.defs.appendChild(el);
                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, ii = dots.length; i &lt; ii; i++) {
                    el.appendChild($(<span class="string">"stop"</span>, {
                        offset: dots[i].offset ? dots[i].offset : i ? <span class="string">"100%"</span> : <span class="string">"0%"</span>,
                        <span class="string">"stop-color"</span>: dots[i].color || <span class="string">"#fff"</span>
                    }));
                }
            }
        }
        $(o, {
            fill: <span class="string">"url(#"</span> + id + <span class="string">")"</span>,
            opacity: <span class="number">1</span>,
            <span class="string">"fill-opacity"</span>: <span class="number">1</span>
        });
        s.fill = E;
        s.opacity = <span class="number">1</span>;
        s.fillOpacity = <span class="number">1</span>;
        <span class="keyword">return</span> <span class="number">1</span>;
    },
    updatePosition = <span class="function"><span class="keyword">function</span> <span class="params">(o)</span> {</span>
        <span class="keyword">var</span> bbox = o.getBBox(<span class="number">1</span>);
        $(o.pattern, {patternTransform: o.matrix.invert() + <span class="string">" translate("</span> + bbox.x + <span class="string">","</span> + bbox.y + <span class="string">")"</span>});
    },
    addArrow = <span class="function"><span class="keyword">function</span> <span class="params">(o, value, isEnd)</span> {</span>
        <span class="keyword">if</span> (o.type == <span class="string">"path"</span>) {
            <span class="keyword">var</span> values = Str(value).toLowerCase().split(<span class="string">"-"</span>),
                p = o.paper,
                se = isEnd ? <span class="string">"end"</span> : <span class="string">"start"</span>,
                node = o.node,
                attrs = o.attrs,
                stroke = attrs[<span class="string">"stroke-width"</span>],
                i = values.length,
                type = <span class="string">"classic"</span>,
                from,
                to,
                dx,
                refX,
                attr,
                w = <span class="number">3</span>,
                h = <span class="number">3</span>,
                t = <span class="number">5</span>;
            <span class="keyword">while</span> (i--) {
                <span class="keyword">switch</span> (values[i]) {
                    <span class="keyword">case</span> <span class="string">"block"</span>:
                    <span class="keyword">case</span> <span class="string">"classic"</span>:
                    <span class="keyword">case</span> <span class="string">"oval"</span>:
                    <span class="keyword">case</span> <span class="string">"diamond"</span>:
                    <span class="keyword">case</span> <span class="string">"open"</span>:
                    <span class="keyword">case</span> <span class="string">"none"</span>:
                        type = values[i];
                        <span class="keyword">break</span>;
                    <span class="keyword">case</span> <span class="string">"wide"</span>: h = <span class="number">5</span>; <span class="keyword">break</span>;
                    <span class="keyword">case</span> <span class="string">"narrow"</span>: h = <span class="number">2</span>; <span class="keyword">break</span>;
                    <span class="keyword">case</span> <span class="string">"long"</span>: w = <span class="number">5</span>; <span class="keyword">break</span>;
                    <span class="keyword">case</span> <span class="string">"short"</span>: w = <span class="number">2</span>; <span class="keyword">break</span>;
                }
            }
            <span class="keyword">if</span> (type == <span class="string">"open"</span>) {
                w += <span class="number">2</span>;
                h += <span class="number">2</span>;
                t += <span class="number">2</span>;
                dx = <span class="number">1</span>;
                refX = isEnd ? <span class="number">4</span> : <span class="number">1</span>;
                attr = {
                    fill: <span class="string">"none"</span>,
                    stroke: attrs.stroke
                };
            } <span class="keyword">else</span> {
                refX = dx = w / <span class="number">2</span>;
                attr = {
                    fill: attrs.stroke,
                    stroke: <span class="string">"none"</span>
                };
            }
            <span class="keyword">if</span> (o._.arrows) {
                <span class="keyword">if</span> (isEnd) {
                    o._.arrows.endPath &amp;&amp; markerCounter[o._.arrows.endPath]--;
                    o._.arrows.endMarker &amp;&amp; markerCounter[o._.arrows.endMarker]--;
                } <span class="keyword">else</span> {
                    o._.arrows.startPath &amp;&amp; markerCounter[o._.arrows.startPath]--;
                    o._.arrows.startMarker &amp;&amp; markerCounter[o._.arrows.startMarker]--;
                }
            } <span class="keyword">else</span> {
                o._.arrows = {};
            }
            <span class="keyword">if</span> (type != <span class="string">"none"</span>) {
                <span class="keyword">var</span> pathId = <span class="string">"raphael-marker-"</span> + type,
                    markerId = <span class="string">"raphael-marker-"</span> + se + type + w + h;
                <span class="keyword">if</span> (!R._g.doc.getElementById(pathId)) {
                    p.defs.appendChild($($(<span class="string">"path"</span>), {
                        <span class="string">"stroke-linecap"</span>: <span class="string">"round"</span>,
                        d: markers[type],
                        id: pathId
                    }));
                    markerCounter[pathId] = <span class="number">1</span>;
                } <span class="keyword">else</span> {
                    markerCounter[pathId]++;
                }
                <span class="keyword">var</span> marker = R._g.doc.getElementById(markerId),
                    use;
                <span class="keyword">if</span> (!marker) {
                    marker = $($(<span class="string">"marker"</span>), {
                        id: markerId,
                        markerHeight: h,
                        markerWidth: w,
                        orient: <span class="string">"auto"</span>,
                        refX: refX,
                        refY: h / <span class="number">2</span>
                    });
                    use = $($(<span class="string">"use"</span>), {
                        <span class="string">"xlink:href"</span>: <span class="string">"#"</span> + pathId,
                        transform: (isEnd ? <span class="string">"rotate(180 "</span> + w / <span class="number">2</span> + <span class="string">" "</span> + h / <span class="number">2</span> + <span class="string">") "</span> : E) + <span class="string">"scale("</span> + w / t + <span class="string">","</span> + h / t + <span class="string">")"</span>,
                        <span class="string">"stroke-width"</span>: (<span class="number">1</span> / ((w / t + h / t) / <span class="number">2</span>)).toFixed(<span class="number">4</span>)
                    });
                    marker.appendChild(use);
                    p.defs.appendChild(marker);
                    markerCounter[markerId] = <span class="number">1</span>;
                } <span class="keyword">else</span> {
                    markerCounter[markerId]++;
                    use = marker.getElementsByTagName(<span class="string">"use"</span>)[<span class="number">0</span>];
                }
                $(use, attr);
                <span class="keyword">var</span> delta = dx * (type != <span class="string">"diamond"</span> &amp;&amp; type != <span class="string">"oval"</span>);
                <span class="keyword">if</span> (isEnd) {
                    from = o._.arrows.startdx * stroke || <span class="number">0</span>;
                    to = R.getTotalLength(attrs.path) - delta * stroke;
                } <span class="keyword">else</span> {
                    from = delta * stroke;
                    to = R.getTotalLength(attrs.path) - (o._.arrows.enddx * stroke || <span class="number">0</span>);
                }
                attr = {};
                attr[<span class="string">"marker-"</span> + se] = <span class="string">"url(#"</span> + markerId + <span class="string">")"</span>;
                <span class="keyword">if</span> (to || from) {
                    attr.d = R.getSubpath(attrs.path, from, to);
                }
                $(node, attr);
                o._.arrows[se + <span class="string">"Path"</span>] = pathId;
                o._.arrows[se + <span class="string">"Marker"</span>] = markerId;
                o._.arrows[se + <span class="string">"dx"</span>] = delta;
                o._.arrows[se + <span class="string">"Type"</span>] = type;
                o._.arrows[se + <span class="string">"String"</span>] = value;
            } <span class="keyword">else</span> {
                <span class="keyword">if</span> (isEnd) {
                    from = o._.arrows.startdx * stroke || <span class="number">0</span>;
                    to = R.getTotalLength(attrs.path) - from;
                } <span class="keyword">else</span> {
                    from = <span class="number">0</span>;
                    to = R.getTotalLength(attrs.path) - (o._.arrows.enddx * stroke || <span class="number">0</span>);
                }
                o._.arrows[se + <span class="string">"Path"</span>] &amp;&amp; $(node, {d: R.getSubpath(attrs.path, from, to)});
                <span class="keyword">delete</span> o._.arrows[se + <span class="string">"Path"</span>];
                <span class="keyword">delete</span> o._.arrows[se + <span class="string">"Marker"</span>];
                <span class="keyword">delete</span> o._.arrows[se + <span class="string">"dx"</span>];
                <span class="keyword">delete</span> o._.arrows[se + <span class="string">"Type"</span>];
                <span class="keyword">delete</span> o._.arrows[se + <span class="string">"String"</span>];
            }
            <span class="keyword">for</span> (attr <span class="keyword">in</span> markerCounter) <span class="keyword">if</span> (markerCounter[has](attr) &amp;&amp; !markerCounter[attr]) {
                <span class="keyword">var</span> item = R._g.doc.getElementById(attr);
                item &amp;&amp; item.parentNode.removeChild(item);
            }
        }
    },
    dasharray = {
        <span class="string">""</span>: [<span class="number">0</span>],
        <span class="string">"none"</span>: [<span class="number">0</span>],
        <span class="string">"-"</span>: [<span class="number">3</span>, <span class="number">1</span>],
        <span class="string">"."</span>: [<span class="number">1</span>, <span class="number">1</span>],
        <span class="string">"-."</span>: [<span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],
        <span class="string">"-.."</span>: [<span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],
        <span class="string">". "</span>: [<span class="number">1</span>, <span class="number">3</span>],
        <span class="string">"- "</span>: [<span class="number">4</span>, <span class="number">3</span>],
        <span class="string">"--"</span>: [<span class="number">8</span>, <span class="number">3</span>],
        <span class="string">"- ."</span>: [<span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>],
        <span class="string">"--."</span>: [<span class="number">8</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>],
        <span class="string">"--.."</span>: [<span class="number">8</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>]
    },
    addDashes = <span class="function"><span class="keyword">function</span> <span class="params">(o, value, params)</span> {</span>
        value = dasharray[Str(value).toLowerCase()];
        <span class="keyword">if</span> (value) {
            <span class="keyword">var</span> width = o.attrs[<span class="string">"stroke-width"</span>] || <span class="string">"1"</span>,
                butt = {round: width, square: width, butt: <span class="number">0</span>}[o.attrs[<span class="string">"stroke-linecap"</span>] || params[<span class="string">"stroke-linecap"</span>]] || <span class="number">0</span>,
                dashes = [],
                i = value.length;
            <span class="keyword">while</span> (i--) {
                dashes[i] = value[i] * width + ((i % <span class="number">2</span>) ? <span class="number">1</span> : -<span class="number">1</span>) * butt;
            }
            $(o.node, {<span class="string">"stroke-dasharray"</span>: dashes.join(<span class="string">","</span>)});
        }
    },
    setFillAndStroke = <span class="function"><span class="keyword">function</span> <span class="params">(o, params)</span> {</span>
        <span class="keyword">var</span> node = o.node,
            attrs = o.attrs,
            vis = node.style.visibility;
        node.style.visibility = <span class="string">"hidden"</span>;
        <span class="keyword">for</span> (<span class="keyword">var</span> att <span class="keyword">in</span> params) {
            <span class="keyword">if</span> (params[has](att)) {
                <span class="keyword">if</span> (!R._availableAttrs[has](att)) {
                    <span class="keyword">continue</span>;
                }
                <span class="keyword">var</span> value = params[att];
                attrs[att] = value;
                <span class="keyword">switch</span> (att) {
                    <span class="keyword">case</span> <span class="string">"blur"</span>:
                        o.blur(value);
                        <span class="keyword">break</span>;
                    <span class="keyword">case</span> <span class="string">"href"</span>:
                    <span class="keyword">case</span> <span class="string">"title"</span>:
                    <span class="keyword">case</span> <span class="string">"target"</span>:
                        <span class="keyword">var</span> pn = node.parentNode;
                        <span class="keyword">if</span> (pn.tagName.toLowerCase() != <span class="string">"a"</span>) {
                            <span class="keyword">var</span> hl = $(<span class="string">"a"</span>);
                            pn.insertBefore(hl, node);
                            hl.appendChild(node);
                            pn = hl;
                        }
                        <span class="keyword">if</span> (att == <span class="string">"target"</span>) {
                            pn.setAttributeNS(xlink, <span class="string">"show"</span>, value == <span class="string">"blank"</span> ? <span class="string">"new"</span> : value);
                        } <span class="keyword">else</span> {
                            pn.setAttributeNS(xlink, att, value);
                        }
                        <span class="keyword">break</span>;
                    <span class="keyword">case</span> <span class="string">"cursor"</span>:
                        node.style.cursor = value;
                        <span class="keyword">break</span>;
                    <span class="keyword">case</span> <span class="string">"transform"</span>:
                        o.transform(value);
                        <span class="keyword">break</span>;
                    <span class="keyword">case</span> <span class="string">"arrow-start"</span>:
                        addArrow(o, value);
                        <span class="keyword">break</span>;
                    <span class="keyword">case</span> <span class="string">"arrow-end"</span>:
                        addArrow(o, value, <span class="number">1</span>);
                        <span class="keyword">break</span>;
                    <span class="keyword">case</span> <span class="string">"clip-rect"</span>:
                        <span class="keyword">var</span> rect = Str(value).split(separator);
                        <span class="keyword">if</span> (rect.length == <span class="number">4</span>) {
                            o.clip &amp;&amp; o.clip.parentNode.parentNode.removeChild(o.clip.parentNode);
                            <span class="keyword">var</span> el = $(<span class="string">"clipPath"</span>),
                                rc = $(<span class="string">"rect"</span>);
                            el.id = R.createUUID();
                            $(rc, {
                                x: rect[<span class="number">0</span>],
                                y: rect[<span class="number">1</span>],
                                width: rect[<span class="number">2</span>],
                                height: rect[<span class="number">3</span>]
                            });
                            el.appendChild(rc);
                            o.paper.defs.appendChild(el);
                            $(node, {<span class="string">"clip-path"</span>: <span class="string">"url(#"</span> + el.id + <span class="string">")"</span>});
                            o.clip = rc;
                        }
                        <span class="keyword">if</span> (!value) {
                            <span class="keyword">var</span> path = node.getAttribute(<span class="string">"clip-path"</span>);
                            <span class="keyword">if</span> (path) {
                                <span class="keyword">var</span> clip = R._g.doc.getElementById(path.replace(<span class="regexp">/(^url\(#|\)$)/g</span>, E));
                                clip &amp;&amp; clip.parentNode.removeChild(clip);
                                $(node, {<span class="string">"clip-path"</span>: E});
                                <span class="keyword">delete</span> o.clip;
                            }
                        }
                    <span class="keyword">break</span>;
                    <span class="keyword">case</span> <span class="string">"path"</span>:
                        <span class="keyword">if</span> (o.type == <span class="string">"path"</span>) {
                            $(node, {d: value ? attrs.path = R._pathToAbsolute(value) : <span class="string">"M0,0"</span>});
                            o._.dirty = <span class="number">1</span>;
                            <span class="keyword">if</span> (o._.arrows) {
                                <span class="string">"startString"</span> <span class="keyword">in</span> o._.arrows &amp;&amp; addArrow(o, o._.arrows.startString);
                                <span class="string">"endString"</span> <span class="keyword">in</span> o._.arrows &amp;&amp; addArrow(o, o._.arrows.endString, <span class="number">1</span>);
                            }
                        }
                        <span class="keyword">break</span>;
                    <span class="keyword">case</span> <span class="string">"width"</span>:
                        node.setAttribute(att, value);
                        o._.dirty = <span class="number">1</span>;
                        <span class="keyword">if</span> (attrs.fx) {
                            att = <span class="string">"x"</span>;
                            value = attrs.x;
                        } <span class="keyword">else</span> {
                            <span class="keyword">break</span>;
                        }
                    <span class="keyword">case</span> <span class="string">"x"</span>:
                        <span class="keyword">if</span> (attrs.fx) {
                            value = -attrs.x - (attrs.width || <span class="number">0</span>);
                        }
                    <span class="keyword">case</span> <span class="string">"rx"</span>:
                        <span class="keyword">if</span> (att == <span class="string">"rx"</span> &amp;&amp; o.type == <span class="string">"rect"</span>) {
                            <span class="keyword">break</span>;
                        }
                    <span class="keyword">case</span> <span class="string">"cx"</span>:
                        node.setAttribute(att, value);
                        o.pattern &amp;&amp; updatePosition(o);
                        o._.dirty = <span class="number">1</span>;
                        <span class="keyword">break</span>;
                    <span class="keyword">case</span> <span class="string">"height"</span>:
                        node.setAttribute(att, value);
                        o._.dirty = <span class="number">1</span>;
                        <span class="keyword">if</span> (attrs.fy) {
                            att = <span class="string">"y"</span>;
                            value = attrs.y;
                        } <span class="keyword">else</span> {
                            <span class="keyword">break</span>;
                        }
                    <span class="keyword">case</span> <span class="string">"y"</span>:
                        <span class="keyword">if</span> (attrs.fy) {
                            value = -attrs.y - (attrs.height || <span class="number">0</span>);
                        }
                    <span class="keyword">case</span> <span class="string">"ry"</span>:
                        <span class="keyword">if</span> (att == <span class="string">"ry"</span> &amp;&amp; o.type == <span class="string">"rect"</span>) {
                            <span class="keyword">break</span>;
                        }
                    <span class="keyword">case</span> <span class="string">"cy"</span>:
                        node.setAttribute(att, value);
                        o.pattern &amp;&amp; updatePosition(o);
                        o._.dirty = <span class="number">1</span>;
                        <span class="keyword">break</span>;
                    <span class="keyword">case</span> <span class="string">"r"</span>:
                        <span class="keyword">if</span> (o.type == <span class="string">"rect"</span>) {
                            $(node, {rx: value, ry: value});
                        } <span class="keyword">else</span> {
                            node.setAttribute(att, value);
                        }
                        o._.dirty = <span class="number">1</span>;
                        <span class="keyword">break</span>;
                    <span class="keyword">case</span> <span class="string">"src"</span>:
                        <span class="keyword">if</span> (o.type == <span class="string">"image"</span>) {
                            node.setAttributeNS(xlink, <span class="string">"href"</span>, value);
                        }
                        <span class="keyword">break</span>;
                    <span class="keyword">case</span> <span class="string">"stroke-width"</span>:
                        <span class="keyword">if</span> (o._.sx != <span class="number">1</span> || o._.sy != <span class="number">1</span>) {
                            value /= mmax(abs(o._.sx), abs(o._.sy)) || <span class="number">1</span>;
                        }
                        <span class="keyword">if</span> (o.paper._vbSize) {
                            value *= o.paper._vbSize;
                        }
                        node.setAttribute(att, value);
                        <span class="keyword">if</span> (attrs[<span class="string">"stroke-dasharray"</span>]) {
                            addDashes(o, attrs[<span class="string">"stroke-dasharray"</span>], params);
                        }
                        <span class="keyword">if</span> (o._.arrows) {
                            <span class="string">"startString"</span> <span class="keyword">in</span> o._.arrows &amp;&amp; addArrow(o, o._.arrows.startString);
                            <span class="string">"endString"</span> <span class="keyword">in</span> o._.arrows &amp;&amp; addArrow(o, o._.arrows.endString, <span class="number">1</span>);
                        }
                        <span class="keyword">break</span>;
                    <span class="keyword">case</span> <span class="string">"stroke-dasharray"</span>:
                        addDashes(o, value, params);
                        <span class="keyword">break</span>;
                    <span class="keyword">case</span> <span class="string">"fill"</span>:
                        <span class="keyword">var</span> isURL = Str(value).match(R._ISURL);
                        <span class="keyword">if</span> (isURL) {
                            el = $(<span class="string">"pattern"</span>);
                            <span class="keyword">var</span> ig = $(<span class="string">"image"</span>);
                            el.id = R.createUUID();
                            $(el, {x: <span class="number">0</span>, y: <span class="number">0</span>, patternUnits: <span class="string">"userSpaceOnUse"</span>, height: <span class="number">1</span>, width: <span class="number">1</span>});
                            $(ig, {x: <span class="number">0</span>, y: <span class="number">0</span>, <span class="string">"xlink:href"</span>: isURL[<span class="number">1</span>]});
                            el.appendChild(ig);

                            (<span class="function"><span class="keyword">function</span> <span class="params">(el)</span> {</span>
                                R._preload(isURL[<span class="number">1</span>], <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
                                    <span class="keyword">var</span> w = <span class="keyword">this</span>.offsetWidth,
                                        h = <span class="keyword">this</span>.offsetHeight;
                                    $(el, {width: w, height: h});
                                    $(ig, {width: w, height: h});
                                    o.paper.safari();
                                });
                            })(el);
                            o.paper.defs.appendChild(el);
                            $(node, {fill: <span class="string">"url(#"</span> + el.id + <span class="string">")"</span>});
                            o.pattern = el;
                            o.pattern &amp;&amp; updatePosition(o);
                            <span class="keyword">break</span>;
                        }
                        <span class="keyword">var</span> clr = R.getRGB(value);
                        <span class="keyword">if</span> (!clr.error) {
                            <span class="keyword">delete</span> params.gradient;
                            <span class="keyword">delete</span> attrs.gradient;
                            !R.is(attrs.opacity, <span class="string">"undefined"</span>) &amp;&amp;
                                R.is(params.opacity, <span class="string">"undefined"</span>) &amp;&amp;
                                $(node, {opacity: attrs.opacity});
                            !R.is(attrs[<span class="string">"fill-opacity"</span>], <span class="string">"undefined"</span>) &amp;&amp;
                                R.is(params[<span class="string">"fill-opacity"</span>], <span class="string">"undefined"</span>) &amp;&amp;
                                $(node, {<span class="string">"fill-opacity"</span>: attrs[<span class="string">"fill-opacity"</span>]});
                        } <span class="keyword">else</span> <span class="keyword">if</span> ((o.type == <span class="string">"circle"</span> || o.type == <span class="string">"ellipse"</span> || Str(value).charAt() != <span class="string">"r"</span>) &amp;&amp; addGradientFill(o, value)) {
                            <span class="keyword">if</span> (<span class="string">"opacity"</span> <span class="keyword">in</span> attrs || <span class="string">"fill-opacity"</span> <span class="keyword">in</span> attrs) {
                                <span class="keyword">var</span> gradient = R._g.doc.getElementById(node.getAttribute(<span class="string">"fill"</span>).replace(<span class="regexp">/^url\(#|\)$/g</span>, E));
                                <span class="keyword">if</span> (gradient) {
                                    <span class="keyword">var</span> stops = gradient.getElementsByTagName(<span class="string">"stop"</span>);
                                    $(stops[stops.length - <span class="number">1</span>], {<span class="string">"stop-opacity"</span>: (<span class="string">"opacity"</span> <span class="keyword">in</span> attrs ? attrs.opacity : <span class="number">1</span>) * (<span class="string">"fill-opacity"</span> <span class="keyword">in</span> attrs ? attrs[<span class="string">"fill-opacity"</span>] : <span class="number">1</span>)});
                                }
                            }
                            attrs.gradient = value;
                            attrs.fill = <span class="string">"none"</span>;
                            <span class="keyword">break</span>;
                        }
                        clr[has](<span class="string">"opacity"</span>) &amp;&amp; $(node, {<span class="string">"fill-opacity"</span>: clr.opacity &gt; <span class="number">1</span> ? clr.opacity / <span class="number">100</span> : clr.opacity});
                    <span class="keyword">case</span> <span class="string">"stroke"</span>:
                        clr = R.getRGB(value);
                        node.setAttribute(att, clr.hex);
                        att == <span class="string">"stroke"</span> &amp;&amp; clr[has](<span class="string">"opacity"</span>) &amp;&amp; $(node, {<span class="string">"stroke-opacity"</span>: clr.opacity &gt; <span class="number">1</span> ? clr.opacity / <span class="number">100</span> : clr.opacity});
                        <span class="keyword">if</span> (att == <span class="string">"stroke"</span> &amp;&amp; o._.arrows) {
                            <span class="string">"startString"</span> <span class="keyword">in</span> o._.arrows &amp;&amp; addArrow(o, o._.arrows.startString);
                            <span class="string">"endString"</span> <span class="keyword">in</span> o._.arrows &amp;&amp; addArrow(o, o._.arrows.endString, <span class="number">1</span>);
                        }
                        <span class="keyword">break</span>;
                    <span class="keyword">case</span> <span class="string">"gradient"</span>:
                        (o.type == <span class="string">"circle"</span> || o.type == <span class="string">"ellipse"</span> || Str(value).charAt() != <span class="string">"r"</span>) &amp;&amp; addGradientFill(o, value);
                        <span class="keyword">break</span>;
                    <span class="keyword">case</span> <span class="string">"opacity"</span>:
                        <span class="keyword">if</span> (attrs.gradient &amp;&amp; !attrs[has](<span class="string">"stroke-opacity"</span>)) {
                            $(node, {<span class="string">"stroke-opacity"</span>: value &gt; <span class="number">1</span> ? value / <span class="number">100</span> : value});
                        }</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>fall</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    <span class="keyword">case</span> <span class="string">"fill-opacity"</span>:
                        <span class="keyword">if</span> (attrs.gradient) {
                            gradient = R._g.doc.getElementById(node.getAttribute(<span class="string">"fill"</span>).replace(<span class="regexp">/^url\(#|\)$/g</span>, E));
                            <span class="keyword">if</span> (gradient) {
                                stops = gradient.getElementsByTagName(<span class="string">"stop"</span>);
                                $(stops[stops.length - <span class="number">1</span>], {<span class="string">"stop-opacity"</span>: value});
                            }
                            <span class="keyword">break</span>;
                        }
                    <span class="keyword">default</span>:
                        att == <span class="string">"font-size"</span> &amp;&amp; (value = toInt(value, <span class="number">10</span>) + <span class="string">"px"</span>);
                        <span class="keyword">var</span> cssrule = att.replace(<span class="regexp">/(\-.)/g</span>, <span class="function"><span class="keyword">function</span> <span class="params">(w)</span> {</span>
                            <span class="keyword">return</span> w.substring(<span class="number">1</span>).toUpperCase();
                        });
                        node.style[cssrule] = value;
                        o._.dirty = <span class="number">1</span>;
                        node.setAttribute(att, value);
                        <span class="keyword">break</span>;
                }
            }
        }

        tuneText(o, params);
        node.style.visibility = vis;
    },
    leading = <span class="number">1.2</span>,
    tuneText = <span class="function"><span class="keyword">function</span> <span class="params">(el, params)</span> {</span>
        <span class="keyword">if</span> (el.type != <span class="string">"text"</span> || !(params[has](<span class="string">"text"</span>) || params[has](<span class="string">"font"</span>) || params[has](<span class="string">"font-size"</span>) || params[has](<span class="string">"x"</span>) || params[has](<span class="string">"y"</span>))) {
            <span class="keyword">return</span>;
        }
        <span class="keyword">var</span> a = el.attrs,
            node = el.node,
            fontSize = node.firstChild ? toInt(R._g.doc.defaultView.getComputedStyle(node.firstChild, E).getPropertyValue(<span class="string">"font-size"</span>), <span class="number">10</span>) : <span class="number">10</span>;

        <span class="keyword">if</span> (params[has](<span class="string">"text"</span>)) {
            a.text = params.text;
            <span class="keyword">while</span> (node.firstChild) {
                node.removeChild(node.firstChild);
            }
            <span class="keyword">var</span> texts = Str(params.text).split(<span class="string">"\n"</span>),
                tspans = [],
                tspan;
            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, ii = texts.length; i &lt; ii; i++) {
                tspan = $(<span class="string">"tspan"</span>);
                i &amp;&amp; $(tspan, {dy: fontSize * leading, x: a.x});
                tspan.appendChild(R._g.doc.createTextNode(texts[i]));
                node.appendChild(tspan);
                tspans[i] = tspan;
            }
        } <span class="keyword">else</span> {
            tspans = node.getElementsByTagName(<span class="string">"tspan"</span>);
            <span class="keyword">for</span> (i = <span class="number">0</span>, ii = tspans.length; i &lt; ii; i++) <span class="keyword">if</span> (i) {
                $(tspans[i], {dy: fontSize * leading, x: a.x});
            } <span class="keyword">else</span> {
                $(tspans[<span class="number">0</span>], {dy: <span class="number">0</span>});
            }
        }
        $(node, {x: a.x, y: a.y});
        el._.dirty = <span class="number">1</span>;
        <span class="keyword">var</span> bb = el._getBBox(),
            dif = a.y - (bb.y + bb.height / <span class="number">2</span>);
        dif &amp;&amp; R.is(dif, <span class="string">"finite"</span>) &amp;&amp; $(tspans[<span class="number">0</span>], {dy: dif});
    },
    Element = <span class="function"><span class="keyword">function</span> <span class="params">(node, svg)</span> {</span>
        <span class="keyword">var</span> X = <span class="number">0</span>,
            Y = <span class="number">0</span>;
        <span class="comment">/*\
         * Element.node
         [ property (object) ]
         **
         * Gives you a reference to the DOM object, so you can assign event handlers or just mess around.
         **
         * Note: Don’t mess with it.
         &gt; Usage
         | // draw a circle at coordinate 10,10 with radius of 10
         | var c = paper.circle(10, 10, 10);
         | c.node.onclick = function () {
         |     c.attr("fill", "red");
         | };
        \*/</span>
        <span class="keyword">this</span>[<span class="number">0</span>] = <span class="keyword">this</span>.node = node;
        <span class="comment">/*\
         * Element.raphael
         [ property (object) ]
         **
         * Internal reference to @Raphael object. In case it is not available.
         &gt; Usage
         | Raphael.el.red = function () {
         |     var hsb = this.paper.raphael.rgb2hsb(this.attr("fill"));
         |     hsb.h = 1;
         |     this.attr({fill: this.paper.raphael.hsb2rgb(hsb).hex});
         | }
        \*/</span>
        node.raphael = <span class="literal">true</span>;
        <span class="comment">/*\
         * Element.id
         [ property (number) ]
         **
         * Unique id of the element. Especially usesful when you want to listen to events of the element, 
         * because all events are fired in format `&lt;module&gt;.&lt;action&gt;.&lt;id&gt;`. Also useful for @Paper.getById method.
        \*/</span>
        <span class="keyword">this</span>.id = R._oid++;
        node.raphaelid = <span class="keyword">this</span>.id;
        <span class="keyword">this</span>.matrix = R.matrix();
        <span class="keyword">this</span>.realPath = <span class="literal">null</span>;
        <span class="comment">/*\
         * Element.paper
         [ property (object) ]
         **
         * Internal reference to “paper” where object drawn. Mainly for use in plugins and element extensions.
         &gt; Usage
         | Raphael.el.cross = function () {
         |     this.attr({fill: "red"});
         |     this.paper.path("M10,10L50,50M50,10L10,50")
         |         .attr({stroke: "red"});
         | }
        \*/</span>
        <span class="keyword">this</span>.paper = svg;
        <span class="keyword">this</span>.attrs = <span class="keyword">this</span>.attrs || {};
        <span class="keyword">this</span>._ = {
            transform: [],
            sx: <span class="number">1</span>,
            sy: <span class="number">1</span>,
            deg: <span class="number">0</span>,
            dx: <span class="number">0</span>,
            dy: <span class="number">0</span>,
            dirty: <span class="number">1</span>
        };
        !svg.bottom &amp;&amp; (svg.bottom = <span class="keyword">this</span>);
        <span class="comment">/*\
         * Element.prev
         [ property (object) ]
         **
         * Reference to the previous element in the hierarchy.
        \*/</span>
        <span class="keyword">this</span>.prev = svg.top;
        svg.top &amp;&amp; (svg.top.next = <span class="keyword">this</span>);
        svg.top = <span class="keyword">this</span>;
        <span class="comment">/*\
         * Element.next
         [ property (object) ]
         **
         * Reference to the next element in the hierarchy.
        \*/</span>
        <span class="keyword">this</span>.next = <span class="literal">null</span>;
    },
    elproto = R.el;

    Element.prototype = elproto;
    elproto.constructor = Element;

    R._engine.path = <span class="function"><span class="keyword">function</span> <span class="params">(pathString, SVG)</span> {</span>
        <span class="keyword">var</span> el = $(<span class="string">"path"</span>);
        SVG.canvas &amp;&amp; SVG.canvas.appendChild(el);
        <span class="keyword">var</span> p = <span class="keyword">new</span> Element(el, SVG);
        p.type = <span class="string">"path"</span>;
        setFillAndStroke(p, {
            fill: <span class="string">"none"</span>,
            stroke: <span class="string">"#000"</span>,
            path: pathString
        });
        <span class="keyword">return</span> p;
    };
    <span class="comment">/*\
     * Element.rotate
     [ method ]
     **
     * Deprecated! Use @Element.transform instead.
     * Adds rotation by given angle around given point to the list of
     * transformations of the element.
     &gt; Parameters
     - deg (number) angle in degrees
     - cx (number) #optional x coordinate of the centre of rotation
     - cy (number) #optional y coordinate of the centre of rotation
     * If cx &amp; cy aren’t specified centre of the shape is used as a point of rotation.
     = (object) @Element
    \*/</span>
    elproto.rotate = <span class="function"><span class="keyword">function</span> <span class="params">(deg, cx, cy)</span> {</span>
        <span class="keyword">if</span> (<span class="keyword">this</span>.removed) {
            <span class="keyword">return</span> <span class="keyword">this</span>;
        }
        deg = Str(deg).split(separator);
        <span class="keyword">if</span> (deg.length - <span class="number">1</span>) {
            cx = toFloat(deg[<span class="number">1</span>]);
            cy = toFloat(deg[<span class="number">2</span>]);
        }
        deg = toFloat(deg[<span class="number">0</span>]);
        (cy == <span class="literal">null</span>) &amp;&amp; (cx = cy);
        <span class="keyword">if</span> (cx == <span class="literal">null</span> || cy == <span class="literal">null</span>) {
            <span class="keyword">var</span> bbox = <span class="keyword">this</span>.getBBox(<span class="number">1</span>);
            cx = bbox.x + bbox.width / <span class="number">2</span>;
            cy = bbox.y + bbox.height / <span class="number">2</span>;
        }
        <span class="keyword">this</span>.transform(<span class="keyword">this</span>._.transform.concat([[<span class="string">"r"</span>, deg, cx, cy]]));
        <span class="keyword">return</span> <span class="keyword">this</span>;
    };
    <span class="comment">/*\
     * Element.scale
     [ method ]
     **
     * Deprecated! Use @Element.transform instead.
     * Adds scale by given amount relative to given point to the list of
     * transformations of the element.
     &gt; Parameters
     - sx (number) horisontal scale amount
     - sy (number) vertical scale amount
     - cx (number) #optional x coordinate of the centre of scale
     - cy (number) #optional y coordinate of the centre of scale
     * If cx &amp; cy aren’t specified centre of the shape is used instead.
     = (object) @Element
    \*/</span>
    elproto.scale = <span class="function"><span class="keyword">function</span> <span class="params">(sx, sy, cx, cy)</span> {</span>
        <span class="keyword">if</span> (<span class="keyword">this</span>.removed) {
            <span class="keyword">return</span> <span class="keyword">this</span>;
        }
        sx = Str(sx).split(separator);
        <span class="keyword">if</span> (sx.length - <span class="number">1</span>) {
            sy = toFloat(sx[<span class="number">1</span>]);
            cx = toFloat(sx[<span class="number">2</span>]);
            cy = toFloat(sx[<span class="number">3</span>]);
        }
        sx = toFloat(sx[<span class="number">0</span>]);
        (sy == <span class="literal">null</span>) &amp;&amp; (sy = sx);
        (cy == <span class="literal">null</span>) &amp;&amp; (cx = cy);
        <span class="keyword">if</span> (cx == <span class="literal">null</span> || cy == <span class="literal">null</span>) {
            <span class="keyword">var</span> bbox = <span class="keyword">this</span>.getBBox(<span class="number">1</span>);
        }
        cx = cx == <span class="literal">null</span> ? bbox.x + bbox.width / <span class="number">2</span> : cx;
        cy = cy == <span class="literal">null</span> ? bbox.y + bbox.height / <span class="number">2</span> : cy;
        <span class="keyword">this</span>.transform(<span class="keyword">this</span>._.transform.concat([[<span class="string">"s"</span>, sx, sy, cx, cy]]));
        <span class="keyword">return</span> <span class="keyword">this</span>;
    };
    <span class="comment">/*\
     * Element.translate
     [ method ]
     **
     * Deprecated! Use @Element.transform instead.
     * Adds translation by given amount to the list of transformations of the element.
     &gt; Parameters
     - dx (number) horisontal shift
     - dy (number) vertical shift
     = (object) @Element
    \*/</span>
    elproto.translate = <span class="function"><span class="keyword">function</span> <span class="params">(dx, dy)</span> {</span>
        <span class="keyword">if</span> (<span class="keyword">this</span>.removed) {
            <span class="keyword">return</span> <span class="keyword">this</span>;
        }
        dx = Str(dx).split(separator);
        <span class="keyword">if</span> (dx.length - <span class="number">1</span>) {
            dy = toFloat(dx[<span class="number">1</span>]);
        }
        dx = toFloat(dx[<span class="number">0</span>]) || <span class="number">0</span>;
        dy = +dy || <span class="number">0</span>;
        <span class="keyword">this</span>.transform(<span class="keyword">this</span>._.transform.concat([[<span class="string">"t"</span>, dx, dy]]));
        <span class="keyword">return</span> <span class="keyword">this</span>;
    };
    <span class="comment">/*\
     * Element.transform
     [ method ]
     **
     * Adds transformation to the element which is separate to other attributes,
     * i.e. translation doesn’t change `x` or `y` of the rectange. The format
     * of transformation string is similar to the path string syntax:
     | "t100,100r30,100,100s2,2,100,100r45s1.5"
     * Each letter is a command. There are four commands: `t` is for translate, `r` is for rotate, `s` is for
     * scale and `m` is for matrix.
     *
     * There are also alternative “absolute” translation, rotation and scale: `T`, `R` and `S`. They will not take previous transformation into account. For example, `...T100,0` will always move element 100 px horisontally, while `...t100,0` could move it vertically if there is `r90` before. Just compare results of `r90t100,0` and `r90T100,0`.
     *
     * So, the example line above could be read like “translate by 100, 100; rotate 30° around 100, 100; scale twice around 100, 100;
     * rotate 45° around centre; scale 1.5 times relative to centre”. As you can see rotate and scale commands have origin
     * coordinates as optional parameters, the default is the centre point of the element.
     * Matrix accepts six parameters.
     &gt; Usage
     | var el = paper.rect(10, 20, 300, 200);
     | // translate 100, 100, rotate 45°, translate -100, 0
     | el.transform("t100,100r45t-100,0");
     | // if you want you can append or prepend transformations
     | el.transform("...t50,50");
     | el.transform("s2...");
     | // or even wrap
     | el.transform("t50,50...t-50-50");
     | // to reset transformation call method with empty string
     | el.transform("");
     | // to get current value call it without parameters
     | console.log(el.transform());
     &gt; Parameters
     - tstr (string) #optional transformation string
     * If tstr isn’t specified
     = (string) current transformation string
     * else
     = (object) @Element
    \*/</span>
    elproto.transform = <span class="function"><span class="keyword">function</span> <span class="params">(tstr)</span> {</span>
        <span class="keyword">var</span> _ = <span class="keyword">this</span>._;
        <span class="keyword">if</span> (tstr == <span class="literal">null</span>) {
            <span class="keyword">return</span> _.transform;
        }
        R._extractTransform(<span class="keyword">this</span>, tstr);

        <span class="keyword">this</span>.clip &amp;&amp; $(<span class="keyword">this</span>.clip, {transform: <span class="keyword">this</span>.matrix.invert()});
        <span class="keyword">this</span>.pattern &amp;&amp; updatePosition(<span class="keyword">this</span>);
        <span class="keyword">this</span>.node &amp;&amp; $(<span class="keyword">this</span>.node, {transform: <span class="keyword">this</span>.matrix});
    
        <span class="keyword">if</span> (_.sx != <span class="number">1</span> || _.sy != <span class="number">1</span>) {
            <span class="keyword">var</span> sw = <span class="keyword">this</span>.attrs[has](<span class="string">"stroke-width"</span>) ? <span class="keyword">this</span>.attrs[<span class="string">"stroke-width"</span>] : <span class="number">1</span>;
            <span class="keyword">this</span>.attr({<span class="string">"stroke-width"</span>: sw});
        }

        <span class="keyword">return</span> <span class="keyword">this</span>;
    };
    <span class="comment">/*\
     * Element.hide
     [ method ]
     **
     * Makes element invisible. See @Element.show.
     = (object) @Element
    \*/</span>
    elproto.hide = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        !<span class="keyword">this</span>.removed &amp;&amp; <span class="keyword">this</span>.paper.safari(<span class="keyword">this</span>.node.style.display = <span class="string">"none"</span>);
        <span class="keyword">return</span> <span class="keyword">this</span>;
    };
    <span class="comment">/*\
     * Element.show
     [ method ]
     **
     * Makes element visible. See @Element.hide.
     = (object) @Element
    \*/</span>
    elproto.show = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        !<span class="keyword">this</span>.removed &amp;&amp; <span class="keyword">this</span>.paper.safari(<span class="keyword">this</span>.node.style.display = <span class="string">""</span>);
        <span class="keyword">return</span> <span class="keyword">this</span>;
    };
    <span class="comment">/*\
     * Element.remove
     [ method ]
     **
     * Removes element from the paper.
    \*/</span>
    elproto.remove = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">if</span> (<span class="keyword">this</span>.removed || !<span class="keyword">this</span>.node.parentNode) {
            <span class="keyword">return</span>;
        }
        <span class="keyword">var</span> paper = <span class="keyword">this</span>.paper;
        paper.__set__ &amp;&amp; paper.__set__.exclude(<span class="keyword">this</span>);
        eve.unbind(<span class="string">"raphael.*.*."</span> + <span class="keyword">this</span>.id);
        <span class="keyword">if</span> (<span class="keyword">this</span>.gradient) {
            paper.defs.removeChild(<span class="keyword">this</span>.gradient);
        }
        R._tear(<span class="keyword">this</span>, paper);
        <span class="keyword">if</span> (<span class="keyword">this</span>.node.parentNode.tagName.toLowerCase() == <span class="string">"a"</span>) {
            <span class="keyword">this</span>.node.parentNode.parentNode.removeChild(<span class="keyword">this</span>.node.parentNode);
        } <span class="keyword">else</span> {
            <span class="keyword">this</span>.node.parentNode.removeChild(<span class="keyword">this</span>.node);
        }
        <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> <span class="keyword">this</span>) {
            <span class="keyword">this</span>[i] = <span class="keyword">typeof</span> <span class="keyword">this</span>[i] == <span class="string">"function"</span> ? R._removedFactory(i) : <span class="literal">null</span>;
        }
        <span class="keyword">this</span>.removed = <span class="literal">true</span>;
    };
    elproto._getBBox = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">if</span> (<span class="keyword">this</span>.node.style.display == <span class="string">"none"</span>) {
            <span class="keyword">this</span>.show();
            <span class="keyword">var</span> hide = <span class="literal">true</span>;
        }
        <span class="keyword">var</span> bbox = {};
        <span class="keyword">try</span> {
            bbox = <span class="keyword">this</span>.node.getBBox();
        } <span class="keyword">catch</span>(e) {</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>Firefox 3.0.x plays badly here</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        } <span class="keyword">finally</span> {
            bbox = bbox || {};
        }
        hide &amp;&amp; <span class="keyword">this</span>.hide();
        <span class="keyword">return</span> bbox;
    };
    <span class="comment">/*\
     * Element.attr
     [ method ]
     **
     * Sets the attributes of the element.
     &gt; Parameters
     - attrName (string) attribute’s name
     - value (string) value
     * or
     - params (object) object of name/value pairs
     * or
     - attrName (string) attribute’s name
     * or
     - attrNames (array) in this case method returns array of current values for given attribute names
     = (object) @Element if attrsName &amp; value or params are passed in.
     = (...) value of the attribute if only attrsName is passed in.
     = (array) array of values of the attribute if attrsNames is passed in.
     = (object) object of attributes if nothing is passed in.
     &gt; Possible parameters
     # &lt;p&gt;Please refer to the &lt;a href="http://www.w3.org/TR/SVG/" title="The W3C Recommendation for the SVG language describes these properties in detail."&gt;SVG specification&lt;/a&gt; for an explanation of these parameters.&lt;/p&gt;
     o arrow-end (string) arrowhead on the end of the path. The format for string is `&lt;type&gt;[-&lt;width&gt;[-&lt;length&gt;]]`. Possible types: `classic`, `block`, `open`, `oval`, `diamond`, `none`, width: `wide`, `narrow`, `medium`, length: `long`, `short`, `midium`.
     o clip-rect (string) comma or space separated values: x, y, width and height
     o cursor (string) CSS type of the cursor
     o cx (number) the x-axis coordinate of the center of the circle, or ellipse
     o cy (number) the y-axis coordinate of the center of the circle, or ellipse
     o fill (string) colour, gradient or image
     o fill-opacity (number)
     o font (string)
     o font-family (string)
     o font-size (number) font size in pixels
     o font-weight (string)
     o height (number)
     o href (string) URL, if specified element behaves as hyperlink
     o opacity (number)
     o path (string) SVG path string format
     o r (number) radius of the circle, ellipse or rounded corner on the rect
     o rx (number) horisontal radius of the ellipse
     o ry (number) vertical radius of the ellipse
     o src (string) image URL, only works for @Element.image element
     o stroke (string) stroke colour
     o stroke-dasharray (string) [“”, “`-`”, “`.`”, “`-.`”, “`-..`”, “`. `”, “`- `”, “`--`”, “`- .`”, “`--.`”, “`--..`”]
     o stroke-linecap (string) [“`butt`”, “`square`”, “`round`”]
     o stroke-linejoin (string) [“`bevel`”, “`round`”, “`miter`”]
     o stroke-miterlimit (number)
     o stroke-opacity (number)
     o stroke-width (number) stroke width in pixels, default is '1'
     o target (string) used with href
     o text (string) contents of the text element. Use `\n` for multiline text
     o text-anchor (string) [“`start`”, “`middle`”, “`end`”], default is “`middle`”
     o title (string) will create tooltip with a given text
     o transform (string) see @Element.transform
     o width (number)
     o x (number)
     o y (number)
     &gt; Gradients
     * Linear gradient format: “`‹angle›-‹colour›[-‹colour›[:‹offset›]]*-‹colour›`”, example: “`90-#fff-#000`” – 90°
     * gradient from white to black or “`0-#fff-#f00:20-#000`” – 0° gradient from white via red (at 20%) to black.
     *
     * radial gradient: “`r[(‹fx›, ‹fy›)]‹colour›[-‹colour›[:‹offset›]]*-‹colour›`”, example: “`r#fff-#000`” –
     * gradient from white to black or “`r(0.25, 0.75)#fff-#000`” – gradient from white to black with focus point
     * at 0.25, 0.75. Focus point coordinates are in 0..1 range. Radial gradients can only be applied to circles and ellipses.
     &gt; Path String
     # &lt;p&gt;Please refer to &lt;a href="http://www.w3.org/TR/SVG/paths.html#PathData" title="Details of a path’s data attribute’s format are described in the SVG specification."&gt;SVG documentation regarding path string&lt;/a&gt;. Raphaël fully supports it.&lt;/p&gt;
     &gt; Colour Parsing
     # &lt;ul&gt;
     #     &lt;li&gt;Colour name (“&lt;code&gt;red&lt;/code&gt;”, “&lt;code&gt;green&lt;/code&gt;”, “&lt;code&gt;cornflowerblue&lt;/code&gt;”, etc)&lt;/li&gt;
     #     &lt;li&gt;#••• — shortened HTML colour: (“&lt;code&gt;#000&lt;/code&gt;”, “&lt;code&gt;#fc0&lt;/code&gt;”, etc)&lt;/li&gt;
     #     &lt;li&gt;#•••••• — full length HTML colour: (“&lt;code&gt;#000000&lt;/code&gt;”, “&lt;code&gt;#bd2300&lt;/code&gt;”)&lt;/li&gt;
     #     &lt;li&gt;rgb(•••, •••, •••) — red, green and blue channels’ values: (“&lt;code&gt;rgb(200,&amp;nbsp;100,&amp;nbsp;0)&lt;/code&gt;”)&lt;/li&gt;
     #     &lt;li&gt;rgb(•••%, •••%, •••%) — same as above, but in %: (“&lt;code&gt;rgb(100%,&amp;nbsp;175%,&amp;nbsp;0%)&lt;/code&gt;”)&lt;/li&gt;
     #     &lt;li&gt;rgba(•••, •••, •••, •••) — red, green and blue channels’ values: (“&lt;code&gt;rgba(200,&amp;nbsp;100,&amp;nbsp;0, .5)&lt;/code&gt;”)&lt;/li&gt;
     #     &lt;li&gt;rgba(•••%, •••%, •••%, •••%) — same as above, but in %: (“&lt;code&gt;rgba(100%,&amp;nbsp;175%,&amp;nbsp;0%, 50%)&lt;/code&gt;”)&lt;/li&gt;
     #     &lt;li&gt;hsb(•••, •••, •••) — hue, saturation and brightness values: (“&lt;code&gt;hsb(0.5,&amp;nbsp;0.25,&amp;nbsp;1)&lt;/code&gt;”)&lt;/li&gt;
     #     &lt;li&gt;hsb(•••%, •••%, •••%) — same as above, but in %&lt;/li&gt;
     #     &lt;li&gt;hsba(•••, •••, •••, •••) — same as above, but with opacity&lt;/li&gt;
     #     &lt;li&gt;hsl(•••, •••, •••) — almost the same as hsb, see &lt;a href="http://en.wikipedia.org/wiki/HSL_and_HSV" title="HSL and HSV - Wikipedia, the free encyclopedia"&gt;Wikipedia page&lt;/a&gt;&lt;/li&gt;
     #     &lt;li&gt;hsl(•••%, •••%, •••%) — same as above, but in %&lt;/li&gt;
     #     &lt;li&gt;hsla(•••, •••, •••, •••) — same as above, but with opacity&lt;/li&gt;
     #     &lt;li&gt;Optionally for hsb and hsl you could specify hue as a degree: “&lt;code&gt;hsl(240deg,&amp;nbsp;1,&amp;nbsp;.5)&lt;/code&gt;” or, if you want to go fancy, “&lt;code&gt;hsl(240°,&amp;nbsp;1,&amp;nbsp;.5)&lt;/code&gt;”&lt;/li&gt;
     # &lt;/ul&gt;
    \*/</span>
    elproto.attr = <span class="function"><span class="keyword">function</span> <span class="params">(name, value)</span> {</span>
        <span class="keyword">if</span> (<span class="keyword">this</span>.removed) {
            <span class="keyword">return</span> <span class="keyword">this</span>;
        }
        <span class="keyword">if</span> (name == <span class="literal">null</span>) {
            <span class="keyword">var</span> res = {};
            <span class="keyword">for</span> (<span class="keyword">var</span> a <span class="keyword">in</span> <span class="keyword">this</span>.attrs) <span class="keyword">if</span> (<span class="keyword">this</span>.attrs[has](a)) {
                res[a] = <span class="keyword">this</span>.attrs[a];
            }
            res.gradient &amp;&amp; res.fill == <span class="string">"none"</span> &amp;&amp; (res.fill = res.gradient) &amp;&amp; <span class="keyword">delete</span> res.gradient;
            res.transform = <span class="keyword">this</span>._.transform;
            <span class="keyword">return</span> res;
        }
        <span class="keyword">if</span> (value == <span class="literal">null</span> &amp;&amp; R.is(name, <span class="string">"string"</span>)) {
            <span class="keyword">if</span> (name == <span class="string">"fill"</span> &amp;&amp; <span class="keyword">this</span>.attrs.fill == <span class="string">"none"</span> &amp;&amp; <span class="keyword">this</span>.attrs.gradient) {
                <span class="keyword">return</span> <span class="keyword">this</span>.attrs.gradient;
            }
            <span class="keyword">if</span> (name == <span class="string">"transform"</span>) {
                <span class="keyword">return</span> <span class="keyword">this</span>._.transform;
            }
            <span class="keyword">var</span> names = name.split(separator),
                out = {};
            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, ii = names.length; i &lt; ii; i++) {
                name = names[i];
                <span class="keyword">if</span> (name <span class="keyword">in</span> <span class="keyword">this</span>.attrs) {
                    out[name] = <span class="keyword">this</span>.attrs[name];
                } <span class="keyword">else</span> <span class="keyword">if</span> (R.is(<span class="keyword">this</span>.paper.customAttributes[name], <span class="string">"function"</span>)) {
                    out[name] = <span class="keyword">this</span>.paper.customAttributes[name].def;
                } <span class="keyword">else</span> {
                    out[name] = R._availableAttrs[name];
                }
            }
            <span class="keyword">return</span> ii - <span class="number">1</span> ? out : out[names[<span class="number">0</span>]];
        }
        <span class="keyword">if</span> (value == <span class="literal">null</span> &amp;&amp; R.is(name, <span class="string">"array"</span>)) {
            out = {};
            <span class="keyword">for</span> (i = <span class="number">0</span>, ii = name.length; i &lt; ii; i++) {
                out[name[i]] = <span class="keyword">this</span>.attr(name[i]);
            }
            <span class="keyword">return</span> out;
        }
        <span class="keyword">if</span> (value != <span class="literal">null</span>) {
            <span class="keyword">var</span> params = {};
            params[name] = value;
        } <span class="keyword">else</span> <span class="keyword">if</span> (name != <span class="literal">null</span> &amp;&amp; R.is(name, <span class="string">"object"</span>)) {
            params = name;
        }
        <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> params) {
            eve(<span class="string">"raphael.attr."</span> + key + <span class="string">"."</span> + <span class="keyword">this</span>.id, <span class="keyword">this</span>, params[key]);
        }
        <span class="keyword">for</span> (key <span class="keyword">in</span> <span class="keyword">this</span>.paper.customAttributes) <span class="keyword">if</span> (<span class="keyword">this</span>.paper.customAttributes[has](key) &amp;&amp; params[has](key) &amp;&amp; R.is(<span class="keyword">this</span>.paper.customAttributes[key], <span class="string">"function"</span>)) {
            <span class="keyword">var</span> par = <span class="keyword">this</span>.paper.customAttributes[key].apply(<span class="keyword">this</span>, [].concat(params[key]));
            <span class="keyword">this</span>.attrs[key] = params[key];
            <span class="keyword">for</span> (<span class="keyword">var</span> subkey <span class="keyword">in</span> par) <span class="keyword">if</span> (par[has](subkey)) {
                params[subkey] = par[subkey];
            }
        }
        setFillAndStroke(<span class="keyword">this</span>, params);
        <span class="keyword">return</span> <span class="keyword">this</span>;
    };
    <span class="comment">/*\
     * Element.toFront
     [ method ]
     **
     * Moves the element so it is the closest to the viewer’s eyes, on top of other elements.
     = (object) @Element
    \*/</span>
    elproto.toFront = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">if</span> (<span class="keyword">this</span>.removed) {
            <span class="keyword">return</span> <span class="keyword">this</span>;
        }
        <span class="keyword">if</span> (<span class="keyword">this</span>.node.parentNode.tagName.toLowerCase() == <span class="string">"a"</span>) {
            <span class="keyword">this</span>.node.parentNode.parentNode.appendChild(<span class="keyword">this</span>.node.parentNode);
        } <span class="keyword">else</span> {
            <span class="keyword">this</span>.node.parentNode.appendChild(<span class="keyword">this</span>.node);
        }
        <span class="keyword">var</span> svg = <span class="keyword">this</span>.paper;
        svg.top != <span class="keyword">this</span> &amp;&amp; R._tofront(<span class="keyword">this</span>, svg);
        <span class="keyword">return</span> <span class="keyword">this</span>;
    };
    <span class="comment">/*\
     * Element.toBack
     [ method ]
     **
     * Moves the element so it is the furthest from the viewer’s eyes, behind other elements.
     = (object) @Element
    \*/</span>
    elproto.toBack = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">if</span> (<span class="keyword">this</span>.removed) {
            <span class="keyword">return</span> <span class="keyword">this</span>;
        }
        <span class="keyword">var</span> parent = <span class="keyword">this</span>.node.parentNode;
        <span class="keyword">if</span> (parent.tagName.toLowerCase() == <span class="string">"a"</span>) {
            parent.parentNode.insertBefore(<span class="keyword">this</span>.node.parentNode, <span class="keyword">this</span>.node.parentNode.parentNode.firstChild); 
        } <span class="keyword">else</span> <span class="keyword">if</span> (parent.firstChild != <span class="keyword">this</span>.node) {
            parent.insertBefore(<span class="keyword">this</span>.node, <span class="keyword">this</span>.node.parentNode.firstChild);
        }
        R._toback(<span class="keyword">this</span>, <span class="keyword">this</span>.paper);
        <span class="keyword">var</span> svg = <span class="keyword">this</span>.paper;
        <span class="keyword">return</span> <span class="keyword">this</span>;
    };
    <span class="comment">/*\
     * Element.insertAfter
     [ method ]
     **
     * Inserts current object after the given one.
     = (object) @Element
    \*/</span>
    elproto.insertAfter = <span class="function"><span class="keyword">function</span> <span class="params">(element)</span> {</span>
        <span class="keyword">if</span> (<span class="keyword">this</span>.removed) {
            <span class="keyword">return</span> <span class="keyword">this</span>;
        }
        <span class="keyword">var</span> node = element.node || element[element.length - <span class="number">1</span>].node;
        <span class="keyword">if</span> (node.nextSibling) {
            node.parentNode.insertBefore(<span class="keyword">this</span>.node, node.nextSibling);
        } <span class="keyword">else</span> {
            node.parentNode.appendChild(<span class="keyword">this</span>.node);
        }
        R._insertafter(<span class="keyword">this</span>, element, <span class="keyword">this</span>.paper);
        <span class="keyword">return</span> <span class="keyword">this</span>;
    };
    <span class="comment">/*\
     * Element.insertBefore
     [ method ]
     **
     * Inserts current object before the given one.
     = (object) @Element
    \*/</span>
    elproto.insertBefore = <span class="function"><span class="keyword">function</span> <span class="params">(element)</span> {</span>
        <span class="keyword">if</span> (<span class="keyword">this</span>.removed) {
            <span class="keyword">return</span> <span class="keyword">this</span>;
        }
        <span class="keyword">var</span> node = element.node || element[<span class="number">0</span>].node;
        node.parentNode.insertBefore(<span class="keyword">this</span>.node, node);
        R._insertbefore(<span class="keyword">this</span>, element, <span class="keyword">this</span>.paper);
        <span class="keyword">return</span> <span class="keyword">this</span>;
    };
    elproto.blur = <span class="function"><span class="keyword">function</span> <span class="params">(size)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>Experimental. No Safari support. Use it on your own risk.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> t = <span class="keyword">this</span>;
        <span class="keyword">if</span> (+size !== <span class="number">0</span>) {
            <span class="keyword">var</span> fltr = $(<span class="string">"filter"</span>),
                blur = $(<span class="string">"feGaussianBlur"</span>);
            t.attrs.blur = size;
            fltr.id = R.createUUID();
            $(blur, {stdDeviation: +size || <span class="number">1.5</span>});
            fltr.appendChild(blur);
            t.paper.defs.appendChild(fltr);
            t._blur = fltr;
            $(t.node, {filter: <span class="string">"url(#"</span> + fltr.id + <span class="string">")"</span>});
        } <span class="keyword">else</span> {
            <span class="keyword">if</span> (t._blur) {
                t._blur.parentNode.removeChild(t._blur);
                <span class="keyword">delete</span> t._blur;
                <span class="keyword">delete</span> t.attrs.blur;
            }
            t.node.removeAttribute(<span class="string">"filter"</span>);
        }
        <span class="keyword">return</span> t;
    };
    R._engine.circle = <span class="function"><span class="keyword">function</span> <span class="params">(svg, x, y, r)</span> {</span>
        <span class="keyword">var</span> el = $(<span class="string">"circle"</span>);
        svg.canvas &amp;&amp; svg.canvas.appendChild(el);
        <span class="keyword">var</span> res = <span class="keyword">new</span> Element(el, svg);
        res.attrs = {cx: x, cy: y, r: r, fill: <span class="string">"none"</span>, stroke: <span class="string">"#000"</span>};
        res.type = <span class="string">"circle"</span>;
        $(el, res.attrs);
        <span class="keyword">return</span> res;
    };
    R._engine.rect = <span class="function"><span class="keyword">function</span> <span class="params">(svg, x, y, w, h, r)</span> {</span>
        <span class="keyword">var</span> el = $(<span class="string">"rect"</span>);
        svg.canvas &amp;&amp; svg.canvas.appendChild(el);
        <span class="keyword">var</span> res = <span class="keyword">new</span> Element(el, svg);
        res.attrs = {x: x, y: y, width: w, height: h, r: r || <span class="number">0</span>, rx: r || <span class="number">0</span>, ry: r || <span class="number">0</span>, fill: <span class="string">"none"</span>, stroke: <span class="string">"#000"</span>};
        res.type = <span class="string">"rect"</span>;
        $(el, res.attrs);
        <span class="keyword">return</span> res;
    };
    R._engine.ellipse = <span class="function"><span class="keyword">function</span> <span class="params">(svg, x, y, rx, ry)</span> {</span>
        <span class="keyword">var</span> el = $(<span class="string">"ellipse"</span>);
        svg.canvas &amp;&amp; svg.canvas.appendChild(el);
        <span class="keyword">var</span> res = <span class="keyword">new</span> Element(el, svg);
        res.attrs = {cx: x, cy: y, rx: rx, ry: ry, fill: <span class="string">"none"</span>, stroke: <span class="string">"#000"</span>};
        res.type = <span class="string">"ellipse"</span>;
        $(el, res.attrs);
        <span class="keyword">return</span> res;
    };
    R._engine.image = <span class="function"><span class="keyword">function</span> <span class="params">(svg, src, x, y, w, h)</span> {</span>
        <span class="keyword">var</span> el = $(<span class="string">"image"</span>);
        $(el, {x: x, y: y, width: w, height: h, preserveAspectRatio: <span class="string">"none"</span>});
        el.setAttributeNS(xlink, <span class="string">"href"</span>, src);
        svg.canvas &amp;&amp; svg.canvas.appendChild(el);
        <span class="keyword">var</span> res = <span class="keyword">new</span> Element(el, svg);
        res.attrs = {x: x, y: y, width: w, height: h, src: src};
        res.type = <span class="string">"image"</span>;
        <span class="keyword">return</span> res;
    };
    R._engine.text = <span class="function"><span class="keyword">function</span> <span class="params">(svg, x, y, text)</span> {</span>
        <span class="keyword">var</span> el = $(<span class="string">"text"</span>);
        svg.canvas &amp;&amp; svg.canvas.appendChild(el);
        <span class="keyword">var</span> res = <span class="keyword">new</span> Element(el, svg);
        res.attrs = {
            x: x,
            y: y,
            <span class="string">"text-anchor"</span>: <span class="string">"middle"</span>,
            text: text,
            font: R._availableAttrs.font,
            stroke: <span class="string">"none"</span>,
            fill: <span class="string">"#000"</span>
        };
        res.type = <span class="string">"text"</span>;
        setFillAndStroke(res, res.attrs);
        <span class="keyword">return</span> res;
    };
    R._engine.setSize = <span class="function"><span class="keyword">function</span> <span class="params">(width, height)</span> {</span>
        <span class="keyword">this</span>.width = width || <span class="keyword">this</span>.width;
        <span class="keyword">this</span>.height = height || <span class="keyword">this</span>.height;
        <span class="keyword">this</span>.canvas.setAttribute(<span class="string">"width"</span>, <span class="keyword">this</span>.width);
        <span class="keyword">this</span>.canvas.setAttribute(<span class="string">"height"</span>, <span class="keyword">this</span>.height);
        <span class="keyword">if</span> (<span class="keyword">this</span>._viewBox) {
            <span class="keyword">this</span>.setViewBox.apply(<span class="keyword">this</span>, <span class="keyword">this</span>._viewBox);
        }
        <span class="keyword">return</span> <span class="keyword">this</span>;
    };
    R._engine.create = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">var</span> con = R._getContainer.apply(<span class="number">0</span>, arguments),
            container = con &amp;&amp; con.container,
            x = con.x,
            y = con.y,
            width = con.width,
            height = con.height;
        <span class="keyword">if</span> (!container) {
            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"SVG container not found."</span>);
        }
        <span class="keyword">var</span> cnvs = $(<span class="string">"svg"</span>),
            css = <span class="string">"overflow:hidden;"</span>,
            isFloating;
        x = x || <span class="number">0</span>;
        y = y || <span class="number">0</span>;
        width = width || <span class="number">512</span>;
        height = height || <span class="number">342</span>;
        $(cnvs, {
            height: height,
            version: <span class="number">1.1</span>,
            width: width,
            xmlns: <span class="string">"http://www.w3.org/2000/svg"</span>
        });
        <span class="keyword">if</span> (container == <span class="number">1</span>) {
            cnvs.style.cssText = css + <span class="string">"position:absolute;left:"</span> + x + <span class="string">"px;top:"</span> + y + <span class="string">"px"</span>;
            R._g.doc.body.appendChild(cnvs);
            isFloating = <span class="number">1</span>;
        } <span class="keyword">else</span> {
            cnvs.style.cssText = css + <span class="string">"position:relative"</span>;
            <span class="keyword">if</span> (container.firstChild) {
                container.insertBefore(cnvs, container.firstChild);
            } <span class="keyword">else</span> {
                container.appendChild(cnvs);
            }
        }
        container = <span class="keyword">new</span> R._Paper;
        container.width = width;
        container.height = height;
        container.canvas = cnvs;
        container.clear();
        container._left = container._top = <span class="number">0</span>;
        isFloating &amp;&amp; (container.renderfix = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>});
        container.renderfix();
        <span class="keyword">return</span> container;
    };
    R._engine.setViewBox = <span class="function"><span class="keyword">function</span> <span class="params">(x, y, w, h, fit)</span> {</span>
        eve(<span class="string">"raphael.setViewBox"</span>, <span class="keyword">this</span>, <span class="keyword">this</span>._viewBox, [x, y, w, h, fit]);
        <span class="keyword">var</span> size = mmax(w / <span class="keyword">this</span>.width, h / <span class="keyword">this</span>.height),
            top = <span class="keyword">this</span>.top,
            aspectRatio = fit ? <span class="string">"meet"</span> : <span class="string">"xMinYMin"</span>,
            vb,
            sw;
        <span class="keyword">if</span> (x == <span class="literal">null</span>) {
            <span class="keyword">if</span> (<span class="keyword">this</span>._vbSize) {
                size = <span class="number">1</span>;
            }
            <span class="keyword">delete</span> <span class="keyword">this</span>._vbSize;
            vb = <span class="string">"0 0 "</span> + <span class="keyword">this</span>.width + S + <span class="keyword">this</span>.height;
        } <span class="keyword">else</span> {
            <span class="keyword">this</span>._vbSize = size;
            vb = x + S + y + S + w + S + h;
        }
        $(<span class="keyword">this</span>.canvas, {
            viewBox: vb,
            preserveAspectRatio: aspectRatio
        });
        <span class="keyword">while</span> (size &amp;&amp; top) {
            sw = <span class="string">"stroke-width"</span> <span class="keyword">in</span> top.attrs ? top.attrs[<span class="string">"stroke-width"</span>] : <span class="number">1</span>;
            top.attr({<span class="string">"stroke-width"</span>: sw});
            top._.dirty = <span class="number">1</span>;
            top._.dirtyT = <span class="number">1</span>;
            top = top.prev;
        }
        <span class="keyword">this</span>._viewBox = [x, y, w, h, !!fit];
        <span class="keyword">return</span> <span class="keyword">this</span>;
    };
    <span class="comment">/*\
     * Paper.renderfix
     [ method ]
     **
     * Fixes the issue of Firefox and IE9 regarding subpixel rendering. If paper is dependant
     * on other elements after reflow it could shift half pixel which cause for lines to lost their crispness.
     * This method fixes the issue.
     **
       Special thanks to Mariusz Nowak (http://www.medikoo.com/) for this method.
    \*/</span>
    R.prototype.renderfix = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">var</span> cnvs = <span class="keyword">this</span>.canvas,
            s = cnvs.style,
            pos;
        <span class="keyword">try</span> {
            pos = cnvs.getScreenCTM() || cnvs.createSVGMatrix();
        } <span class="keyword">catch</span> (e) {
            pos = cnvs.createSVGMatrix();
        }
        <span class="keyword">var</span> left = -pos.e % <span class="number">1</span>,
            top = -pos.f % <span class="number">1</span>;
        <span class="keyword">if</span> (left || top) {
            <span class="keyword">if</span> (left) {
                <span class="keyword">this</span>._left = (<span class="keyword">this</span>._left + left) % <span class="number">1</span>;
                s.left = <span class="keyword">this</span>._left + <span class="string">"px"</span>;
            }
            <span class="keyword">if</span> (top) {
                <span class="keyword">this</span>._top = (<span class="keyword">this</span>._top + top) % <span class="number">1</span>;
                s.top = <span class="keyword">this</span>._top + <span class="string">"px"</span>;
            }
        }
    };
    <span class="comment">/*\
     * Paper.clear
     [ method ]
     **
     * Clears the paper, i.e. removes all the elements.
    \*/</span>
    R.prototype.clear = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        R.eve(<span class="string">"raphael.clear"</span>, <span class="keyword">this</span>);
        <span class="keyword">var</span> c = <span class="keyword">this</span>.canvas;
        <span class="keyword">while</span> (c.firstChild) {
            c.removeChild(c.firstChild);
        }
        <span class="keyword">this</span>.bottom = <span class="keyword">this</span>.top = <span class="literal">null</span>;
        (<span class="keyword">this</span>.desc = $(<span class="string">"desc"</span>)).appendChild(R._g.doc.createTextNode(<span class="string">"Created with Rapha\xebl "</span> + R.version));
        c.appendChild(<span class="keyword">this</span>.desc);
        c.appendChild(<span class="keyword">this</span>.defs = $(<span class="string">"defs"</span>));
    };
    <span class="comment">/*\
     * Paper.remove
     [ method ]
     **
     * Removes the paper from the DOM.
    \*/</span>
    R.prototype.remove = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        eve(<span class="string">"raphael.remove"</span>, <span class="keyword">this</span>);
        <span class="keyword">this</span>.canvas.parentNode &amp;&amp; <span class="keyword">this</span>.canvas.parentNode.removeChild(<span class="keyword">this</span>.canvas);
        <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> <span class="keyword">this</span>) {
            <span class="keyword">this</span>[i] = <span class="keyword">typeof</span> <span class="keyword">this</span>[i] == <span class="string">"function"</span> ? R._removedFactory(i) : <span class="literal">null</span>;
        }
    };
    <span class="keyword">var</span> setproto = R.st;
    <span class="keyword">for</span> (<span class="keyword">var</span> method <span class="keyword">in</span> elproto) <span class="keyword">if</span> (elproto[has](method) &amp;&amp; !setproto[has](method)) {
        setproto[method] = (<span class="function"><span class="keyword">function</span> <span class="params">(methodname)</span> {</span>
            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
                <span class="keyword">var</span> arg = arguments;
                <span class="keyword">return</span> <span class="keyword">this</span>.forEach(<span class="function"><span class="keyword">function</span> <span class="params">(el)</span> {</span>
                    el[methodname].apply(el, arg);
                });
            };
        })(method);
    }
})();</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>┌─────────────────────────────────────────────────────────────────────┐ \
│ Raphaël - JavaScript Vector Library                                 │ \
├─────────────────────────────────────────────────────────────────────┤ \
│ VML Module                                                          │ \
├─────────────────────────────────────────────────────────────────────┤ \
│ Copyright (c) 2008-2011 Dmitry Baranovskiy (<a href="http://raphaeljs.com">http://raphaeljs.com</a>)   │ \
│ Copyright (c) 2008-2011 Sencha Labs (<a href="http://sencha.com">http://sencha.com</a>)             │ \
│ Licensed under the MIT (<a href="http://raphaeljs.com/license.html">http://raphaeljs.com/license.html</a>) license. │ \
└─────────────────────────────────────────────────────────────────────┘ \</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>(<span class="keyword">function</span>(){
    <span class="keyword">if</span> (!R.vml) {
        <span class="keyword">return</span>;
    }
    <span class="keyword">var</span> has = <span class="string">"hasOwnProperty"</span>,
        Str = String,
        toFloat = parseFloat,
        math = Math,
        round = math.round,
        mmax = math.max,
        mmin = math.min,
        abs = math.abs,
        fillString = <span class="string">"fill"</span>,
        separator = <span class="regexp">/[, ]+/</span>,
        eve = R.eve,
        ms = <span class="string">" progid:DXImageTransform.Microsoft"</span>,
        S = <span class="string">" "</span>,
        E = <span class="string">""</span>,
        map = {M: <span class="string">"m"</span>, L: <span class="string">"l"</span>, C: <span class="string">"c"</span>, Z: <span class="string">"x"</span>, m: <span class="string">"t"</span>, l: <span class="string">"r"</span>, c: <span class="string">"v"</span>, z: <span class="string">"x"</span>},
        bites = <span class="regexp">/([clmz]),?([^clmz]*)/gi</span>,
        blurregexp = <span class="regexp">/ progid:\S+Blur\([^\)]+\)/g</span>,
        val = <span class="regexp">/-?[^,\s-]+/g</span>,
        cssDot = <span class="string">"position:absolute;left:0;top:0;width:1px;height:1px"</span>,
        zoom = <span class="number">21600</span>,
        pathTypes = {path: <span class="number">1</span>, rect: <span class="number">1</span>, image: <span class="number">1</span>},
        ovalTypes = {circle: <span class="number">1</span>, ellipse: <span class="number">1</span>},
        path2vml = <span class="function"><span class="keyword">function</span> <span class="params">(path)</span> {</span>
            <span class="keyword">var</span> total =  <span class="regexp">/[ahqstv]/ig</span>,
                command = R._pathToAbsolute;
            Str(path).match(total) &amp;&amp; (command = R._path2curve);
            total = <span class="regexp">/[clmz]/g</span>;
            <span class="keyword">if</span> (command == R._pathToAbsolute &amp;&amp; !Str(path).match(total)) {
                <span class="keyword">var</span> res = Str(path).replace(bites, <span class="function"><span class="keyword">function</span> <span class="params">(all, command, args)</span> {</span>
                    <span class="keyword">var</span> vals = [],
                        isMove = command.toLowerCase() == <span class="string">"m"</span>,
                        res = map[command];
                    args.replace(val, <span class="function"><span class="keyword">function</span> <span class="params">(value)</span> {</span>
                        <span class="keyword">if</span> (isMove &amp;&amp; vals.length == <span class="number">2</span>) {
                            res += vals + map[command == <span class="string">"m"</span> ? <span class="string">"l"</span> : <span class="string">"L"</span>];
                            vals = [];
                        }
                        vals.push(round(value * zoom));
                    });
                    <span class="keyword">return</span> res + vals;
                });
                <span class="keyword">return</span> res;
            }
            <span class="keyword">var</span> pa = command(path), p, r;
            res = [];
            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, ii = pa.length; i &lt; ii; i++) {
                p = pa[i];
                r = pa[i][<span class="number">0</span>].toLowerCase();
                r == <span class="string">"z"</span> &amp;&amp; (r = <span class="string">"x"</span>);
                <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">1</span>, jj = p.length; j &lt; jj; j++) {
                    r += round(p[j] * zoom) + (j != jj - <span class="number">1</span> ? <span class="string">","</span> : E);
                }
                res.push(r);
            }
            <span class="keyword">return</span> res.join(S);
        },
        compensation = <span class="function"><span class="keyword">function</span> <span class="params">(deg, dx, dy)</span> {</span>
            <span class="keyword">var</span> m = R.matrix();
            m.rotate(-deg, <span class="number">.5</span>, <span class="number">.5</span>);
            <span class="keyword">return</span> {
                dx: m.x(dx, dy),
                dy: m.y(dx, dy)
            };
        },
        setCoords = <span class="function"><span class="keyword">function</span> <span class="params">(p, sx, sy, dx, dy, deg)</span> {</span>
            <span class="keyword">var</span> _ = p._,
                m = p.matrix,
                fillpos = _.fillpos,
                o = p.node,
                s = o.style,
                y = <span class="number">1</span>,
                flip = <span class="string">""</span>,
                dxdy,
                kx = zoom / sx,
                ky = zoom / sy;
            s.visibility = <span class="string">"hidden"</span>;
            <span class="keyword">if</span> (!sx || !sy) {
                <span class="keyword">return</span>;
            }
            o.coordsize = abs(kx) + S + abs(ky);
            s.rotation = deg * (sx * sy &lt; <span class="number">0</span> ? -<span class="number">1</span> : <span class="number">1</span>);
            <span class="keyword">if</span> (deg) {
                <span class="keyword">var</span> c = compensation(deg, dx, dy);
                dx = c.dx;
                dy = c.dy;
            }
            sx &lt; <span class="number">0</span> &amp;&amp; (flip += <span class="string">"x"</span>);
            sy &lt; <span class="number">0</span> &amp;&amp; (flip += <span class="string">" y"</span>) &amp;&amp; (y = -<span class="number">1</span>);
            s.flip = flip;
            o.coordorigin = (dx * -kx) + S + (dy * -ky);
            <span class="keyword">if</span> (fillpos || _.fillsize) {
                <span class="keyword">var</span> fill = o.getElementsByTagName(fillString);
                fill = fill &amp;&amp; fill[<span class="number">0</span>];
                o.removeChild(fill);
                <span class="keyword">if</span> (fillpos) {
                    c = compensation(deg, m.x(fillpos[<span class="number">0</span>], fillpos[<span class="number">1</span>]), m.y(fillpos[<span class="number">0</span>], fillpos[<span class="number">1</span>]));
                    fill.position = c.dx * y + S + c.dy * y;
                }
                <span class="keyword">if</span> (_.fillsize) {
                    fill.size = _.fillsize[<span class="number">0</span>] * abs(sx) + S + _.fillsize[<span class="number">1</span>] * abs(sy);
                }
                o.appendChild(fill);
            }
            s.visibility = <span class="string">"visible"</span>;
        };
    R.toString = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">return</span>  <span class="string">"Your browser doesn\u2019t support SVG. Falling down to VML.\nYou are running Rapha\xebl "</span> + <span class="keyword">this</span>.version;
    };
    <span class="keyword">var</span> addArrow = <span class="function"><span class="keyword">function</span> <span class="params">(o, value, isEnd)</span> {</span>
        <span class="keyword">var</span> values = Str(value).toLowerCase().split(<span class="string">"-"</span>),
            se = isEnd ? <span class="string">"end"</span> : <span class="string">"start"</span>,
            i = values.length,
            type = <span class="string">"classic"</span>,
            w = <span class="string">"medium"</span>,
            h = <span class="string">"medium"</span>;
        <span class="keyword">while</span> (i--) {
            <span class="keyword">switch</span> (values[i]) {
                <span class="keyword">case</span> <span class="string">"block"</span>:
                <span class="keyword">case</span> <span class="string">"classic"</span>:
                <span class="keyword">case</span> <span class="string">"oval"</span>:
                <span class="keyword">case</span> <span class="string">"diamond"</span>:
                <span class="keyword">case</span> <span class="string">"open"</span>:
                <span class="keyword">case</span> <span class="string">"none"</span>:
                    type = values[i];
                    <span class="keyword">break</span>;
                <span class="keyword">case</span> <span class="string">"wide"</span>:
                <span class="keyword">case</span> <span class="string">"narrow"</span>: h = values[i]; <span class="keyword">break</span>;
                <span class="keyword">case</span> <span class="string">"long"</span>:
                <span class="keyword">case</span> <span class="string">"short"</span>: w = values[i]; <span class="keyword">break</span>;
            }
        }
        <span class="keyword">var</span> stroke = o.node.getElementsByTagName(<span class="string">"stroke"</span>)[<span class="number">0</span>];
        stroke[se + <span class="string">"arrow"</span>] = type;
        stroke[se + <span class="string">"arrowlength"</span>] = w;
        stroke[se + <span class="string">"arrowwidth"</span>] = h;
    },
    setFillAndStroke = <span class="function"><span class="keyword">function</span> <span class="params">(o, params)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>o.paper.canvas.style.display = &quot;none&quot;;</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        o.attrs = o.attrs || {};
        <span class="keyword">var</span> node = o.node,
            a = o.attrs,
            s = node.style,
            xy,
            newpath = pathTypes[o.type] &amp;&amp; (params.x != a.x || params.y != a.y || params.width != a.width || params.height != a.height || params.cx != a.cx || params.cy != a.cy || params.rx != a.rx || params.ry != a.ry || params.r != a.r),
            isOval = ovalTypes[o.type] &amp;&amp; (a.cx != params.cx || a.cy != params.cy || a.r != params.r || a.rx != params.rx || a.ry != params.ry),
            res = o;


        <span class="keyword">for</span> (<span class="keyword">var</span> par <span class="keyword">in</span> params) <span class="keyword">if</span> (params[has](par)) {
            a[par] = params[par];
        }
        <span class="keyword">if</span> (newpath) {
            a.path = R._getPath[o.type](o);
            o._.dirty = <span class="number">1</span>;
        }
        params.href &amp;&amp; (node.href = params.href);
        params.title &amp;&amp; (node.title = params.title);
        params.target &amp;&amp; (node.target = params.target);
        params.cursor &amp;&amp; (s.cursor = params.cursor);
        <span class="string">"blur"</span> <span class="keyword">in</span> params &amp;&amp; o.blur(params.blur);
        <span class="keyword">if</span> (params.path &amp;&amp; o.type == <span class="string">"path"</span> || newpath) {
            node.path = path2vml(~Str(a.path).toLowerCase().indexOf(<span class="string">"r"</span>) ? R._pathToAbsolute(a.path) : a.path);
            <span class="keyword">if</span> (o.type == <span class="string">"image"</span>) {
                o._.fillpos = [a.x, a.y];
                o._.fillsize = [a.width, a.height];
                setCoords(o, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);
            }
        }
        <span class="string">"transform"</span> <span class="keyword">in</span> params &amp;&amp; o.transform(params.transform);
        <span class="keyword">if</span> (isOval) {
            <span class="keyword">var</span> cx = +a.cx,
                cy = +a.cy,
                rx = +a.rx || +a.r || <span class="number">0</span>,
                ry = +a.ry || +a.r || <span class="number">0</span>;
            node.path = R.format(<span class="string">"ar{0},{1},{2},{3},{4},{1},{4},{1}x"</span>, round((cx - rx) * zoom), round((cy - ry) * zoom), round((cx + rx) * zoom), round((cy + ry) * zoom), round(cx * zoom));
            o._.dirty = <span class="number">1</span>;
        }
        <span class="keyword">if</span> (<span class="string">"clip-rect"</span> <span class="keyword">in</span> params) {
            <span class="keyword">var</span> rect = Str(params[<span class="string">"clip-rect"</span>]).split(separator);
            <span class="keyword">if</span> (rect.length == <span class="number">4</span>) {
                rect[<span class="number">2</span>] = +rect[<span class="number">2</span>] + (+rect[<span class="number">0</span>]);
                rect[<span class="number">3</span>] = +rect[<span class="number">3</span>] + (+rect[<span class="number">1</span>]);
                <span class="keyword">var</span> div = node.clipRect || R._g.doc.createElement(<span class="string">"div"</span>),
                    dstyle = div.style;
                dstyle.clip = R.format(<span class="string">"rect({1}px {2}px {3}px {0}px)"</span>, rect);
                <span class="keyword">if</span> (!node.clipRect) {
                    dstyle.position = <span class="string">"absolute"</span>;
                    dstyle.top = <span class="number">0</span>;
                    dstyle.left = <span class="number">0</span>;
                    dstyle.width = o.paper.width + <span class="string">"px"</span>;
                    dstyle.height = o.paper.height + <span class="string">"px"</span>;
                    node.parentNode.insertBefore(div, node);
                    div.appendChild(node);
                    node.clipRect = div;
                }
            }
            <span class="keyword">if</span> (!params[<span class="string">"clip-rect"</span>]) {
                node.clipRect &amp;&amp; (node.clipRect.style.clip = <span class="string">"auto"</span>);
            }
        }
        <span class="keyword">if</span> (o.textpath) {
            <span class="keyword">var</span> textpathStyle = o.textpath.style;
            params.font &amp;&amp; (textpathStyle.font = params.font);
            params[<span class="string">"font-family"</span>] &amp;&amp; (textpathStyle.fontFamily = <span class="string">'"'</span> + params[<span class="string">"font-family"</span>].split(<span class="string">","</span>)[<span class="number">0</span>].replace(<span class="regexp">/^['"]+|['"]+$/g</span>, E) + <span class="string">'"'</span>);
            params[<span class="string">"font-size"</span>] &amp;&amp; (textpathStyle.fontSize = params[<span class="string">"font-size"</span>]);
            params[<span class="string">"font-weight"</span>] &amp;&amp; (textpathStyle.fontWeight = params[<span class="string">"font-weight"</span>]);
            params[<span class="string">"font-style"</span>] &amp;&amp; (textpathStyle.fontStyle = params[<span class="string">"font-style"</span>]);
        }
        <span class="keyword">if</span> (<span class="string">"arrow-start"</span> <span class="keyword">in</span> params) {
            addArrow(res, params[<span class="string">"arrow-start"</span>]);
        }
        <span class="keyword">if</span> (<span class="string">"arrow-end"</span> <span class="keyword">in</span> params) {
            addArrow(res, params[<span class="string">"arrow-end"</span>], <span class="number">1</span>);
        }
        <span class="keyword">if</span> (params.opacity != <span class="literal">null</span> || 
            params[<span class="string">"stroke-width"</span>] != <span class="literal">null</span> ||
            params.fill != <span class="literal">null</span> ||
            params.src != <span class="literal">null</span> ||
            params.stroke != <span class="literal">null</span> ||
            params[<span class="string">"stroke-width"</span>] != <span class="literal">null</span> ||
            params[<span class="string">"stroke-opacity"</span>] != <span class="literal">null</span> ||
            params[<span class="string">"fill-opacity"</span>] != <span class="literal">null</span> ||
            params[<span class="string">"stroke-dasharray"</span>] != <span class="literal">null</span> ||
            params[<span class="string">"stroke-miterlimit"</span>] != <span class="literal">null</span> ||
            params[<span class="string">"stroke-linejoin"</span>] != <span class="literal">null</span> ||
            params[<span class="string">"stroke-linecap"</span>] != <span class="literal">null</span>) {
            <span class="keyword">var</span> fill = node.getElementsByTagName(fillString),
                newfill = <span class="literal">false</span>;
            fill = fill &amp;&amp; fill[<span class="number">0</span>];
            !fill &amp;&amp; (newfill = fill = createNode(fillString));
            <span class="keyword">if</span> (o.type == <span class="string">"image"</span> &amp;&amp; params.src) {
                fill.src = params.src;
            }
            params.fill &amp;&amp; (fill.on = <span class="literal">true</span>);
            <span class="keyword">if</span> (fill.on == <span class="literal">null</span> || params.fill == <span class="string">"none"</span> || params.fill === <span class="literal">null</span>) {
                fill.on = <span class="literal">false</span>;
            }
            <span class="keyword">if</span> (fill.on &amp;&amp; params.fill) {
                <span class="keyword">var</span> isURL = Str(params.fill).match(R._ISURL);
                <span class="keyword">if</span> (isURL) {
                    fill.parentNode == node &amp;&amp; node.removeChild(fill);
                    fill.rotate = <span class="literal">true</span>;
                    fill.src = isURL[<span class="number">1</span>];
                    fill.type = <span class="string">"tile"</span>;
                    <span class="keyword">var</span> bbox = o.getBBox(<span class="number">1</span>);
                    fill.position = bbox.x + S + bbox.y;
                    o._.fillpos = [bbox.x, bbox.y];

                    R._preload(isURL[<span class="number">1</span>], <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
                        o._.fillsize = [<span class="keyword">this</span>.offsetWidth, <span class="keyword">this</span>.offsetHeight];
                    });
                } <span class="keyword">else</span> {
                    fill.color = R.getRGB(params.fill).hex;
                    fill.src = E;
                    fill.type = <span class="string">"solid"</span>;
                    <span class="keyword">if</span> (R.getRGB(params.fill).error &amp;&amp; (res.type <span class="keyword">in</span> {circle: <span class="number">1</span>, ellipse: <span class="number">1</span>} || Str(params.fill).charAt() != <span class="string">"r"</span>) &amp;&amp; addGradientFill(res, params.fill, fill)) {
                        a.fill = <span class="string">"none"</span>;
                        a.gradient = params.fill;
                        fill.rotate = <span class="literal">false</span>;
                    }
                }
            }
            <span class="keyword">if</span> (<span class="string">"fill-opacity"</span> <span class="keyword">in</span> params || <span class="string">"opacity"</span> <span class="keyword">in</span> params) {
                <span class="keyword">var</span> opacity = ((+a[<span class="string">"fill-opacity"</span>] + <span class="number">1</span> || <span class="number">2</span>) - <span class="number">1</span>) * ((+a.opacity + <span class="number">1</span> || <span class="number">2</span>) - <span class="number">1</span>) * ((+R.getRGB(params.fill).o + <span class="number">1</span> || <span class="number">2</span>) - <span class="number">1</span>);
                opacity = mmin(mmax(opacity, <span class="number">0</span>), <span class="number">1</span>);
                fill.opacity = opacity;
                <span class="keyword">if</span> (fill.src) {
                    fill.color = <span class="string">"none"</span>;
                }
            }
            node.appendChild(fill);
            <span class="keyword">var</span> stroke = (node.getElementsByTagName(<span class="string">"stroke"</span>) &amp;&amp; node.getElementsByTagName(<span class="string">"stroke"</span>)[<span class="number">0</span>]),
            newstroke = <span class="literal">false</span>;
            !stroke &amp;&amp; (newstroke = stroke = createNode(<span class="string">"stroke"</span>));
            <span class="keyword">if</span> ((params.stroke &amp;&amp; params.stroke != <span class="string">"none"</span>) ||
                params[<span class="string">"stroke-width"</span>] ||
                params[<span class="string">"stroke-opacity"</span>] != <span class="literal">null</span> ||
                params[<span class="string">"stroke-dasharray"</span>] ||
                params[<span class="string">"stroke-miterlimit"</span>] ||
                params[<span class="string">"stroke-linejoin"</span>] ||
                params[<span class="string">"stroke-linecap"</span>]) {
                stroke.on = <span class="literal">true</span>;
            }
            (params.stroke == <span class="string">"none"</span> || params.stroke === <span class="literal">null</span> || stroke.on == <span class="literal">null</span> || params.stroke == <span class="number">0</span> || params[<span class="string">"stroke-width"</span>] == <span class="number">0</span>) &amp;&amp; (stroke.on = <span class="literal">false</span>);
            <span class="keyword">var</span> strokeColor = R.getRGB(params.stroke);
            stroke.on &amp;&amp; params.stroke &amp;&amp; (stroke.color = strokeColor.hex);
            opacity = ((+a[<span class="string">"stroke-opacity"</span>] + <span class="number">1</span> || <span class="number">2</span>) - <span class="number">1</span>) * ((+a.opacity + <span class="number">1</span> || <span class="number">2</span>) - <span class="number">1</span>) * ((+strokeColor.o + <span class="number">1</span> || <span class="number">2</span>) - <span class="number">1</span>);
            <span class="keyword">var</span> width = (toFloat(params[<span class="string">"stroke-width"</span>]) || <span class="number">1</span>) * <span class="number">.75</span>;
            opacity = mmin(mmax(opacity, <span class="number">0</span>), <span class="number">1</span>);
            params[<span class="string">"stroke-width"</span>] == <span class="literal">null</span> &amp;&amp; (width = a[<span class="string">"stroke-width"</span>]);
            params[<span class="string">"stroke-width"</span>] &amp;&amp; (stroke.weight = width);
            width &amp;&amp; width &lt; <span class="number">1</span> &amp;&amp; (opacity *= width) &amp;&amp; (stroke.weight = <span class="number">1</span>);
            stroke.opacity = opacity;
        
            params[<span class="string">"stroke-linejoin"</span>] &amp;&amp; (stroke.joinstyle = params[<span class="string">"stroke-linejoin"</span>] || <span class="string">"miter"</span>);
            stroke.miterlimit = params[<span class="string">"stroke-miterlimit"</span>] || <span class="number">8</span>;
            params[<span class="string">"stroke-linecap"</span>] &amp;&amp; (stroke.endcap = params[<span class="string">"stroke-linecap"</span>] == <span class="string">"butt"</span> ? <span class="string">"flat"</span> : params[<span class="string">"stroke-linecap"</span>] == <span class="string">"square"</span> ? <span class="string">"square"</span> : <span class="string">"round"</span>);
            <span class="keyword">if</span> (params[<span class="string">"stroke-dasharray"</span>]) {
                <span class="keyword">var</span> dasharray = {
                    <span class="string">"-"</span>: <span class="string">"shortdash"</span>,
                    <span class="string">"."</span>: <span class="string">"shortdot"</span>,
                    <span class="string">"-."</span>: <span class="string">"shortdashdot"</span>,
                    <span class="string">"-.."</span>: <span class="string">"shortdashdotdot"</span>,
                    <span class="string">". "</span>: <span class="string">"dot"</span>,
                    <span class="string">"- "</span>: <span class="string">"dash"</span>,
                    <span class="string">"--"</span>: <span class="string">"longdash"</span>,
                    <span class="string">"- ."</span>: <span class="string">"dashdot"</span>,
                    <span class="string">"--."</span>: <span class="string">"longdashdot"</span>,
                    <span class="string">"--.."</span>: <span class="string">"longdashdotdot"</span>
                };
                stroke.dashstyle = dasharray[has](params[<span class="string">"stroke-dasharray"</span>]) ? dasharray[params[<span class="string">"stroke-dasharray"</span>]] : E;
            }
            newstroke &amp;&amp; node.appendChild(stroke);
        }
        <span class="keyword">if</span> (res.type == <span class="string">"text"</span>) {
            res.paper.canvas.style.display = E;
            <span class="keyword">var</span> span = res.paper.span,
                m = <span class="number">100</span>,
                fontSize = a.font &amp;&amp; a.font.match(<span class="regexp">/\d+(?:\.\d*)?(?=px)/</span>);
            s = span.style;
            a.font &amp;&amp; (s.font = a.font);
            a[<span class="string">"font-family"</span>] &amp;&amp; (s.fontFamily = a[<span class="string">"font-family"</span>]);
            a[<span class="string">"font-weight"</span>] &amp;&amp; (s.fontWeight = a[<span class="string">"font-weight"</span>]);
            a[<span class="string">"font-style"</span>] &amp;&amp; (s.fontStyle = a[<span class="string">"font-style"</span>]);
            fontSize = toFloat(a[<span class="string">"font-size"</span>] || fontSize &amp;&amp; fontSize[<span class="number">0</span>]) || <span class="number">10</span>;
            s.fontSize = fontSize * m + <span class="string">"px"</span>;
            res.textpath.string &amp;&amp; (span.innerHTML = Str(res.textpath.string).replace(<span class="regexp">/&lt;/g</span>, <span class="string">"&amp;#60;"</span>).replace(<span class="regexp">/&amp;/g</span>, <span class="string">"&amp;#38;"</span>).replace(<span class="regexp">/\n/g</span>, <span class="string">"&lt;br&gt;"</span>));
            <span class="keyword">var</span> brect = span.getBoundingClientRect();
            res.W = a.w = (brect.right - brect.left) / m;
            res.H = a.h = (brect.bottom - brect.top) / m;</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>res.paper.canvas.style.display = &quot;none&quot;;</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            res.X = a.x;
            res.Y = a.y + res.H / <span class="number">2</span>;

            (<span class="string">"x"</span> <span class="keyword">in</span> params || <span class="string">"y"</span> <span class="keyword">in</span> params) &amp;&amp; (res.path.v = R.format(<span class="string">"m{0},{1}l{2},{1}"</span>, round(a.x * zoom), round(a.y * zoom), round(a.x * zoom) + <span class="number">1</span>));
            <span class="keyword">var</span> dirtyattrs = [<span class="string">"x"</span>, <span class="string">"y"</span>, <span class="string">"text"</span>, <span class="string">"font"</span>, <span class="string">"font-family"</span>, <span class="string">"font-weight"</span>, <span class="string">"font-style"</span>, <span class="string">"font-size"</span>];
            <span class="keyword">for</span> (<span class="keyword">var</span> d = <span class="number">0</span>, dd = dirtyattrs.length; d &lt; dd; d++) <span class="keyword">if</span> (dirtyattrs[d] <span class="keyword">in</span> params) {
                res._.dirty = <span class="number">1</span>;
                <span class="keyword">break</span>;
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>text-anchor emulation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">switch</span> (a[<span class="string">"text-anchor"</span>]) {
                <span class="keyword">case</span> <span class="string">"start"</span>:
                    res.textpath.style[<span class="string">"v-text-align"</span>] = <span class="string">"left"</span>;
                    res.bbx = res.W / <span class="number">2</span>;
                <span class="keyword">break</span>;
                <span class="keyword">case</span> <span class="string">"end"</span>:
                    res.textpath.style[<span class="string">"v-text-align"</span>] = <span class="string">"right"</span>;
                    res.bbx = -res.W / <span class="number">2</span>;
                <span class="keyword">break</span>;
                <span class="keyword">default</span>:
                    res.textpath.style[<span class="string">"v-text-align"</span>] = <span class="string">"center"</span>;
                    res.bbx = <span class="number">0</span>;
                <span class="keyword">break</span>;
            }
            res.textpath.style[<span class="string">"v-text-kern"</span>] = <span class="literal">true</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>res.paper.canvas.style.display = E;</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    },
    addGradientFill = <span class="function"><span class="keyword">function</span> <span class="params">(o, gradient, fill)</span> {</span>
        o.attrs = o.attrs || {};
        <span class="keyword">var</span> attrs = o.attrs,
            pow = Math.pow,
            opacity,
            oindex,
            type = <span class="string">"linear"</span>,
            fxfy = <span class="string">".5 .5"</span>;
        o.attrs.gradient = gradient;
        gradient = Str(gradient).replace(R._radial_gradient, <span class="function"><span class="keyword">function</span> <span class="params">(all, fx, fy)</span> {</span>
            type = <span class="string">"radial"</span>;
            <span class="keyword">if</span> (fx &amp;&amp; fy) {
                fx = toFloat(fx);
                fy = toFloat(fy);
                pow(fx - <span class="number">.5</span>, <span class="number">2</span>) + pow(fy - <span class="number">.5</span>, <span class="number">2</span>) &gt; <span class="number">.25</span> &amp;&amp; (fy = math.sqrt(<span class="number">.25</span> - pow(fx - <span class="number">.5</span>, <span class="number">2</span>)) * ((fy &gt; <span class="number">.5</span>) * <span class="number">2</span> - <span class="number">1</span>) + <span class="number">.5</span>);
                fxfy = fx + S + fy;
            }
            <span class="keyword">return</span> E;
        });
        gradient = gradient.split(<span class="regexp">/\s*\-\s*/</span>);
        <span class="keyword">if</span> (type == <span class="string">"linear"</span>) {
            <span class="keyword">var</span> angle = gradient.shift();
            angle = -toFloat(angle);
            <span class="keyword">if</span> (isNaN(angle)) {
                <span class="keyword">return</span> <span class="literal">null</span>;
            }
        }
        <span class="keyword">var</span> dots = R._parseDots(gradient);
        <span class="keyword">if</span> (!dots) {
            <span class="keyword">return</span> <span class="literal">null</span>;
        }
        o = o.shape || o.node;
        <span class="keyword">if</span> (dots.length) {
            o.removeChild(fill);
            fill.on = <span class="literal">true</span>;
            fill.method = <span class="string">"none"</span>;
            fill.color = dots[<span class="number">0</span>].color;
            fill.color2 = dots[dots.length - <span class="number">1</span>].color;
            <span class="keyword">var</span> clrs = [];
            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, ii = dots.length; i &lt; ii; i++) {
                dots[i].offset &amp;&amp; clrs.push(dots[i].offset + S + dots[i].color);
            }
            fill.colors = clrs.length ? clrs.join() : <span class="string">"0% "</span> + fill.color;
            <span class="keyword">if</span> (type == <span class="string">"radial"</span>) {
                fill.type = <span class="string">"gradientTitle"</span>;
                fill.focus = <span class="string">"100%"</span>;
                fill.focussize = <span class="string">"0 0"</span>;
                fill.focusposition = fxfy;
                fill.angle = <span class="number">0</span>;
            } <span class="keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>fill.rotate= true;</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                fill.type = <span class="string">"gradient"</span>;
                fill.angle = (<span class="number">270</span> - angle) % <span class="number">360</span>;
            }
            o.appendChild(fill);
        }
        <span class="keyword">return</span> <span class="number">1</span>;
    },
    Element = <span class="function"><span class="keyword">function</span> <span class="params">(node, vml)</span> {</span>
        <span class="keyword">this</span>[<span class="number">0</span>] = <span class="keyword">this</span>.node = node;
        node.raphael = <span class="literal">true</span>;
        <span class="keyword">this</span>.id = R._oid++;
        node.raphaelid = <span class="keyword">this</span>.id;
        <span class="keyword">this</span>.X = <span class="number">0</span>;
        <span class="keyword">this</span>.Y = <span class="number">0</span>;
        <span class="keyword">this</span>.attrs = {};
        <span class="keyword">this</span>.paper = vml;
        <span class="keyword">this</span>.matrix = R.matrix();
        <span class="keyword">this</span>._ = {
            transform: [],
            sx: <span class="number">1</span>,
            sy: <span class="number">1</span>,
            dx: <span class="number">0</span>,
            dy: <span class="number">0</span>,
            deg: <span class="number">0</span>,
            dirty: <span class="number">1</span>,
            dirtyT: <span class="number">1</span>
        };
        !vml.bottom &amp;&amp; (vml.bottom = <span class="keyword">this</span>);
        <span class="keyword">this</span>.prev = vml.top;
        vml.top &amp;&amp; (vml.top.next = <span class="keyword">this</span>);
        vml.top = <span class="keyword">this</span>;
        <span class="keyword">this</span>.next = <span class="literal">null</span>;
    };
    <span class="keyword">var</span> elproto = R.el;

    Element.prototype = elproto;
    elproto.constructor = Element;
    elproto.transform = <span class="function"><span class="keyword">function</span> <span class="params">(tstr)</span> {</span>
        <span class="keyword">if</span> (tstr == <span class="literal">null</span>) {
            <span class="keyword">return</span> <span class="keyword">this</span>._.transform;
        }
        <span class="keyword">var</span> vbs = <span class="keyword">this</span>.paper._viewBoxShift,
            vbt = vbs ? <span class="string">"s"</span> + [vbs.scale, vbs.scale] + <span class="string">"-1-1t"</span> + [vbs.dx, vbs.dy] : E,
            oldt;
        <span class="keyword">if</span> (vbs) {
            oldt = tstr = Str(tstr).replace(<span class="regexp">/\.{3}|\u2026/g</span>, <span class="keyword">this</span>._.transform || E);
        }
        R._extractTransform(<span class="keyword">this</span>, vbt + tstr);
        <span class="keyword">var</span> matrix = <span class="keyword">this</span>.matrix.clone(),
            skew = <span class="keyword">this</span>.skew,
            o = <span class="keyword">this</span>.node,
            split,
            isGrad = ~Str(<span class="keyword">this</span>.attrs.fill).indexOf(<span class="string">"-"</span>),
            isPatt = !Str(<span class="keyword">this</span>.attrs.fill).indexOf(<span class="string">"url("</span>);
        matrix.translate(-<span class="number">.5</span>, -<span class="number">.5</span>);
        <span class="keyword">if</span> (isPatt || isGrad || <span class="keyword">this</span>.type == <span class="string">"image"</span>) {
            skew.matrix = <span class="string">"1 0 0 1"</span>;
            skew.offset = <span class="string">"0 0"</span>;
            split = matrix.split();
            <span class="keyword">if</span> ((isGrad &amp;&amp; split.noRotation) || !split.isSimple) {
                o.style.filter = matrix.toFilter();
                <span class="keyword">var</span> bb = <span class="keyword">this</span>.getBBox(),
                    bbt = <span class="keyword">this</span>.getBBox(<span class="number">1</span>),
                    dx = bb.x - bbt.x,
                    dy = bb.y - bbt.y;
                o.coordorigin = (dx * -zoom) + S + (dy * -zoom);
                setCoords(<span class="keyword">this</span>, <span class="number">1</span>, <span class="number">1</span>, dx, dy, <span class="number">0</span>);
            } <span class="keyword">else</span> {
                o.style.filter = E;
                setCoords(<span class="keyword">this</span>, split.scalex, split.scaley, split.dx, split.dy, split.rotate);
            }
        } <span class="keyword">else</span> {
            o.style.filter = E;
            skew.matrix = Str(matrix);
            skew.offset = matrix.offset();
        }
        oldt &amp;&amp; (<span class="keyword">this</span>._.transform = oldt);
        <span class="keyword">return</span> <span class="keyword">this</span>;
    };
    elproto.rotate = <span class="function"><span class="keyword">function</span> <span class="params">(deg, cx, cy)</span> {</span>
        <span class="keyword">if</span> (<span class="keyword">this</span>.removed) {
            <span class="keyword">return</span> <span class="keyword">this</span>;
        }
        <span class="keyword">if</span> (deg == <span class="literal">null</span>) {
            <span class="keyword">return</span>;
        }
        deg = Str(deg).split(separator);
        <span class="keyword">if</span> (deg.length - <span class="number">1</span>) {
            cx = toFloat(deg[<span class="number">1</span>]);
            cy = toFloat(deg[<span class="number">2</span>]);
        }
        deg = toFloat(deg[<span class="number">0</span>]);
        (cy == <span class="literal">null</span>) &amp;&amp; (cx = cy);
        <span class="keyword">if</span> (cx == <span class="literal">null</span> || cy == <span class="literal">null</span>) {
            <span class="keyword">var</span> bbox = <span class="keyword">this</span>.getBBox(<span class="number">1</span>);
            cx = bbox.x + bbox.width / <span class="number">2</span>;
            cy = bbox.y + bbox.height / <span class="number">2</span>;
        }
        <span class="keyword">this</span>._.dirtyT = <span class="number">1</span>;
        <span class="keyword">this</span>.transform(<span class="keyword">this</span>._.transform.concat([[<span class="string">"r"</span>, deg, cx, cy]]));
        <span class="keyword">return</span> <span class="keyword">this</span>;
    };
    elproto.translate = <span class="function"><span class="keyword">function</span> <span class="params">(dx, dy)</span> {</span>
        <span class="keyword">if</span> (<span class="keyword">this</span>.removed) {
            <span class="keyword">return</span> <span class="keyword">this</span>;
        }
        dx = Str(dx).split(separator);
        <span class="keyword">if</span> (dx.length - <span class="number">1</span>) {
            dy = toFloat(dx[<span class="number">1</span>]);
        }
        dx = toFloat(dx[<span class="number">0</span>]) || <span class="number">0</span>;
        dy = +dy || <span class="number">0</span>;
        <span class="keyword">if</span> (<span class="keyword">this</span>._.bbox) {
            <span class="keyword">this</span>._.bbox.x += dx;
            <span class="keyword">this</span>._.bbox.y += dy;
        }
        <span class="keyword">this</span>.transform(<span class="keyword">this</span>._.transform.concat([[<span class="string">"t"</span>, dx, dy]]));
        <span class="keyword">return</span> <span class="keyword">this</span>;
    };
    elproto.scale = <span class="function"><span class="keyword">function</span> <span class="params">(sx, sy, cx, cy)</span> {</span>
        <span class="keyword">if</span> (<span class="keyword">this</span>.removed) {
            <span class="keyword">return</span> <span class="keyword">this</span>;
        }
        sx = Str(sx).split(separator);
        <span class="keyword">if</span> (sx.length - <span class="number">1</span>) {
            sy = toFloat(sx[<span class="number">1</span>]);
            cx = toFloat(sx[<span class="number">2</span>]);
            cy = toFloat(sx[<span class="number">3</span>]);
            isNaN(cx) &amp;&amp; (cx = <span class="literal">null</span>);
            isNaN(cy) &amp;&amp; (cy = <span class="literal">null</span>);
        }
        sx = toFloat(sx[<span class="number">0</span>]);
        (sy == <span class="literal">null</span>) &amp;&amp; (sy = sx);
        (cy == <span class="literal">null</span>) &amp;&amp; (cx = cy);
        <span class="keyword">if</span> (cx == <span class="literal">null</span> || cy == <span class="literal">null</span>) {
            <span class="keyword">var</span> bbox = <span class="keyword">this</span>.getBBox(<span class="number">1</span>);
        }
        cx = cx == <span class="literal">null</span> ? bbox.x + bbox.width / <span class="number">2</span> : cx;
        cy = cy == <span class="literal">null</span> ? bbox.y + bbox.height / <span class="number">2</span> : cy;
    
        <span class="keyword">this</span>.transform(<span class="keyword">this</span>._.transform.concat([[<span class="string">"s"</span>, sx, sy, cx, cy]]));
        <span class="keyword">this</span>._.dirtyT = <span class="number">1</span>;
        <span class="keyword">return</span> <span class="keyword">this</span>;
    };
    elproto.hide = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        !<span class="keyword">this</span>.removed &amp;&amp; (<span class="keyword">this</span>.node.style.display = <span class="string">"none"</span>);
        <span class="keyword">return</span> <span class="keyword">this</span>;
    };
    elproto.show = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        !<span class="keyword">this</span>.removed &amp;&amp; (<span class="keyword">this</span>.node.style.display = E);
        <span class="keyword">return</span> <span class="keyword">this</span>;
    };
    elproto._getBBox = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">if</span> (<span class="keyword">this</span>.removed) {
            <span class="keyword">return</span> {};
        }
        <span class="keyword">return</span> {
            x: <span class="keyword">this</span>.X + (<span class="keyword">this</span>.bbx || <span class="number">0</span>) - <span class="keyword">this</span>.W / <span class="number">2</span>,
            y: <span class="keyword">this</span>.Y - <span class="keyword">this</span>.H,
            width: <span class="keyword">this</span>.W,
            height: <span class="keyword">this</span>.H
        };
    };
    elproto.remove = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">if</span> (<span class="keyword">this</span>.removed || !<span class="keyword">this</span>.node.parentNode) {
            <span class="keyword">return</span>;
        }
        <span class="keyword">this</span>.paper.__set__ &amp;&amp; <span class="keyword">this</span>.paper.__set__.exclude(<span class="keyword">this</span>);
        R.eve.unbind(<span class="string">"raphael.*.*."</span> + <span class="keyword">this</span>.id);
        R._tear(<span class="keyword">this</span>, <span class="keyword">this</span>.paper);
        <span class="keyword">this</span>.node.parentNode.removeChild(<span class="keyword">this</span>.node);
        <span class="keyword">this</span>.shape &amp;&amp; <span class="keyword">this</span>.shape.parentNode.removeChild(<span class="keyword">this</span>.shape);
        <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> <span class="keyword">this</span>) {
            <span class="keyword">this</span>[i] = <span class="keyword">typeof</span> <span class="keyword">this</span>[i] == <span class="string">"function"</span> ? R._removedFactory(i) : <span class="literal">null</span>;
        }
        <span class="keyword">this</span>.removed = <span class="literal">true</span>;
    };
    elproto.attr = <span class="function"><span class="keyword">function</span> <span class="params">(name, value)</span> {</span>
        <span class="keyword">if</span> (<span class="keyword">this</span>.removed) {
            <span class="keyword">return</span> <span class="keyword">this</span>;
        }
        <span class="keyword">if</span> (name == <span class="literal">null</span>) {
            <span class="keyword">var</span> res = {};
            <span class="keyword">for</span> (<span class="keyword">var</span> a <span class="keyword">in</span> <span class="keyword">this</span>.attrs) <span class="keyword">if</span> (<span class="keyword">this</span>.attrs[has](a)) {
                res[a] = <span class="keyword">this</span>.attrs[a];
            }
            res.gradient &amp;&amp; res.fill == <span class="string">"none"</span> &amp;&amp; (res.fill = res.gradient) &amp;&amp; <span class="keyword">delete</span> res.gradient;
            res.transform = <span class="keyword">this</span>._.transform;
            <span class="keyword">return</span> res;
        }
        <span class="keyword">if</span> (value == <span class="literal">null</span> &amp;&amp; R.is(name, <span class="string">"string"</span>)) {
            <span class="keyword">if</span> (name == fillString &amp;&amp; <span class="keyword">this</span>.attrs.fill == <span class="string">"none"</span> &amp;&amp; <span class="keyword">this</span>.attrs.gradient) {
                <span class="keyword">return</span> <span class="keyword">this</span>.attrs.gradient;
            }
            <span class="keyword">var</span> names = name.split(separator),
                out = {};
            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, ii = names.length; i &lt; ii; i++) {
                name = names[i];
                <span class="keyword">if</span> (name <span class="keyword">in</span> <span class="keyword">this</span>.attrs) {
                    out[name] = <span class="keyword">this</span>.attrs[name];
                } <span class="keyword">else</span> <span class="keyword">if</span> (R.is(<span class="keyword">this</span>.paper.customAttributes[name], <span class="string">"function"</span>)) {
                    out[name] = <span class="keyword">this</span>.paper.customAttributes[name].def;
                } <span class="keyword">else</span> {
                    out[name] = R._availableAttrs[name];
                }
            }
            <span class="keyword">return</span> ii - <span class="number">1</span> ? out : out[names[<span class="number">0</span>]];
        }
        <span class="keyword">if</span> (<span class="keyword">this</span>.attrs &amp;&amp; value == <span class="literal">null</span> &amp;&amp; R.is(name, <span class="string">"array"</span>)) {
            out = {};
            <span class="keyword">for</span> (i = <span class="number">0</span>, ii = name.length; i &lt; ii; i++) {
                out[name[i]] = <span class="keyword">this</span>.attr(name[i]);
            }
            <span class="keyword">return</span> out;
        }
        <span class="keyword">var</span> params;
        <span class="keyword">if</span> (value != <span class="literal">null</span>) {
            params = {};
            params[name] = value;
        }
        value == <span class="literal">null</span> &amp;&amp; R.is(name, <span class="string">"object"</span>) &amp;&amp; (params = name);
        <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> params) {
            eve(<span class="string">"raphael.attr."</span> + key + <span class="string">"."</span> + <span class="keyword">this</span>.id, <span class="keyword">this</span>, params[key]);
        }
        <span class="keyword">if</span> (params) {
            <span class="keyword">for</span> (key <span class="keyword">in</span> <span class="keyword">this</span>.paper.customAttributes) <span class="keyword">if</span> (<span class="keyword">this</span>.paper.customAttributes[has](key) &amp;&amp; params[has](key) &amp;&amp; R.is(<span class="keyword">this</span>.paper.customAttributes[key], <span class="string">"function"</span>)) {
                <span class="keyword">var</span> par = <span class="keyword">this</span>.paper.customAttributes[key].apply(<span class="keyword">this</span>, [].concat(params[key]));
                <span class="keyword">this</span>.attrs[key] = params[key];
                <span class="keyword">for</span> (<span class="keyword">var</span> subkey <span class="keyword">in</span> par) <span class="keyword">if</span> (par[has](subkey)) {
                    params[subkey] = par[subkey];
                }
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>this.paper.canvas.style.display = &quot;none&quot;;</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">if</span> (params.text &amp;&amp; <span class="keyword">this</span>.type == <span class="string">"text"</span>) {
                <span class="keyword">this</span>.textpath.string = params.text;
            }
            setFillAndStroke(<span class="keyword">this</span>, params);</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>this.paper.canvas.style.display = E;</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        }
        <span class="keyword">return</span> <span class="keyword">this</span>;
    };
    elproto.toFront = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        !<span class="keyword">this</span>.removed &amp;&amp; <span class="keyword">this</span>.node.parentNode.appendChild(<span class="keyword">this</span>.node);
        <span class="keyword">this</span>.paper &amp;&amp; <span class="keyword">this</span>.paper.top != <span class="keyword">this</span> &amp;&amp; R._tofront(<span class="keyword">this</span>, <span class="keyword">this</span>.paper);
        <span class="keyword">return</span> <span class="keyword">this</span>;
    };
    elproto.toBack = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">if</span> (<span class="keyword">this</span>.removed) {
            <span class="keyword">return</span> <span class="keyword">this</span>;
        }
        <span class="keyword">if</span> (<span class="keyword">this</span>.node.parentNode.firstChild != <span class="keyword">this</span>.node) {
            <span class="keyword">this</span>.node.parentNode.insertBefore(<span class="keyword">this</span>.node, <span class="keyword">this</span>.node.parentNode.firstChild);
            R._toback(<span class="keyword">this</span>, <span class="keyword">this</span>.paper);
        }
        <span class="keyword">return</span> <span class="keyword">this</span>;
    };
    elproto.insertAfter = <span class="function"><span class="keyword">function</span> <span class="params">(element)</span> {</span>
        <span class="keyword">if</span> (<span class="keyword">this</span>.removed) {
            <span class="keyword">return</span> <span class="keyword">this</span>;
        }
        <span class="keyword">if</span> (element.constructor == R.st.constructor) {
            element = element[element.length - <span class="number">1</span>];
        }
        <span class="keyword">if</span> (element.node.nextSibling) {
            element.node.parentNode.insertBefore(<span class="keyword">this</span>.node, element.node.nextSibling);
        } <span class="keyword">else</span> {
            element.node.parentNode.appendChild(<span class="keyword">this</span>.node);
        }
        R._insertafter(<span class="keyword">this</span>, element, <span class="keyword">this</span>.paper);
        <span class="keyword">return</span> <span class="keyword">this</span>;
    };
    elproto.insertBefore = <span class="function"><span class="keyword">function</span> <span class="params">(element)</span> {</span>
        <span class="keyword">if</span> (<span class="keyword">this</span>.removed) {
            <span class="keyword">return</span> <span class="keyword">this</span>;
        }
        <span class="keyword">if</span> (element.constructor == R.st.constructor) {
            element = element[<span class="number">0</span>];
        }
        element.node.parentNode.insertBefore(<span class="keyword">this</span>.node, element.node);
        R._insertbefore(<span class="keyword">this</span>, element, <span class="keyword">this</span>.paper);
        <span class="keyword">return</span> <span class="keyword">this</span>;
    };
    elproto.blur = <span class="function"><span class="keyword">function</span> <span class="params">(size)</span> {</span>
        <span class="keyword">var</span> s = <span class="keyword">this</span>.node.runtimeStyle,
            f = s.filter;
        f = f.replace(blurregexp, E);
        <span class="keyword">if</span> (+size !== <span class="number">0</span>) {
            <span class="keyword">this</span>.attrs.blur = size;
            s.filter = f + S + ms + <span class="string">".Blur(pixelradius="</span> + (+size || <span class="number">1.5</span>) + <span class="string">")"</span>;
            s.margin = R.format(<span class="string">"-{0}px 0 0 -{0}px"</span>, round(+size || <span class="number">1.5</span>));
        } <span class="keyword">else</span> {
            s.filter = f;
            s.margin = <span class="number">0</span>;
            <span class="keyword">delete</span> <span class="keyword">this</span>.attrs.blur;
        }
        <span class="keyword">return</span> <span class="keyword">this</span>;
    };

    R._engine.path = <span class="function"><span class="keyword">function</span> <span class="params">(pathString, vml)</span> {</span>
        <span class="keyword">var</span> el = createNode(<span class="string">"shape"</span>);
        el.style.cssText = cssDot;
        el.coordsize = zoom + S + zoom;
        el.coordorigin = vml.coordorigin;
        <span class="keyword">var</span> p = <span class="keyword">new</span> Element(el, vml),
            attr = {fill: <span class="string">"none"</span>, stroke: <span class="string">"#000"</span>};
        pathString &amp;&amp; (attr.path = pathString);
        p.type = <span class="string">"path"</span>;
        p.path = [];
        p.Path = E;
        setFillAndStroke(p, attr);
        vml.canvas.appendChild(el);
        <span class="keyword">var</span> skew = createNode(<span class="string">"skew"</span>);
        skew.on = <span class="literal">true</span>;
        el.appendChild(skew);
        p.skew = skew;
        p.transform(E);
        <span class="keyword">return</span> p;
    };
    R._engine.rect = <span class="function"><span class="keyword">function</span> <span class="params">(vml, x, y, w, h, r)</span> {</span>
        <span class="keyword">var</span> path = R._rectPath(x, y, w, h, r),
            res = vml.path(path),
            a = res.attrs;
        res.X = a.x = x;
        res.Y = a.y = y;
        res.W = a.width = w;
        res.H = a.height = h;
        a.r = r;
        a.path = path;
        res.type = <span class="string">"rect"</span>;
        <span class="keyword">return</span> res;
    };
    R._engine.ellipse = <span class="function"><span class="keyword">function</span> <span class="params">(vml, x, y, rx, ry)</span> {</span>
        <span class="keyword">var</span> res = vml.path(),
            a = res.attrs;
        res.X = x - rx;
        res.Y = y - ry;
        res.W = rx * <span class="number">2</span>;
        res.H = ry * <span class="number">2</span>;
        res.type = <span class="string">"ellipse"</span>;
        setFillAndStroke(res, {
            cx: x,
            cy: y,
            rx: rx,
            ry: ry
        });
        <span class="keyword">return</span> res;
    };
    R._engine.circle = <span class="function"><span class="keyword">function</span> <span class="params">(vml, x, y, r)</span> {</span>
        <span class="keyword">var</span> res = vml.path(),
            a = res.attrs;
        res.X = x - r;
        res.Y = y - r;
        res.W = res.H = r * <span class="number">2</span>;
        res.type = <span class="string">"circle"</span>;
        setFillAndStroke(res, {
            cx: x,
            cy: y,
            r: r
        });
        <span class="keyword">return</span> res;
    };
    R._engine.image = <span class="function"><span class="keyword">function</span> <span class="params">(vml, src, x, y, w, h)</span> {</span>
        <span class="keyword">var</span> path = R._rectPath(x, y, w, h),
            res = vml.path(path).attr({stroke: <span class="string">"none"</span>}),
            a = res.attrs,
            node = res.node,
            fill = node.getElementsByTagName(fillString)[<span class="number">0</span>];
        a.src = src;
        res.X = a.x = x;
        res.Y = a.y = y;
        res.W = a.width = w;
        res.H = a.height = h;
        a.path = path;
        res.type = <span class="string">"image"</span>;
        fill.parentNode == node &amp;&amp; node.removeChild(fill);
        fill.rotate = <span class="literal">true</span>;
        fill.src = src;
        fill.type = <span class="string">"tile"</span>;
        res._.fillpos = [x, y];
        res._.fillsize = [w, h];
        node.appendChild(fill);
        setCoords(res, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);
        <span class="keyword">return</span> res;
    };
    R._engine.text = <span class="function"><span class="keyword">function</span> <span class="params">(vml, x, y, text)</span> {</span>
        <span class="keyword">var</span> el = createNode(<span class="string">"shape"</span>),
            path = createNode(<span class="string">"path"</span>),
            o = createNode(<span class="string">"textpath"</span>);
        x = x || <span class="number">0</span>;
        y = y || <span class="number">0</span>;
        text = text || <span class="string">""</span>;
        path.v = R.format(<span class="string">"m{0},{1}l{2},{1}"</span>, round(x * zoom), round(y * zoom), round(x * zoom) + <span class="number">1</span>);
        path.textpathok = <span class="literal">true</span>;
        o.string = Str(text);
        o.on = <span class="literal">true</span>;
        el.style.cssText = cssDot;
        el.coordsize = zoom + S + zoom;
        el.coordorigin = <span class="string">"0 0"</span>;
        <span class="keyword">var</span> p = <span class="keyword">new</span> Element(el, vml),
            attr = {
                fill: <span class="string">"#000"</span>,
                stroke: <span class="string">"none"</span>,
                font: R._availableAttrs.font,
                text: text
            };
        p.shape = el;
        p.path = path;
        p.textpath = o;
        p.type = <span class="string">"text"</span>;
        p.attrs.text = Str(text);
        p.attrs.x = x;
        p.attrs.y = y;
        p.attrs.w = <span class="number">1</span>;
        p.attrs.h = <span class="number">1</span>;
        setFillAndStroke(p, attr);
        el.appendChild(o);
        el.appendChild(path);
        vml.canvas.appendChild(el);
        <span class="keyword">var</span> skew = createNode(<span class="string">"skew"</span>);
        skew.on = <span class="literal">true</span>;
        el.appendChild(skew);
        p.skew = skew;
        p.transform(E);
        <span class="keyword">return</span> p;
    };
    R._engine.setSize = <span class="function"><span class="keyword">function</span> <span class="params">(width, height)</span> {</span>
        <span class="keyword">var</span> cs = <span class="keyword">this</span>.canvas.style;
        <span class="keyword">this</span>.width = width;
        <span class="keyword">this</span>.height = height;
        width == +width &amp;&amp; (width += <span class="string">"px"</span>);
        height == +height &amp;&amp; (height += <span class="string">"px"</span>);
        cs.width = width;
        cs.height = height;
        cs.clip = <span class="string">"rect(0 "</span> + width + <span class="string">" "</span> + height + <span class="string">" 0)"</span>;
        <span class="keyword">if</span> (<span class="keyword">this</span>._viewBox) {
            R._engine.setViewBox.apply(<span class="keyword">this</span>, <span class="keyword">this</span>._viewBox);
        }
        <span class="keyword">return</span> <span class="keyword">this</span>;
    };
    R._engine.setViewBox = <span class="function"><span class="keyword">function</span> <span class="params">(x, y, w, h, fit)</span> {</span>
        R.eve(<span class="string">"raphael.setViewBox"</span>, <span class="keyword">this</span>, <span class="keyword">this</span>._viewBox, [x, y, w, h, fit]);
        <span class="keyword">var</span> width = <span class="keyword">this</span>.width,
            height = <span class="keyword">this</span>.height,
            size = <span class="number">1</span> / mmax(w / width, h / height),
            H, W;
        <span class="keyword">if</span> (fit) {
            H = height / h;
            W = width / w;
            <span class="keyword">if</span> (w * H &lt; width) {
                x -= (width - w * H) / <span class="number">2</span> / H;
            }
            <span class="keyword">if</span> (h * W &lt; height) {
                y -= (height - h * W) / <span class="number">2</span> / W;
            }
        }
        <span class="keyword">this</span>._viewBox = [x, y, w, h, !!fit];
        <span class="keyword">this</span>._viewBoxShift = {
            dx: -x,
            dy: -y,
            scale: size
        };
        <span class="keyword">this</span>.forEach(<span class="function"><span class="keyword">function</span> <span class="params">(el)</span> {</span>
            el.transform(<span class="string">"..."</span>);
        });
        <span class="keyword">return</span> <span class="keyword">this</span>;
    };
    <span class="keyword">var</span> createNode;
    R._engine.initWin = <span class="function"><span class="keyword">function</span> <span class="params">(win)</span> {</span>
            <span class="keyword">var</span> doc = win.document;
            doc.createStyleSheet().addRule(<span class="string">".rvml"</span>, <span class="string">"behavior:url(#default#VML)"</span>);
            <span class="keyword">try</span> {
                !doc.namespaces.rvml &amp;&amp; doc.namespaces.add(<span class="string">"rvml"</span>, <span class="string">"urn:schemas-microsoft-com:vml"</span>);
                createNode = <span class="function"><span class="keyword">function</span> <span class="params">(tagName)</span> {</span>
                    <span class="keyword">return</span> doc.createElement(<span class="string">'&lt;rvml:'</span> + tagName + <span class="string">' class="rvml"&gt;'</span>);
                };
            } <span class="keyword">catch</span> (e) {
                createNode = <span class="function"><span class="keyword">function</span> <span class="params">(tagName)</span> {</span>
                    <span class="keyword">return</span> doc.createElement(<span class="string">'&lt;'</span> + tagName + <span class="string">' xmlns="urn:schemas-microsoft.com:vml" class="rvml"&gt;'</span>);
                };
            }
        };
    R._engine.initWin(R._g.win);
    R._engine.create = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">var</span> con = R._getContainer.apply(<span class="number">0</span>, arguments),
            container = con.container,
            height = con.height,
            s,
            width = con.width,
            x = con.x,
            y = con.y;
        <span class="keyword">if</span> (!container) {
            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"VML container not found."</span>);
        }
        <span class="keyword">var</span> res = <span class="keyword">new</span> R._Paper,
            c = res.canvas = R._g.doc.createElement(<span class="string">"div"</span>),
            cs = c.style;
        x = x || <span class="number">0</span>;
        y = y || <span class="number">0</span>;
        width = width || <span class="number">512</span>;
        height = height || <span class="number">342</span>;
        res.width = width;
        res.height = height;
        width == +width &amp;&amp; (width += <span class="string">"px"</span>);
        height == +height &amp;&amp; (height += <span class="string">"px"</span>);
        res.coordsize = zoom * <span class="number">1e3</span> + S + zoom * <span class="number">1e3</span>;
        res.coordorigin = <span class="string">"0 0"</span>;
        res.span = R._g.doc.createElement(<span class="string">"span"</span>);
        res.span.style.cssText = <span class="string">"position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;"</span>;
        c.appendChild(res.span);
        cs.cssText = R.format(<span class="string">"top:0;left:0;width:{0};height:{1};display:inline-block;position:relative;clip:rect(0 {0} {1} 0);overflow:hidden"</span>, width, height);
        <span class="keyword">if</span> (container == <span class="number">1</span>) {
            R._g.doc.body.appendChild(c);
            cs.left = x + <span class="string">"px"</span>;
            cs.top = y + <span class="string">"px"</span>;
            cs.position = <span class="string">"absolute"</span>;
        } <span class="keyword">else</span> {
            <span class="keyword">if</span> (container.firstChild) {
                container.insertBefore(c, container.firstChild);
            } <span class="keyword">else</span> {
                container.appendChild(c);
            }
        }
        res.renderfix = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>};
        <span class="keyword">return</span> res;
    };
    R.prototype.clear = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        R.eve(<span class="string">"raphael.clear"</span>, <span class="keyword">this</span>);
        <span class="keyword">this</span>.canvas.innerHTML = E;
        <span class="keyword">this</span>.span = R._g.doc.createElement(<span class="string">"span"</span>);
        <span class="keyword">this</span>.span.style.cssText = <span class="string">"position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;display:inline;"</span>;
        <span class="keyword">this</span>.canvas.appendChild(<span class="keyword">this</span>.span);
        <span class="keyword">this</span>.bottom = <span class="keyword">this</span>.top = <span class="literal">null</span>;
    };
    R.prototype.remove = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        R.eve(<span class="string">"raphael.remove"</span>, <span class="keyword">this</span>);
        <span class="keyword">this</span>.canvas.parentNode.removeChild(<span class="keyword">this</span>.canvas);
        <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> <span class="keyword">this</span>) {
            <span class="keyword">this</span>[i] = <span class="keyword">typeof</span> <span class="keyword">this</span>[i] == <span class="string">"function"</span> ? R._removedFactory(i) : <span class="literal">null</span>;
        }
        <span class="keyword">return</span> <span class="literal">true</span>;
    };

    <span class="keyword">var</span> setproto = R.st;
    <span class="keyword">for</span> (<span class="keyword">var</span> method <span class="keyword">in</span> elproto) <span class="keyword">if</span> (elproto[has](method) &amp;&amp; !setproto[has](method)) {
        setproto[method] = (<span class="function"><span class="keyword">function</span> <span class="params">(methodname)</span> {</span>
            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
                <span class="keyword">var</span> arg = arguments;
                <span class="keyword">return</span> <span class="keyword">this</span>.forEach(<span class="function"><span class="keyword">function</span> <span class="params">(el)</span> {</span>
                    el[methodname].apply(el, arg);
                });
            };
        })(method);
    }
})();</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>EXPOSE
SVG and VML are appended just before the EXPOSE line
Even with AMD, Raphael should be defined globally</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    oldRaphael.was ? (g.win.Raphael = R) : (Raphael = R);

    <span class="keyword">return</span> R;
}));</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
