<!DOCTYPE html>

<html>
<head>
  <title>chai.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="app.html">
                app.js
              </a>
            
              
              <a class="source" href="days-collection.html">
                days-collection.js
              </a>
            
              
              <a class="source" href="main.html">
                main.js
              </a>
            
              
              <a class="source" href="day-model.html">
                day-model.js
              </a>
            
              
              <a class="source" href="router.html">
                router.js
              </a>
            
              
              <a class="source" href="days-collection-test.html">
                days-collection-test.js
              </a>
            
              
              <a class="source" href="day-model-test.html">
                day-model-test.js
              </a>
            
              
              <a class="source" href="backbone.html">
                backbone.js
              </a>
            
              
              <a class="source" href="bootstrap.html">
                bootstrap.js
              </a>
            
              
              <a class="source" href="chai.html">
                chai.js
              </a>
            
              
              <a class="source" href="jquery.html">
                jquery.js
              </a>
            
              
              <a class="source" href="mocha.html">
                mocha.js
              </a>
            
              
              <a class="source" href="raphael.html">
                raphael.js
              </a>
            
              
              <a class="source" href="require.html">
                require.js
              </a>
            
              
              <a class="source" href="text.html">
                text.js
              </a>
            
              
              <a class="source" href="underscore.html">
                underscore.js
              </a>
            
              
              <a class="source" href="chart-view.html">
                chart-view.js
              </a>
            
              
              <a class="source" href="default-view.html">
                default-view.js
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>chai.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>;(<span class="keyword">function</span>(){

<span class="comment">/**
 * Require the given path.
 *
 * @param {String} path
 * @return {Object} exports
 * @api public
 */</span>

<span class="function"><span class="keyword">function</span> <span class="title">require</span><span class="params">(path, parent, orig)</span> {</span>
  <span class="keyword">var</span> resolved = require.resolve(path);</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>lookup failed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">if</span> (<span class="literal">null</span> == resolved) {
    orig = orig || path;
    parent = parent || <span class="string">'root'</span>;
    <span class="keyword">var</span> err = <span class="keyword">new</span> Error(<span class="string">'Failed to require "'</span> + orig + <span class="string">'" from "'</span> + parent + <span class="string">'"'</span>);
    err.path = orig;
    err.parent = parent;
    err.require = <span class="literal">true</span>;
    <span class="keyword">throw</span> err;
  }

  <span class="keyword">var</span> module = require.modules[resolved];</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>perform real require()
by invoking the module&#39;s
registered function</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">if</span> (!module.exports) {
    module.exports = {};
    module.client = module.component = <span class="literal">true</span>;
    module.call(<span class="keyword">this</span>, module.exports, require.relative(resolved), module);
  }

  <span class="keyword">return</span> module.exports;
}

<span class="comment">/**
 * Registered modules.
 */</span>

require.modules = {};

<span class="comment">/**
 * Registered aliases.
 */</span>

require.aliases = {};

<span class="comment">/**
 * Resolve `path`.
 *
 * Lookup:
 *
 *   - PATH/index.js
 *   - PATH.js
 *   - PATH
 *
 * @param {String} path
 * @return {String} path or null
 * @api private
 */</span>

require.resolve = <span class="keyword">function</span>(path) {
  <span class="keyword">if</span> (path.charAt(<span class="number">0</span>) === <span class="string">'/'</span>) path = path.slice(<span class="number">1</span>);

  <span class="keyword">var</span> paths = [
    path,
    path + <span class="string">'.js'</span>,
    path + <span class="string">'.json'</span>,
    path + <span class="string">'/index.js'</span>,
    path + <span class="string">'/index.json'</span>
  ];

  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; paths.length; i++) {
    <span class="keyword">var</span> path = paths[i];
    <span class="keyword">if</span> (require.modules.hasOwnProperty(path)) <span class="keyword">return</span> path;
    <span class="keyword">if</span> (require.aliases.hasOwnProperty(path)) <span class="keyword">return</span> require.aliases[path];
  }
};

<span class="comment">/**
 * Normalize `path` relative to the current path.
 *
 * @param {String} curr
 * @param {String} path
 * @return {String}
 * @api private
 */</span>

require.normalize = <span class="keyword">function</span>(curr, path) {
  <span class="keyword">var</span> segs = [];

  <span class="keyword">if</span> (<span class="string">'.'</span> != path.charAt(<span class="number">0</span>)) <span class="keyword">return</span> path;

  curr = curr.split(<span class="string">'/'</span>);
  path = path.split(<span class="string">'/'</span>);

  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; path.length; ++i) {
    <span class="keyword">if</span> (<span class="string">'..'</span> == path[i]) {
      curr.pop();
    } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">'.'</span> != path[i] &amp;&amp; <span class="string">''</span> != path[i]) {
      segs.push(path[i]);
    }
  }

  <span class="keyword">return</span> curr.concat(segs).join(<span class="string">'/'</span>);
};

<span class="comment">/**
 * Register module at `path` with callback `definition`.
 *
 * @param {String} path
 * @param {Function} definition
 * @api private
 */</span>

require.register = <span class="keyword">function</span>(path, definition) {
  require.modules[path] = definition;
};

<span class="comment">/**
 * Alias a module definition.
 *
 * @param {String} from
 * @param {String} to
 * @api private
 */</span>

require.alias = <span class="keyword">function</span>(from, to) {
  <span class="keyword">if</span> (!require.modules.hasOwnProperty(from)) {
    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'Failed to alias "'</span> + from + <span class="string">'", it does not exist'</span>);
  }
  require.aliases[to] = from;
};

<span class="comment">/**
 * Return a require function relative to the `parent` path.
 *
 * @param {String} parent
 * @return {Function}
 * @api private
 */</span>

require.relative = <span class="keyword">function</span>(parent) {
  <span class="keyword">var</span> p = require.normalize(parent, <span class="string">'..'</span>);

  <span class="comment">/**
   * lastIndexOf helper.
   */</span>

  <span class="function"><span class="keyword">function</span> <span class="title">lastIndexOf</span><span class="params">(arr, obj)</span> {</span>
    <span class="keyword">var</span> i = arr.length;
    <span class="keyword">while</span> (i--) {
      <span class="keyword">if</span> (arr[i] === obj) <span class="keyword">return</span> i;
    }
    <span class="keyword">return</span> -<span class="number">1</span>;
  }

  <span class="comment">/**
   * The relative require() itself.
   */</span>

  <span class="function"><span class="keyword">function</span> <span class="title">localRequire</span><span class="params">(path)</span> {</span>
    <span class="keyword">var</span> resolved = localRequire.resolve(path);
    <span class="keyword">return</span> require(resolved, parent, path);
  }

  <span class="comment">/**
   * Resolve relative to the parent.
   */</span>

  localRequire.resolve = <span class="keyword">function</span>(path) {
    <span class="keyword">var</span> c = path.charAt(<span class="number">0</span>);
    <span class="keyword">if</span> (<span class="string">'/'</span> == c) <span class="keyword">return</span> path.slice(<span class="number">1</span>);
    <span class="keyword">if</span> (<span class="string">'.'</span> == c) <span class="keyword">return</span> require.normalize(p, path);</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>resolve deps by returning
the dep in the nearest &quot;deps&quot;
directory</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> segs = parent.split(<span class="string">'/'</span>);
    <span class="keyword">var</span> i = lastIndexOf(segs, <span class="string">'deps'</span>) + <span class="number">1</span>;
    <span class="keyword">if</span> (!i) i = <span class="number">0</span>;
    path = segs.slice(<span class="number">0</span>, i + <span class="number">1</span>).join(<span class="string">'/'</span>) + <span class="string">'/deps/'</span> + path;
    <span class="keyword">return</span> path;
  };

  <span class="comment">/**
   * Check if module is defined at `path`.
   */</span>

  localRequire.exists = <span class="keyword">function</span>(path) {
    <span class="keyword">return</span> require.modules.hasOwnProperty(localRequire.resolve(path));
  };

  <span class="keyword">return</span> localRequire;
};
require.register(<span class="string">"chaijs-assertion-error/index.js"</span>, <span class="keyword">function</span>(exports, require, module){
<span class="comment">/*!
 * assertion-error
 * Copyright(c) 2013 Jake Luer &lt;jake@qualiancy.com&gt;
 * MIT Licensed
 */</span>

<span class="comment">/*!
 * Return a function that will copy properties from
 * one object to another excluding any originally
 * listed. Returned function will create a new `{}`.
 *
 * @param {String} excluded properties ...
 * @return {Function}
 */</span>

<span class="function"><span class="keyword">function</span> <span class="title">exclude</span> <span class="params">()</span> {</span>
  <span class="keyword">var</span> excludes = [].slice.call(arguments);

  <span class="function"><span class="keyword">function</span> <span class="title">excludeProps</span> <span class="params">(res, obj)</span> {</span>
    Object.keys(obj).forEach(<span class="function"><span class="keyword">function</span> <span class="params">(key)</span> {</span>
      <span class="keyword">if</span> (!~excludes.indexOf(key)) res[key] = obj[key];
    });
  }

  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">extendExclude</span> <span class="params">()</span> {</span>
    <span class="keyword">var</span> args = [].slice.call(arguments)
      , i = <span class="number">0</span>
      , res = {};

    <span class="keyword">for</span> (; i &lt; args.length; i++) {
      excludeProps(res, args[i]);
    }

    <span class="keyword">return</span> res;
  };
};

<span class="comment">/*!
 * Primary Exports
 */</span>

module.exports = AssertionError;

<span class="comment">/**
 * ### AssertionError
 *
 * An extension of the JavaScript `Error` constructor for
 * assertion and validation scenarios.
 *
 * @param {String} message
 * @param {Object} properties to include (optional)
 * @param {callee} start stack function (optional)
 */</span>

<span class="function"><span class="keyword">function</span> <span class="title">AssertionError</span> <span class="params">(message, _props, ssf)</span> {</span>
  <span class="keyword">var</span> extend = exclude(<span class="string">'name'</span>, <span class="string">'message'</span>, <span class="string">'stack'</span>, <span class="string">'constructor'</span>, <span class="string">'toJSON'</span>)
    , props = extend(_props || {});</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>default values</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">this</span>.message = message || <span class="string">'Unspecified AssertionError'</span>;
  <span class="keyword">this</span>.showDiff = <span class="literal">false</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>copy from properties</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> props) {
    <span class="keyword">this</span>[key] = props[key];
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>capture stack trace</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  ssf = ssf || arguments.callee;
  <span class="keyword">if</span> (ssf &amp;&amp; Error.captureStackTrace) {
    Error.captureStackTrace(<span class="keyword">this</span>, ssf);
  }
}

<span class="comment">/*!
 * Inherit from Error.prototype
 */</span>

AssertionError.prototype = Object.create(Error.prototype);

<span class="comment">/*!
 * Statically set name
 */</span>

AssertionError.prototype.name = <span class="string">'AssertionError'</span>;

<span class="comment">/*!
 * Ensure correct constructor
 */</span>

AssertionError.prototype.constructor = AssertionError;

<span class="comment">/**
 * Allow errors to be converted to JSON for static transfer.
 *
 * @param {Boolean} include stack (default: `true`)
 * @return {Object} object that can be `JSON.stringify`
 */</span>

AssertionError.prototype.toJSON = <span class="function"><span class="keyword">function</span> <span class="params">(stack)</span> {</span>
  <span class="keyword">var</span> extend = exclude(<span class="string">'constructor'</span>, <span class="string">'toJSON'</span>, <span class="string">'stack'</span>)
    , props = extend({ name: <span class="keyword">this</span>.name }, <span class="keyword">this</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>include stack if exists and not turned off</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">if</span> (<span class="literal">false</span> !== stack &amp;&amp; <span class="keyword">this</span>.stack) {
    props.stack = <span class="keyword">this</span>.stack;
  }

  <span class="keyword">return</span> props;
};

});
require.register(<span class="string">"chai/index.js"</span>, <span class="keyword">function</span>(exports, require, module){
module.exports = require(<span class="string">'./lib/chai'</span>);

});
require.register(<span class="string">"chai/lib/chai.js"</span>, <span class="keyword">function</span>(exports, require, module){
<span class="comment">/*!
 * chai
 * Copyright(c) 2011-2013 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */</span>

<span class="keyword">var</span> used = []
  , exports = module.exports = {};

<span class="comment">/*!
 * Chai version
 */</span>

exports.version = <span class="string">'1.6.1'</span>;

<span class="comment">/*!
 * Assertion Error
 */</span>

exports.AssertionError = require(<span class="string">'assertion-error'</span>);

<span class="comment">/*!
 * Utils for plugins (not exported)
 */</span>

<span class="keyword">var</span> util = require(<span class="string">'./chai/utils'</span>);

<span class="comment">/**
 * # .use(function)
 *
 * Provides a way to extend the internals of Chai
 *
 * @param {Function}
 * @returns {this} for chaining
 * @api public
 */</span>

exports.use = <span class="function"><span class="keyword">function</span> <span class="params">(fn)</span> {</span>
  <span class="keyword">if</span> (!~used.indexOf(fn)) {
    fn(<span class="keyword">this</span>, util);
    used.push(fn);
  }

  <span class="keyword">return</span> <span class="keyword">this</span>;
};

<span class="comment">/*!
 * Primary `Assertion` prototype
 */</span>

<span class="keyword">var</span> assertion = require(<span class="string">'./chai/assertion'</span>);
exports.use(assertion);

<span class="comment">/*!
 * Core Assertions
 */</span>

<span class="keyword">var</span> core = require(<span class="string">'./chai/core/assertions'</span>);
exports.use(core);

<span class="comment">/*!
 * Expect interface
 */</span>

<span class="keyword">var</span> expect = require(<span class="string">'./chai/interface/expect'</span>);
exports.use(expect);

<span class="comment">/*!
 * Should interface
 */</span>

<span class="keyword">var</span> should = require(<span class="string">'./chai/interface/should'</span>);
exports.use(should);

<span class="comment">/*!
 * Assert interface
 */</span>

<span class="keyword">var</span> assert = require(<span class="string">'./chai/interface/assert'</span>);
exports.use(assert);

});
require.register(<span class="string">"chai/lib/chai/assertion.js"</span>, <span class="keyword">function</span>(exports, require, module){
<span class="comment">/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2013 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */</span>

module.exports = <span class="function"><span class="keyword">function</span> <span class="params">(_chai, util)</span> {</span>
  <span class="comment">/*!
   * Module dependencies.
   */</span>

  <span class="keyword">var</span> AssertionError = _chai.AssertionError
    , flag = util.flag;

  <span class="comment">/*!
   * Module export.
   */</span>

  _chai.Assertion = Assertion;

  <span class="comment">/*!
   * Assertion Constructor
   *
   * Creates object for chaining.
   *
   * @api private
   */</span>

  <span class="function"><span class="keyword">function</span> <span class="title">Assertion</span> <span class="params">(obj, msg, stack)</span> {</span>
    flag(<span class="keyword">this</span>, <span class="string">'ssfi'</span>, stack || arguments.callee);
    flag(<span class="keyword">this</span>, <span class="string">'object'</span>, obj);
    flag(<span class="keyword">this</span>, <span class="string">'message'</span>, msg);
  }

  <span class="comment">/*!
    * ### Assertion.includeStack
    *
    * User configurable property, influences whether stack trace
    * is included in Assertion error message. Default of false
    * suppresses stack trace in the error message
    *
    *     Assertion.includeStack = true;  // enable stack on error
    *
    * @api public
    */</span>

  Assertion.includeStack = <span class="literal">false</span>;

  <span class="comment">/*!
   * ### Assertion.showDiff
   *
   * User configurable property, influences whether or not
   * the `showDiff` flag should be included in the thrown
   * AssertionErrors. `false` will always be `false`; `true`
   * will be true when the assertion has requested a diff
   * be shown.
   *
   * @api public
   */</span>

  Assertion.showDiff = <span class="literal">true</span>;

  Assertion.addProperty = <span class="function"><span class="keyword">function</span> <span class="params">(name, fn)</span> {</span>
    util.addProperty(<span class="keyword">this</span>.prototype, name, fn);
  };

  Assertion.addMethod = <span class="function"><span class="keyword">function</span> <span class="params">(name, fn)</span> {</span>
    util.addMethod(<span class="keyword">this</span>.prototype, name, fn);
  };

  Assertion.addChainableMethod = <span class="function"><span class="keyword">function</span> <span class="params">(name, fn, chainingBehavior)</span> {</span>
    util.addChainableMethod(<span class="keyword">this</span>.prototype, name, fn, chainingBehavior);
  };

  Assertion.overwriteProperty = <span class="function"><span class="keyword">function</span> <span class="params">(name, fn)</span> {</span>
    util.overwriteProperty(<span class="keyword">this</span>.prototype, name, fn);
  };

  Assertion.overwriteMethod = <span class="function"><span class="keyword">function</span> <span class="params">(name, fn)</span> {</span>
    util.overwriteMethod(<span class="keyword">this</span>.prototype, name, fn);
  };

  <span class="comment">/*!
   * ### .assert(expression, message, negateMessage, expected, actual)
   *
   * Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass.
   *
   * @name assert
   * @param {Philosophical} expression to be tested
   * @param {String} message to display if fails
   * @param {String} negatedMessage to display if negated expression fails
   * @param {Mixed} expected value (remember to check for negation)
   * @param {Mixed} actual (optional) will default to `this.obj`
   * @api private
   */</span>

  Assertion.prototype.assert = <span class="function"><span class="keyword">function</span> <span class="params">(expr, msg, negateMsg, expected, _actual, showDiff)</span> {</span>
    <span class="keyword">var</span> ok = util.test(<span class="keyword">this</span>, arguments);
    <span class="keyword">if</span> (<span class="literal">true</span> !== showDiff) showDiff = <span class="literal">false</span>;
    <span class="keyword">if</span> (<span class="literal">true</span> !== Assertion.showDiff) showDiff = <span class="literal">false</span>;

    <span class="keyword">if</span> (!ok) {
      <span class="keyword">var</span> msg = util.getMessage(<span class="keyword">this</span>, arguments)
        , actual = util.getActual(<span class="keyword">this</span>, arguments);
      <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(msg, {
          actual: actual
        , expected: expected
        , showDiff: showDiff
      }, (Assertion.includeStack) ? <span class="keyword">this</span>.assert : flag(<span class="keyword">this</span>, <span class="string">'ssfi'</span>));
    }
  };

  <span class="comment">/*!
   * ### ._obj
   *
   * Quick reference to stored `actual` value for plugin developers.
   *
   * @api private
   */</span>

  Object.defineProperty(Assertion.prototype, <span class="string">'_obj'</span>,
    { get: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">return</span> flag(<span class="keyword">this</span>, <span class="string">'object'</span>);
      }
    , set: <span class="function"><span class="keyword">function</span> <span class="params">(val)</span> {</span>
        flag(<span class="keyword">this</span>, <span class="string">'object'</span>, val);
      }
  });
};

});
require.register(<span class="string">"chai/lib/chai/core/assertions.js"</span>, <span class="keyword">function</span>(exports, require, module){
<span class="comment">/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2013 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */</span>

module.exports = <span class="function"><span class="keyword">function</span> <span class="params">(chai, _)</span> {</span>
  <span class="keyword">var</span> Assertion = chai.Assertion
    , toString = Object.prototype.toString
    , flag = _.flag;

  <span class="comment">/**
   * ### Language Chains
   *
   * The following are provide as chainable getters to
   * improve the readability of your assertions. They
   * do not provide an testing capability unless they
   * have been overwritten by a plugin.
   *
   * **Chains**
   *
   * - to
   * - be
   * - been
   * - is
   * - that
   * - and
   * - have
   * - with
   * - at
   * - of
   * - same
   *
   * @name language chains
   * @api public
   */</span>

  [ <span class="string">'to'</span>, <span class="string">'be'</span>, <span class="string">'been'</span>
  , <span class="string">'is'</span>, <span class="string">'and'</span>, <span class="string">'have'</span>
  , <span class="string">'with'</span>, <span class="string">'that'</span>, <span class="string">'at'</span>
  , <span class="string">'of'</span>, <span class="string">'same'</span> ].forEach(<span class="function"><span class="keyword">function</span> <span class="params">(chain)</span> {</span>
    Assertion.addProperty(chain, <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
      <span class="keyword">return</span> <span class="keyword">this</span>;
    });
  });

  <span class="comment">/**
   * ### .not
   *
   * Negates any of assertions following in the chain.
   *
   *     expect(foo).to.not.equal('bar');
   *     expect(goodFn).to.not.throw(Error);
   *     expect({ foo: 'baz' }).to.have.property('foo')
   *       .and.not.equal('bar');
   *
   * @name not
   * @api public
   */</span>

  Assertion.addProperty(<span class="string">'not'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    flag(<span class="keyword">this</span>, <span class="string">'negate'</span>, <span class="literal">true</span>);
  });

  <span class="comment">/**
   * ### .deep
   *
   * Sets the `deep` flag, later used by the `equal` and
   * `property` assertions.
   *
   *     expect(foo).to.deep.equal({ bar: 'baz' });
   *     expect({ foo: { bar: { baz: 'quux' } } })
   *       .to.have.deep.property('foo.bar.baz', 'quux');
   *
   * @name deep
   * @api public
   */</span>

  Assertion.addProperty(<span class="string">'deep'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    flag(<span class="keyword">this</span>, <span class="string">'deep'</span>, <span class="literal">true</span>);
  });

  <span class="comment">/**
   * ### .a(type)
   *
   * The `a` and `an` assertions are aliases that can be
   * used either as language chains or to assert a value's
   * type.
   *
   *     // typeof
   *     expect('test').to.be.a('string');
   *     expect({ foo: 'bar' }).to.be.an('object');
   *     expect(null).to.be.a('null');
   *     expect(undefined).to.be.an('undefined');
   *
   *     // language chain
   *     expect(foo).to.be.an.instanceof(Foo);
   *
   * @name a
   * @alias an
   * @param {String} type
   * @param {String} message _optional_
   * @api public
   */</span>

  <span class="function"><span class="keyword">function</span> <span class="title">an</span> <span class="params">(type, msg)</span> {</span>
    <span class="keyword">if</span> (msg) flag(<span class="keyword">this</span>, <span class="string">'message'</span>, msg);
    type = type.toLowerCase();
    <span class="keyword">var</span> obj = flag(<span class="keyword">this</span>, <span class="string">'object'</span>)
      , article = ~[ <span class="string">'a'</span>, <span class="string">'e'</span>, <span class="string">'i'</span>, <span class="string">'o'</span>, <span class="string">'u'</span> ].indexOf(type.charAt(<span class="number">0</span>)) ? <span class="string">'an '</span> : <span class="string">'a '</span>;

    <span class="keyword">this</span>.assert(
        type === _.type(obj)
      , <span class="string">'expected #{this} to be '</span> + article + type
      , <span class="string">'expected #{this} not to be '</span> + article + type
    );
  }

  Assertion.addChainableMethod(<span class="string">'an'</span>, an);
  Assertion.addChainableMethod(<span class="string">'a'</span>, an);

  <span class="comment">/**
   * ### .include(value)
   *
   * The `include` and `contain` assertions can be used as either property
   * based language chains or as methods to assert the inclusion of an object
   * in an array or a substring in a string. When used as language chains,
   * they toggle the `contain` flag for the `keys` assertion.
   *
   *     expect([1,2,3]).to.include(2);
   *     expect('foobar').to.contain('foo');
   *     expect({ foo: 'bar', hello: 'universe' }).to.include.keys('foo');
   *
   * @name include
   * @alias contain
   * @param {Object|String|Number} obj
   * @param {String} message _optional_
   * @api public
   */</span>

  <span class="function"><span class="keyword">function</span> <span class="title">includeChainingBehavior</span> <span class="params">()</span> {</span>
    flag(<span class="keyword">this</span>, <span class="string">'contains'</span>, <span class="literal">true</span>);
  }

  <span class="function"><span class="keyword">function</span> <span class="title">include</span> <span class="params">(val, msg)</span> {</span>
    <span class="keyword">if</span> (msg) flag(<span class="keyword">this</span>, <span class="string">'message'</span>, msg);
    <span class="keyword">var</span> obj = flag(<span class="keyword">this</span>, <span class="string">'object'</span>)
    <span class="keyword">this</span>.assert(
        ~obj.indexOf(val)
      , <span class="string">'expected #{this} to include '</span> + _.inspect(val)
      , <span class="string">'expected #{this} to not include '</span> + _.inspect(val));
  }

  Assertion.addChainableMethod(<span class="string">'include'</span>, include, includeChainingBehavior);
  Assertion.addChainableMethod(<span class="string">'contain'</span>, include, includeChainingBehavior);

  <span class="comment">/**
   * ### .ok
   *
   * Asserts that the target is truthy.
   *
   *     expect('everthing').to.be.ok;
   *     expect(1).to.be.ok;
   *     expect(false).to.not.be.ok;
   *     expect(undefined).to.not.be.ok;
   *     expect(null).to.not.be.ok;
   *
   * @name ok
   * @api public
   */</span>

  Assertion.addProperty(<span class="string">'ok'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">this</span>.assert(
        flag(<span class="keyword">this</span>, <span class="string">'object'</span>)
      , <span class="string">'expected #{this} to be truthy'</span>
      , <span class="string">'expected #{this} to be falsy'</span>);
  });

  <span class="comment">/**
   * ### .true
   *
   * Asserts that the target is `true`.
   *
   *     expect(true).to.be.true;
   *     expect(1).to.not.be.true;
   *
   * @name true
   * @api public
   */</span>

  Assertion.addProperty(<span class="string">'true'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">this</span>.assert(
        <span class="literal">true</span> === flag(<span class="keyword">this</span>, <span class="string">'object'</span>)
      , <span class="string">'expected #{this} to be true'</span>
      , <span class="string">'expected #{this} to be false'</span>
      , <span class="keyword">this</span>.negate ? <span class="literal">false</span> : <span class="literal">true</span>
    );
  });

  <span class="comment">/**
   * ### .false
   *
   * Asserts that the target is `false`.
   *
   *     expect(false).to.be.false;
   *     expect(0).to.not.be.false;
   *
   * @name false
   * @api public
   */</span>

  Assertion.addProperty(<span class="string">'false'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">this</span>.assert(
        <span class="literal">false</span> === flag(<span class="keyword">this</span>, <span class="string">'object'</span>)
      , <span class="string">'expected #{this} to be false'</span>
      , <span class="string">'expected #{this} to be true'</span>
      , <span class="keyword">this</span>.negate ? <span class="literal">true</span> : <span class="literal">false</span>
    );
  });

  <span class="comment">/**
   * ### .null
   *
   * Asserts that the target is `null`.
   *
   *     expect(null).to.be.null;
   *     expect(undefined).not.to.be.null;
   *
   * @name null
   * @api public
   */</span>

  Assertion.addProperty(<span class="string">'null'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">this</span>.assert(
        <span class="literal">null</span> === flag(<span class="keyword">this</span>, <span class="string">'object'</span>)
      , <span class="string">'expected #{this} to be null'</span>
      , <span class="string">'expected #{this} not to be null'</span>
    );
  });

  <span class="comment">/**
   * ### .undefined
   *
   * Asserts that the target is `undefined`.
   *
   *      expect(undefined).to.be.undefined;
   *      expect(null).to.not.be.undefined;
   *
   * @name undefined
   * @api public
   */</span>

  Assertion.addProperty(<span class="string">'undefined'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">this</span>.assert(
        <span class="literal">undefined</span> === flag(<span class="keyword">this</span>, <span class="string">'object'</span>)
      , <span class="string">'expected #{this} to be undefined'</span>
      , <span class="string">'expected #{this} not to be undefined'</span>
    );
  });

  <span class="comment">/**
   * ### .exist
   *
   * Asserts that the target is neither `null` nor `undefined`.
   *
   *     var foo = 'hi'
   *       , bar = null
   *       , baz;
   *
   *     expect(foo).to.exist;
   *     expect(bar).to.not.exist;
   *     expect(baz).to.not.exist;
   *
   * @name exist
   * @api public
   */</span>

  Assertion.addProperty(<span class="string">'exist'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">this</span>.assert(
        <span class="literal">null</span> != flag(<span class="keyword">this</span>, <span class="string">'object'</span>)
      , <span class="string">'expected #{this} to exist'</span>
      , <span class="string">'expected #{this} to not exist'</span>
    );
  });


  <span class="comment">/**
   * ### .empty
   *
   * Asserts that the target's length is `0`. For arrays, it checks
   * the `length` property. For objects, it gets the count of
   * enumerable keys.
   *
   *     expect([]).to.be.empty;
   *     expect('').to.be.empty;
   *     expect({}).to.be.empty;
   *
   * @name empty
   * @api public
   */</span>

  Assertion.addProperty(<span class="string">'empty'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">var</span> obj = flag(<span class="keyword">this</span>, <span class="string">'object'</span>)
      , expected = obj;

    <span class="keyword">if</span> (Array.isArray(obj) || <span class="string">'string'</span> === <span class="keyword">typeof</span> object) {
      expected = obj.length;
    } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> obj === <span class="string">'object'</span>) {
      expected = Object.keys(obj).length;
    }

    <span class="keyword">this</span>.assert(
        !expected
      , <span class="string">'expected #{this} to be empty'</span>
      , <span class="string">'expected #{this} not to be empty'</span>
    );
  });

  <span class="comment">/**
   * ### .arguments
   *
   * Asserts that the target is an arguments object.
   *
   *     function test () {
   *       expect(arguments).to.be.arguments;
   *     }
   *
   * @name arguments
   * @alias Arguments
   * @api public
   */</span>

  <span class="function"><span class="keyword">function</span> <span class="title">checkArguments</span> <span class="params">()</span> {</span>
    <span class="keyword">var</span> obj = flag(<span class="keyword">this</span>, <span class="string">'object'</span>)
      , type = Object.prototype.toString.call(obj);
    <span class="keyword">this</span>.assert(
        <span class="string">'[object Arguments]'</span> === type
      , <span class="string">'expected #{this} to be arguments but got '</span> + type
      , <span class="string">'expected #{this} to not be arguments'</span>
    );
  }

  Assertion.addProperty(<span class="string">'arguments'</span>, checkArguments);
  Assertion.addProperty(<span class="string">'Arguments'</span>, checkArguments);

  <span class="comment">/**
   * ### .equal(value)
   *
   * Asserts that the target is strictly equal (`===`) to `value`.
   * Alternately, if the `deep` flag is set, asserts that
   * the target is deeply equal to `value`.
   *
   *     expect('hello').to.equal('hello');
   *     expect(42).to.equal(42);
   *     expect(1).to.not.equal(true);
   *     expect({ foo: 'bar' }).to.not.equal({ foo: 'bar' });
   *     expect({ foo: 'bar' }).to.deep.equal({ foo: 'bar' });
   *
   * @name equal
   * @alias equals
   * @alias eq
   * @alias deep.equal
   * @param {Mixed} value
   * @param {String} message _optional_
   * @api public
   */</span>

  <span class="function"><span class="keyword">function</span> <span class="title">assertEqual</span> <span class="params">(val, msg)</span> {</span>
    <span class="keyword">if</span> (msg) flag(<span class="keyword">this</span>, <span class="string">'message'</span>, msg);
    <span class="keyword">var</span> obj = flag(<span class="keyword">this</span>, <span class="string">'object'</span>);
    <span class="keyword">if</span> (flag(<span class="keyword">this</span>, <span class="string">'deep'</span>)) {
      <span class="keyword">return</span> <span class="keyword">this</span>.eql(val);
    } <span class="keyword">else</span> {
      <span class="keyword">this</span>.assert(
          val === obj
        , <span class="string">'expected #{this} to equal #{exp}'</span>
        , <span class="string">'expected #{this} to not equal #{exp}'</span>
        , val
        , <span class="keyword">this</span>._obj
        , <span class="literal">true</span>
      );
    }
  }

  Assertion.addMethod(<span class="string">'equal'</span>, assertEqual);
  Assertion.addMethod(<span class="string">'equals'</span>, assertEqual);
  Assertion.addMethod(<span class="string">'eq'</span>, assertEqual);

  <span class="comment">/**
   * ### .eql(value)
   *
   * Asserts that the target is deeply equal to `value`.
   *
   *     expect({ foo: 'bar' }).to.eql({ foo: 'bar' });
   *     expect([ 1, 2, 3 ]).to.eql([ 1, 2, 3 ]);
   *
   * @name eql
   * @alias eqls
   * @param {Mixed} value
   * @param {String} message _optional_
   * @api public
   */</span>

  <span class="function"><span class="keyword">function</span> <span class="title">assertEql</span><span class="params">(obj, msg)</span> {</span>
    <span class="keyword">if</span> (msg) flag(<span class="keyword">this</span>, <span class="string">'message'</span>, msg);
    <span class="keyword">this</span>.assert(
        _.eql(obj, flag(<span class="keyword">this</span>, <span class="string">'object'</span>))
      , <span class="string">'expected #{this} to deeply equal #{exp}'</span>
      , <span class="string">'expected #{this} to not deeply equal #{exp}'</span>
      , obj
      , <span class="keyword">this</span>._obj
      , <span class="literal">true</span>
    );
  }

  Assertion.addMethod(<span class="string">'eql'</span>, assertEql);
  Assertion.addMethod(<span class="string">'eqls'</span>, assertEql);

  <span class="comment">/**
   * ### .above(value)
   *
   * Asserts that the target is greater than `value`.
   *
   *     expect(10).to.be.above(5);
   *
   * Can also be used in conjunction with `length` to
   * assert a minimum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.above(2);
   *     expect([ 1, 2, 3 ]).to.have.length.above(2);
   *
   * @name above
   * @alias gt
   * @alias greaterThan
   * @param {Number} value
   * @param {String} message _optional_
   * @api public
   */</span>

  <span class="function"><span class="keyword">function</span> <span class="title">assertAbove</span> <span class="params">(n, msg)</span> {</span>
    <span class="keyword">if</span> (msg) flag(<span class="keyword">this</span>, <span class="string">'message'</span>, msg);
    <span class="keyword">var</span> obj = flag(<span class="keyword">this</span>, <span class="string">'object'</span>);
    <span class="keyword">if</span> (flag(<span class="keyword">this</span>, <span class="string">'doLength'</span>)) {
      <span class="keyword">new</span> Assertion(obj, msg).to.have.property(<span class="string">'length'</span>);
      <span class="keyword">var</span> len = obj.length;
      <span class="keyword">this</span>.assert(
          len &gt; n
        , <span class="string">'expected #{this} to have a length above #{exp} but got #{act}'</span>
        , <span class="string">'expected #{this} to not have a length above #{exp}'</span>
        , n
        , len
      );
    } <span class="keyword">else</span> {
      <span class="keyword">this</span>.assert(
          obj &gt; n
        , <span class="string">'expected #{this} to be above '</span> + n
        , <span class="string">'expected #{this} to be at most '</span> + n
      );
    }
  }

  Assertion.addMethod(<span class="string">'above'</span>, assertAbove);
  Assertion.addMethod(<span class="string">'gt'</span>, assertAbove);
  Assertion.addMethod(<span class="string">'greaterThan'</span>, assertAbove);

  <span class="comment">/**
   * ### .least(value)
   *
   * Asserts that the target is greater than or equal to `value`.
   *
   *     expect(10).to.be.at.least(10);
   *
   * Can also be used in conjunction with `length` to
   * assert a minimum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.of.at.least(2);
   *     expect([ 1, 2, 3 ]).to.have.length.of.at.least(3);
   *
   * @name least
   * @alias gte
   * @param {Number} value
   * @param {String} message _optional_
   * @api public
   */</span>

  <span class="function"><span class="keyword">function</span> <span class="title">assertLeast</span> <span class="params">(n, msg)</span> {</span>
    <span class="keyword">if</span> (msg) flag(<span class="keyword">this</span>, <span class="string">'message'</span>, msg);
    <span class="keyword">var</span> obj = flag(<span class="keyword">this</span>, <span class="string">'object'</span>);
    <span class="keyword">if</span> (flag(<span class="keyword">this</span>, <span class="string">'doLength'</span>)) {
      <span class="keyword">new</span> Assertion(obj, msg).to.have.property(<span class="string">'length'</span>);
      <span class="keyword">var</span> len = obj.length;
      <span class="keyword">this</span>.assert(
          len &gt;= n
        , <span class="string">'expected #{this} to have a length at least #{exp} but got #{act}'</span>
        , <span class="string">'expected #{this} to have a length below #{exp}'</span>
        , n
        , len
      );
    } <span class="keyword">else</span> {
      <span class="keyword">this</span>.assert(
          obj &gt;= n
        , <span class="string">'expected #{this} to be at least '</span> + n
        , <span class="string">'expected #{this} to be below '</span> + n
      );
    }
  }

  Assertion.addMethod(<span class="string">'least'</span>, assertLeast);
  Assertion.addMethod(<span class="string">'gte'</span>, assertLeast);

  <span class="comment">/**
   * ### .below(value)
   *
   * Asserts that the target is less than `value`.
   *
   *     expect(5).to.be.below(10);
   *
   * Can also be used in conjunction with `length` to
   * assert a maximum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.below(4);
   *     expect([ 1, 2, 3 ]).to.have.length.below(4);
   *
   * @name below
   * @alias lt
   * @alias lessThan
   * @param {Number} value
   * @param {String} message _optional_
   * @api public
   */</span>

  <span class="function"><span class="keyword">function</span> <span class="title">assertBelow</span> <span class="params">(n, msg)</span> {</span>
    <span class="keyword">if</span> (msg) flag(<span class="keyword">this</span>, <span class="string">'message'</span>, msg);
    <span class="keyword">var</span> obj = flag(<span class="keyword">this</span>, <span class="string">'object'</span>);
    <span class="keyword">if</span> (flag(<span class="keyword">this</span>, <span class="string">'doLength'</span>)) {
      <span class="keyword">new</span> Assertion(obj, msg).to.have.property(<span class="string">'length'</span>);
      <span class="keyword">var</span> len = obj.length;
      <span class="keyword">this</span>.assert(
          len &lt; n
        , <span class="string">'expected #{this} to have a length below #{exp} but got #{act}'</span>
        , <span class="string">'expected #{this} to not have a length below #{exp}'</span>
        , n
        , len
      );
    } <span class="keyword">else</span> {
      <span class="keyword">this</span>.assert(
          obj &lt; n
        , <span class="string">'expected #{this} to be below '</span> + n
        , <span class="string">'expected #{this} to be at least '</span> + n
      );
    }
  }

  Assertion.addMethod(<span class="string">'below'</span>, assertBelow);
  Assertion.addMethod(<span class="string">'lt'</span>, assertBelow);
  Assertion.addMethod(<span class="string">'lessThan'</span>, assertBelow);

  <span class="comment">/**
   * ### .most(value)
   *
   * Asserts that the target is less than or equal to `value`.
   *
   *     expect(5).to.be.at.most(5);
   *
   * Can also be used in conjunction with `length` to
   * assert a maximum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.of.at.most(4);
   *     expect([ 1, 2, 3 ]).to.have.length.of.at.most(3);
   *
   * @name most
   * @alias lte
   * @param {Number} value
   * @param {String} message _optional_
   * @api public
   */</span>

  <span class="function"><span class="keyword">function</span> <span class="title">assertMost</span> <span class="params">(n, msg)</span> {</span>
    <span class="keyword">if</span> (msg) flag(<span class="keyword">this</span>, <span class="string">'message'</span>, msg);
    <span class="keyword">var</span> obj = flag(<span class="keyword">this</span>, <span class="string">'object'</span>);
    <span class="keyword">if</span> (flag(<span class="keyword">this</span>, <span class="string">'doLength'</span>)) {
      <span class="keyword">new</span> Assertion(obj, msg).to.have.property(<span class="string">'length'</span>);
      <span class="keyword">var</span> len = obj.length;
      <span class="keyword">this</span>.assert(
          len &lt;= n
        , <span class="string">'expected #{this} to have a length at most #{exp} but got #{act}'</span>
        , <span class="string">'expected #{this} to have a length above #{exp}'</span>
        , n
        , len
      );
    } <span class="keyword">else</span> {
      <span class="keyword">this</span>.assert(
          obj &lt;= n
        , <span class="string">'expected #{this} to be at most '</span> + n
        , <span class="string">'expected #{this} to be above '</span> + n
      );
    }
  }

  Assertion.addMethod(<span class="string">'most'</span>, assertMost);
  Assertion.addMethod(<span class="string">'lte'</span>, assertMost);

  <span class="comment">/**
   * ### .within(start, finish)
   *
   * Asserts that the target is within a range.
   *
   *     expect(7).to.be.within(5,10);
   *
   * Can also be used in conjunction with `length` to
   * assert a length range. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.within(2,4);
   *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);
   *
   * @name within
   * @param {Number} start lowerbound inclusive
   * @param {Number} finish upperbound inclusive
   * @param {String} message _optional_
   * @api public
   */</span>

  Assertion.addMethod(<span class="string">'within'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(start, finish, msg)</span> {</span>
    <span class="keyword">if</span> (msg) flag(<span class="keyword">this</span>, <span class="string">'message'</span>, msg);
    <span class="keyword">var</span> obj = flag(<span class="keyword">this</span>, <span class="string">'object'</span>)
      , range = start + <span class="string">'..'</span> + finish;
    <span class="keyword">if</span> (flag(<span class="keyword">this</span>, <span class="string">'doLength'</span>)) {
      <span class="keyword">new</span> Assertion(obj, msg).to.have.property(<span class="string">'length'</span>);
      <span class="keyword">var</span> len = obj.length;
      <span class="keyword">this</span>.assert(
          len &gt;= start &amp;&amp; len &lt;= finish
        , <span class="string">'expected #{this} to have a length within '</span> + range
        , <span class="string">'expected #{this} to not have a length within '</span> + range
      );
    } <span class="keyword">else</span> {
      <span class="keyword">this</span>.assert(
          obj &gt;= start &amp;&amp; obj &lt;= finish
        , <span class="string">'expected #{this} to be within '</span> + range
        , <span class="string">'expected #{this} to not be within '</span> + range
      );
    }
  });

  <span class="comment">/**
   * ### .instanceof(constructor)
   *
   * Asserts that the target is an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , Chai = new Tea('chai');
   *
   *     expect(Chai).to.be.an.instanceof(Tea);
   *     expect([ 1, 2, 3 ]).to.be.instanceof(Array);
   *
   * @name instanceof
   * @param {Constructor} constructor
   * @param {String} message _optional_
   * @alias instanceOf
   * @api public
   */</span>

  <span class="function"><span class="keyword">function</span> <span class="title">assertInstanceOf</span> <span class="params">(constructor, msg)</span> {</span>
    <span class="keyword">if</span> (msg) flag(<span class="keyword">this</span>, <span class="string">'message'</span>, msg);
    <span class="keyword">var</span> name = _.getName(constructor);
    <span class="keyword">this</span>.assert(
        flag(<span class="keyword">this</span>, <span class="string">'object'</span>) <span class="keyword">instanceof</span> constructor
      , <span class="string">'expected #{this} to be an instance of '</span> + name
      , <span class="string">'expected #{this} to not be an instance of '</span> + name
    );
  };

  Assertion.addMethod(<span class="string">'instanceof'</span>, assertInstanceOf);
  Assertion.addMethod(<span class="string">'instanceOf'</span>, assertInstanceOf);

  <span class="comment">/**
   * ### .property(name, [value])
   *
   * Asserts that the target has a property `name`, optionally asserting that
   * the value of that property is strictly equal to  `value`.
   * If the `deep` flag is set, you can use dot- and bracket-notation for deep
   * references into objects and arrays.
   *
   *     // simple referencing
   *     var obj = { foo: 'bar' };
   *     expect(obj).to.have.property('foo');
   *     expect(obj).to.have.property('foo', 'bar');
   *
   *     // deep referencing
   *     var deepObj = {
   *         green: { tea: 'matcha' }
   *       , teas: [ 'chai', 'matcha', { tea: 'konacha' } ]
   *     };

   *     expect(deepObj).to.have.deep.property('green.tea', 'matcha');
   *     expect(deepObj).to.have.deep.property('teas[1]', 'matcha');
   *     expect(deepObj).to.have.deep.property('teas[2].tea', 'konacha');
   *
   * You can also use an array as the starting point of a `deep.property`
   * assertion, or traverse nested arrays.
   *
   *     var arr = [
   *         [ 'chai', 'matcha', 'konacha' ]
   *       , [ { tea: 'chai' }
   *         , { tea: 'matcha' }
   *         , { tea: 'konacha' } ]
   *     ];
   *
   *     expect(arr).to.have.deep.property('[0][1]', 'matcha');
   *     expect(arr).to.have.deep.property('[1][2].tea', 'konacha');
   *
   * Furthermore, `property` changes the subject of the assertion
   * to be the value of that property from the original object. This
   * permits for further chainable assertions on that property.
   *
   *     expect(obj).to.have.property('foo')
   *       .that.is.a('string');
   *     expect(deepObj).to.have.property('green')
   *       .that.is.an('object')
   *       .that.deep.equals({ tea: 'matcha' });
   *     expect(deepObj).to.have.property('teas')
   *       .that.is.an('array')
   *       .with.deep.property('[2]')
   *         .that.deep.equals({ tea: 'konacha' });
   *
   * @name property
   * @alias deep.property
   * @param {String} name
   * @param {Mixed} value (optional)
   * @param {String} message _optional_
   * @returns value of property for chaining
   * @api public
   */</span>

  Assertion.addMethod(<span class="string">'property'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(name, val, msg)</span> {</span>
    <span class="keyword">if</span> (msg) flag(<span class="keyword">this</span>, <span class="string">'message'</span>, msg);

    <span class="keyword">var</span> descriptor = flag(<span class="keyword">this</span>, <span class="string">'deep'</span>) ? <span class="string">'deep property '</span> : <span class="string">'property '</span>
      , negate = flag(<span class="keyword">this</span>, <span class="string">'negate'</span>)
      , obj = flag(<span class="keyword">this</span>, <span class="string">'object'</span>)
      , value = flag(<span class="keyword">this</span>, <span class="string">'deep'</span>)
        ? _.getPathValue(name, obj)
        : obj[name];

    <span class="keyword">if</span> (negate &amp;&amp; <span class="literal">undefined</span> !== val) {
      <span class="keyword">if</span> (<span class="literal">undefined</span> === value) {
        msg = (msg != <span class="literal">null</span>) ? msg + <span class="string">': '</span> : <span class="string">''</span>;
        <span class="keyword">throw</span> <span class="keyword">new</span> Error(msg + _.inspect(obj) + <span class="string">' has no '</span> + descriptor + _.inspect(name));
      }
    } <span class="keyword">else</span> {
      <span class="keyword">this</span>.assert(
          <span class="literal">undefined</span> !== value
        , <span class="string">'expected #{this} to have a '</span> + descriptor + _.inspect(name)
        , <span class="string">'expected #{this} to not have '</span> + descriptor + _.inspect(name));
    }

    <span class="keyword">if</span> (<span class="literal">undefined</span> !== val) {
      <span class="keyword">this</span>.assert(
          val === value
        , <span class="string">'expected #{this} to have a '</span> + descriptor + _.inspect(name) + <span class="string">' of #{exp}, but got #{act}'</span>
        , <span class="string">'expected #{this} to not have a '</span> + descriptor + _.inspect(name) + <span class="string">' of #{act}'</span>
        , val
        , value
      );
    }

    flag(<span class="keyword">this</span>, <span class="string">'object'</span>, value);
  });


  <span class="comment">/**
   * ### .ownProperty(name)
   *
   * Asserts that the target has an own property `name`.
   *
   *     expect('test').to.have.ownProperty('length');
   *
   * @name ownProperty
   * @alias haveOwnProperty
   * @param {String} name
   * @param {String} message _optional_
   * @api public
   */</span>

  <span class="function"><span class="keyword">function</span> <span class="title">assertOwnProperty</span> <span class="params">(name, msg)</span> {</span>
    <span class="keyword">if</span> (msg) flag(<span class="keyword">this</span>, <span class="string">'message'</span>, msg);
    <span class="keyword">var</span> obj = flag(<span class="keyword">this</span>, <span class="string">'object'</span>);
    <span class="keyword">this</span>.assert(
        obj.hasOwnProperty(name)
      , <span class="string">'expected #{this} to have own property '</span> + _.inspect(name)
      , <span class="string">'expected #{this} to not have own property '</span> + _.inspect(name)
    );
  }

  Assertion.addMethod(<span class="string">'ownProperty'</span>, assertOwnProperty);
  Assertion.addMethod(<span class="string">'haveOwnProperty'</span>, assertOwnProperty);

  <span class="comment">/**
   * ### .length(value)
   *
   * Asserts that the target's `length` property has
   * the expected value.
   *
   *     expect([ 1, 2, 3]).to.have.length(3);
   *     expect('foobar').to.have.length(6);
   *
   * Can also be used as a chain precursor to a value
   * comparison for the length property.
   *
   *     expect('foo').to.have.length.above(2);
   *     expect([ 1, 2, 3 ]).to.have.length.above(2);
   *     expect('foo').to.have.length.below(4);
   *     expect([ 1, 2, 3 ]).to.have.length.below(4);
   *     expect('foo').to.have.length.within(2,4);
   *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);
   *
   * @name length
   * @alias lengthOf
   * @param {Number} length
   * @param {String} message _optional_
   * @api public
   */</span>

  <span class="function"><span class="keyword">function</span> <span class="title">assertLengthChain</span> <span class="params">()</span> {</span>
    flag(<span class="keyword">this</span>, <span class="string">'doLength'</span>, <span class="literal">true</span>);
  }

  <span class="function"><span class="keyword">function</span> <span class="title">assertLength</span> <span class="params">(n, msg)</span> {</span>
    <span class="keyword">if</span> (msg) flag(<span class="keyword">this</span>, <span class="string">'message'</span>, msg);
    <span class="keyword">var</span> obj = flag(<span class="keyword">this</span>, <span class="string">'object'</span>);
    <span class="keyword">new</span> Assertion(obj, msg).to.have.property(<span class="string">'length'</span>);
    <span class="keyword">var</span> len = obj.length;

    <span class="keyword">this</span>.assert(
        len == n
      , <span class="string">'expected #{this} to have a length of #{exp} but got #{act}'</span>
      , <span class="string">'expected #{this} to not have a length of #{act}'</span>
      , n
      , len
    );
  }

  Assertion.addChainableMethod(<span class="string">'length'</span>, assertLength, assertLengthChain);
  Assertion.addMethod(<span class="string">'lengthOf'</span>, assertLength, assertLengthChain);

  <span class="comment">/**
   * ### .match(regexp)
   *
   * Asserts that the target matches a regular expression.
   *
   *     expect('foobar').to.match(/^foo/);
   *
   * @name match
   * @param {RegExp} RegularExpression
   * @param {String} message _optional_
   * @api public
   */</span>

  Assertion.addMethod(<span class="string">'match'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(re, msg)</span> {</span>
    <span class="keyword">if</span> (msg) flag(<span class="keyword">this</span>, <span class="string">'message'</span>, msg);
    <span class="keyword">var</span> obj = flag(<span class="keyword">this</span>, <span class="string">'object'</span>);
    <span class="keyword">this</span>.assert(
        re.exec(obj)
      , <span class="string">'expected #{this} to match '</span> + re
      , <span class="string">'expected #{this} not to match '</span> + re
    );
  });

  <span class="comment">/**
   * ### .string(string)
   *
   * Asserts that the string target contains another string.
   *
   *     expect('foobar').to.have.string('bar');
   *
   * @name string
   * @param {String} string
   * @param {String} message _optional_
   * @api public
   */</span>

  Assertion.addMethod(<span class="string">'string'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(str, msg)</span> {</span>
    <span class="keyword">if</span> (msg) flag(<span class="keyword">this</span>, <span class="string">'message'</span>, msg);
    <span class="keyword">var</span> obj = flag(<span class="keyword">this</span>, <span class="string">'object'</span>);
    <span class="keyword">new</span> Assertion(obj, msg).is.a(<span class="string">'string'</span>);

    <span class="keyword">this</span>.assert(
        ~obj.indexOf(str)
      , <span class="string">'expected #{this} to contain '</span> + _.inspect(str)
      , <span class="string">'expected #{this} to not contain '</span> + _.inspect(str)
    );
  });


  <span class="comment">/**
   * ### .keys(key1, [key2], [...])
   *
   * Asserts that the target has exactly the given keys, or
   * asserts the inclusion of some keys when using the
   * `include` or `contain` modifiers.
   *
   *     expect({ foo: 1, bar: 2 }).to.have.keys(['foo', 'bar']);
   *     expect({ foo: 1, bar: 2, baz: 3 }).to.contain.keys('foo', 'bar');
   *
   * @name keys
   * @alias key
   * @param {String...|Array} keys
   * @api public
   */</span>

  <span class="function"><span class="keyword">function</span> <span class="title">assertKeys</span> <span class="params">(keys)</span> {</span>
    <span class="keyword">var</span> obj = flag(<span class="keyword">this</span>, <span class="string">'object'</span>)
      , str
      , ok = <span class="literal">true</span>;

    keys = keys <span class="keyword">instanceof</span> Array
      ? keys
      : Array.prototype.slice.call(arguments);

    <span class="keyword">if</span> (!keys.length) <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'keys required'</span>);

    <span class="keyword">var</span> actual = Object.keys(obj)
      , len = keys.length;</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>Inclusion</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    ok = keys.every(<span class="keyword">function</span>(key){
      <span class="keyword">return</span> ~actual.indexOf(key);
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>Strict</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">if</span> (!flag(<span class="keyword">this</span>, <span class="string">'negate'</span>) &amp;&amp; !flag(<span class="keyword">this</span>, <span class="string">'contains'</span>)) {
      ok = ok &amp;&amp; keys.length == actual.length;
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>Key string</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">if</span> (len &gt; <span class="number">1</span>) {
      keys = keys.map(<span class="keyword">function</span>(key){
        <span class="keyword">return</span> _.inspect(key);
      });
      <span class="keyword">var</span> last = keys.pop();
      str = keys.join(<span class="string">', '</span>) + <span class="string">', and '</span> + last;
    } <span class="keyword">else</span> {
      str = _.inspect(keys[<span class="number">0</span>]);
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>Form</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    str = (len &gt; <span class="number">1</span> ? <span class="string">'keys '</span> : <span class="string">'key '</span>) + str;</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>Have / include</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    str = (flag(<span class="keyword">this</span>, <span class="string">'contains'</span>) ? <span class="string">'contain '</span> : <span class="string">'have '</span>) + str;</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>Assertion</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">this</span>.assert(
        ok
      , <span class="string">'expected #{this} to '</span> + str
      , <span class="string">'expected #{this} to not '</span> + str
    );
  }

  Assertion.addMethod(<span class="string">'keys'</span>, assertKeys);
  Assertion.addMethod(<span class="string">'key'</span>, assertKeys);

  <span class="comment">/**
   * ### .throw(constructor)
   *
   * Asserts that the function target will throw a specific error, or specific type of error
   * (as determined using `instanceof`), optionally with a RegExp or string inclusion test
   * for the error's message.
   *
   *     var err = new ReferenceError('This is a bad function.');
   *     var fn = function () { throw err; }
   *     expect(fn).to.throw(ReferenceError);
   *     expect(fn).to.throw(Error);
   *     expect(fn).to.throw(/bad function/);
   *     expect(fn).to.not.throw('good function');
   *     expect(fn).to.throw(ReferenceError, /bad function/);
   *     expect(fn).to.throw(err);
   *     expect(fn).to.not.throw(new RangeError('Out of range.'));
   *
   * Please note that when a throw expectation is negated, it will check each
   * parameter independently, starting with error constructor type. The appropriate way
   * to check for the existence of a type of error but for a message that does not match
   * is to use `and`.
   *
   *     expect(fn).to.throw(ReferenceError)
   *        .and.not.throw(/good function/);
   *
   * @name throw
   * @alias throws
   * @alias Throw
   * @param {ErrorConstructor} constructor
   * @param {String|RegExp} expected error message
   * @param {String} message _optional_
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @api public
   */</span>

  <span class="function"><span class="keyword">function</span> <span class="title">assertThrows</span> <span class="params">(constructor, errMsg, msg)</span> {</span>
    <span class="keyword">if</span> (msg) flag(<span class="keyword">this</span>, <span class="string">'message'</span>, msg);
    <span class="keyword">var</span> obj = flag(<span class="keyword">this</span>, <span class="string">'object'</span>);
    <span class="keyword">new</span> Assertion(obj, msg).is.a(<span class="string">'function'</span>);

    <span class="keyword">var</span> thrown = <span class="literal">false</span>
      , desiredError = <span class="literal">null</span>
      , name = <span class="literal">null</span>
      , thrownError = <span class="literal">null</span>;

    <span class="keyword">if</span> (arguments.length === <span class="number">0</span>) {
      errMsg = <span class="literal">null</span>;
      constructor = <span class="literal">null</span>;
    } <span class="keyword">else</span> <span class="keyword">if</span> (constructor &amp;&amp; (constructor <span class="keyword">instanceof</span> RegExp || <span class="string">'string'</span> === <span class="keyword">typeof</span> constructor)) {
      errMsg = constructor;
      constructor = <span class="literal">null</span>;
    } <span class="keyword">else</span> <span class="keyword">if</span> (constructor &amp;&amp; constructor <span class="keyword">instanceof</span> Error) {
      desiredError = constructor;
      constructor = <span class="literal">null</span>;
      errMsg = <span class="literal">null</span>;
    } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> constructor === <span class="string">'function'</span>) {
      name = (<span class="keyword">new</span> constructor()).name;
    } <span class="keyword">else</span> {
      constructor = <span class="literal">null</span>;
    }

    <span class="keyword">try</span> {
      obj();
    } <span class="keyword">catch</span> (err) {</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>first, check desired error</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">if</span> (desiredError) {
        <span class="keyword">this</span>.assert(
            err === desiredError
          , <span class="string">'expected #{this} to throw #{exp} but #{act} was thrown'</span>
          , <span class="string">'expected #{this} to not throw #{exp}'</span>
          , desiredError
          , err
        );

        <span class="keyword">return</span> <span class="keyword">this</span>;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>next, check constructor</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">if</span> (constructor) {
        <span class="keyword">this</span>.assert(
            err <span class="keyword">instanceof</span> constructor
          , <span class="string">'expected #{this} to throw #{exp} but #{act} was thrown'</span>
          , <span class="string">'expected #{this} to not throw #{exp} but #{act} was thrown'</span>
          , name
          , err
        );

        <span class="keyword">if</span> (!errMsg) <span class="keyword">return</span> <span class="keyword">this</span>;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>next, check message</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">var</span> message = <span class="string">'object'</span> === _.type(err) &amp;&amp; <span class="string">"message"</span> <span class="keyword">in</span> err
        ? err.message
        : <span class="string">''</span> + err;

      <span class="keyword">if</span> ((message != <span class="literal">null</span>) &amp;&amp; errMsg &amp;&amp; errMsg <span class="keyword">instanceof</span> RegExp) {
        <span class="keyword">this</span>.assert(
            errMsg.exec(message)
          , <span class="string">'expected #{this} to throw error matching #{exp} but got #{act}'</span>
          , <span class="string">'expected #{this} to throw error not matching #{exp}'</span>
          , errMsg
          , message
        );

        <span class="keyword">return</span> <span class="keyword">this</span>;
      } <span class="keyword">else</span> <span class="keyword">if</span> ((message != <span class="literal">null</span>) &amp;&amp; errMsg &amp;&amp; <span class="string">'string'</span> === <span class="keyword">typeof</span> errMsg) {
        <span class="keyword">this</span>.assert(
            ~message.indexOf(errMsg)
          , <span class="string">'expected #{this} to throw error including #{exp} but got #{act}'</span>
          , <span class="string">'expected #{this} to throw error not including #{act}'</span>
          , errMsg
          , message
        );

        <span class="keyword">return</span> <span class="keyword">this</span>;
      } <span class="keyword">else</span> {
        thrown = <span class="literal">true</span>;
        thrownError = err;
      }
    }

    <span class="keyword">var</span> actuallyGot = <span class="string">''</span>
      , expectedThrown = name !== <span class="literal">null</span>
        ? name
        : desiredError
          ? <span class="string">'#{exp}'</span> <span class="comment">//_.inspect(desiredError)</span>
          : <span class="string">'an error'</span>;

    <span class="keyword">if</span> (thrown) {
      actuallyGot = <span class="string">' but #{act} was thrown'</span>
    }

    <span class="keyword">this</span>.assert(
        thrown === <span class="literal">true</span>
      , <span class="string">'expected #{this} to throw '</span> + expectedThrown + actuallyGot
      , <span class="string">'expected #{this} to not throw '</span> + expectedThrown + actuallyGot
      , desiredError
      , thrownError
    );
  };

  Assertion.addMethod(<span class="string">'throw'</span>, assertThrows);
  Assertion.addMethod(<span class="string">'throws'</span>, assertThrows);
  Assertion.addMethod(<span class="string">'Throw'</span>, assertThrows);

  <span class="comment">/**
   * ### .respondTo(method)
   *
   * Asserts that the object or class target will respond to a method.
   *
   *     Klass.prototype.bar = function(){};
   *     expect(Klass).to.respondTo('bar');
   *     expect(obj).to.respondTo('bar');
   *
   * To check if a constructor will respond to a static function,
   * set the `itself` flag.
   *
   *    Klass.baz = function(){};
   *    expect(Klass).itself.to.respondTo('baz');
   *
   * @name respondTo
   * @param {String} method
   * @param {String} message _optional_
   * @api public
   */</span>

  Assertion.addMethod(<span class="string">'respondTo'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(method, msg)</span> {</span>
    <span class="keyword">if</span> (msg) flag(<span class="keyword">this</span>, <span class="string">'message'</span>, msg);
    <span class="keyword">var</span> obj = flag(<span class="keyword">this</span>, <span class="string">'object'</span>)
      , itself = flag(<span class="keyword">this</span>, <span class="string">'itself'</span>)
      , context = (<span class="string">'function'</span> === _.type(obj) &amp;&amp; !itself)
        ? obj.prototype[method]
        : obj[method];

    <span class="keyword">this</span>.assert(
        <span class="string">'function'</span> === <span class="keyword">typeof</span> context
      , <span class="string">'expected #{this} to respond to '</span> + _.inspect(method)
      , <span class="string">'expected #{this} to not respond to '</span> + _.inspect(method)
    );
  });

  <span class="comment">/**
   * ### .itself
   *
   * Sets the `itself` flag, later used by the `respondTo` assertion.
   *
   *    function Foo() {}
   *    Foo.bar = function() {}
   *    Foo.prototype.baz = function() {}
   *
   *    expect(Foo).itself.to.respondTo('bar');
   *    expect(Foo).itself.not.to.respondTo('baz');
   *
   * @name itself
   * @api public
   */</span>

  Assertion.addProperty(<span class="string">'itself'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    flag(<span class="keyword">this</span>, <span class="string">'itself'</span>, <span class="literal">true</span>);
  });

  <span class="comment">/**
   * ### .satisfy(method)
   *
   * Asserts that the target passes a given truth test.
   *
   *     expect(1).to.satisfy(function(num) { return num &gt; 0; });
   *
   * @name satisfy
   * @param {Function} matcher
   * @param {String} message _optional_
   * @api public
   */</span>

  Assertion.addMethod(<span class="string">'satisfy'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(matcher, msg)</span> {</span>
    <span class="keyword">if</span> (msg) flag(<span class="keyword">this</span>, <span class="string">'message'</span>, msg);
    <span class="keyword">var</span> obj = flag(<span class="keyword">this</span>, <span class="string">'object'</span>);
    <span class="keyword">this</span>.assert(
        matcher(obj)
      , <span class="string">'expected #{this} to satisfy '</span> + _.objDisplay(matcher)
      , <span class="string">'expected #{this} to not satisfy'</span> + _.objDisplay(matcher)
      , <span class="keyword">this</span>.negate ? <span class="literal">false</span> : <span class="literal">true</span>
      , matcher(obj)
    );
  });

  <span class="comment">/**
   * ### .closeTo(expected, delta)
   *
   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
   *
   *     expect(1.5).to.be.closeTo(1, 0.5);
   *
   * @name closeTo
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} message _optional_
   * @api public
   */</span>

  Assertion.addMethod(<span class="string">'closeTo'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(expected, delta, msg)</span> {</span>
    <span class="keyword">if</span> (msg) flag(<span class="keyword">this</span>, <span class="string">'message'</span>, msg);
    <span class="keyword">var</span> obj = flag(<span class="keyword">this</span>, <span class="string">'object'</span>);
    <span class="keyword">this</span>.assert(
        Math.abs(obj - expected) &lt;= delta
      , <span class="string">'expected #{this} to be close to '</span> + expected + <span class="string">' +/- '</span> + delta
      , <span class="string">'expected #{this} not to be close to '</span> + expected + <span class="string">' +/- '</span> + delta
    );
  });

  <span class="function"><span class="keyword">function</span> <span class="title">isSubsetOf</span><span class="params">(subset, superset)</span> {</span>
    <span class="keyword">return</span> subset.every(<span class="keyword">function</span>(elem) {
      <span class="keyword">return</span> superset.indexOf(elem) !== -<span class="number">1</span>;
    })
  }

  <span class="comment">/**
   * ### .members
   *
   * Asserts that the target is a superset of `set`,
   * or that the target and `set` have the same members.
   *
   *    expect([1, 2, 3]).to.include.members([3, 2]);
   *    expect([1, 2, 3]).to.not.include.members([3, 2, 8]);
   *
   *    expect([4, 2]).to.have.members([2, 4]);
   *    expect([5, 2]).to.not.have.members([5, 2, 1]);
   *
   * @name members
   * @param {Array} set
   * @param {String} message _optional_
   * @api public
   */</span>

  Assertion.addMethod(<span class="string">'members'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(subset, msg)</span> {</span>
    <span class="keyword">if</span> (msg) flag(<span class="keyword">this</span>, <span class="string">'message'</span>, msg);
    <span class="keyword">var</span> obj = flag(<span class="keyword">this</span>, <span class="string">'object'</span>);

    <span class="keyword">new</span> Assertion(obj).to.be.an(<span class="string">'array'</span>);
    <span class="keyword">new</span> Assertion(subset).to.be.an(<span class="string">'array'</span>);

    <span class="keyword">if</span> (flag(<span class="keyword">this</span>, <span class="string">'contains'</span>)) {
      <span class="keyword">return</span> <span class="keyword">this</span>.assert(
          isSubsetOf(subset, obj)
        , <span class="string">'expected #{this} to be a superset of #{act}'</span>
        , <span class="string">'expected #{this} to not be a superset of #{act}'</span>
        , obj
        , subset
      );
    }

    <span class="keyword">this</span>.assert(
        isSubsetOf(obj, subset) &amp;&amp; isSubsetOf(subset, obj)
        , <span class="string">'expected #{this} to have the same members as #{act}'</span>
        , <span class="string">'expected #{this} to not have the same members as #{act}'</span>
        , obj
        , subset
    );
  });
};

});
require.register(<span class="string">"chai/lib/chai/interface/assert.js"</span>, <span class="keyword">function</span>(exports, require, module){
<span class="comment">/*!
 * chai
 * Copyright(c) 2011-2013 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */</span>


module.exports = <span class="function"><span class="keyword">function</span> <span class="params">(chai, util)</span> {</span>

  <span class="comment">/*!
   * Chai dependencies.
   */</span>

  <span class="keyword">var</span> Assertion = chai.Assertion
    , flag = util.flag;

  <span class="comment">/*!
   * Module export.
   */</span>

  <span class="comment">/**
   * ### assert(expression, message)
   *
   * Write your own test expressions.
   *
   *     assert('foo' !== 'bar', 'foo is not bar');
   *     assert(Array.isArray([]), 'empty arrays are arrays');
   *
   * @param {Mixed} expression to test for truthiness
   * @param {String} message to display on error
   * @name assert
   * @api public
   */</span>

  <span class="keyword">var</span> assert = chai.assert = <span class="function"><span class="keyword">function</span> <span class="params">(express, errmsg)</span> {</span>
    <span class="keyword">var</span> test = <span class="keyword">new</span> Assertion(<span class="literal">null</span>);
    test.assert(
        express
      , errmsg
      , <span class="string">'[ negation message unavailable ]'</span>
    );
  };

  <span class="comment">/**
   * ### .fail(actual, expected, [message], [operator])
   *
   * Throw a failure. Node.js `assert` module-compatible.
   *
   * @name fail
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @param {String} operator
   * @api public
   */</span>

  assert.fail = <span class="function"><span class="keyword">function</span> <span class="params">(actual, expected, message, operator)</span> {</span>
    <span class="keyword">throw</span> <span class="keyword">new</span> chai.AssertionError({
        actual: actual
      , expected: expected
      , message: message
      , operator: operator
      , stackStartFunction: assert.fail
    });
  };

  <span class="comment">/**
   * ### .ok(object, [message])
   *
   * Asserts that `object` is truthy.
   *
   *     assert.ok('everything', 'everything is ok');
   *     assert.ok(false, 'this will fail');
   *
   * @name ok
   * @param {Mixed} object to test
   * @param {String} message
   * @api public
   */</span>

  assert.ok = <span class="function"><span class="keyword">function</span> <span class="params">(val, msg)</span> {</span>
    <span class="keyword">new</span> Assertion(val, msg).is.ok;
  };

  <span class="comment">/**
   * ### .notOk(object, [message])
   *
   * Asserts that `object` is falsy.
   *
   *     assert.notOk('everything', 'this will fail');
   *     assert.notOk(false, 'this will pass');
   *
   * @name notOk
   * @param {Mixed} object to test
   * @param {String} message
   * @api public
   */</span>

  assert.notOk = <span class="function"><span class="keyword">function</span> <span class="params">(val, msg)</span> {</span>
    <span class="keyword">new</span> Assertion(val, msg).is.not.ok;
  };

  <span class="comment">/**
   * ### .equal(actual, expected, [message])
   *
   * Asserts non-strict equality (`==`) of `actual` and `expected`.
   *
   *     assert.equal(3, '3', '== coerces values to strings');
   *
   * @name equal
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */</span>

  assert.equal = <span class="function"><span class="keyword">function</span> <span class="params">(act, exp, msg)</span> {</span>
    <span class="keyword">var</span> test = <span class="keyword">new</span> Assertion(act, msg);

    test.assert(
        exp == flag(test, <span class="string">'object'</span>)
      , <span class="string">'expected #{this} to equal #{exp}'</span>
      , <span class="string">'expected #{this} to not equal #{act}'</span>
      , exp
      , act
    );
  };

  <span class="comment">/**
   * ### .notEqual(actual, expected, [message])
   *
   * Asserts non-strict inequality (`!=`) of `actual` and `expected`.
   *
   *     assert.notEqual(3, 4, 'these numbers are not equal');
   *
   * @name notEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */</span>

  assert.notEqual = <span class="function"><span class="keyword">function</span> <span class="params">(act, exp, msg)</span> {</span>
    <span class="keyword">var</span> test = <span class="keyword">new</span> Assertion(act, msg);

    test.assert(
        exp != flag(test, <span class="string">'object'</span>)
      , <span class="string">'expected #{this} to not equal #{exp}'</span>
      , <span class="string">'expected #{this} to equal #{act}'</span>
      , exp
      , act
    );
  };

  <span class="comment">/**
   * ### .strictEqual(actual, expected, [message])
   *
   * Asserts strict equality (`===`) of `actual` and `expected`.
   *
   *     assert.strictEqual(true, true, 'these booleans are strictly equal');
   *
   * @name strictEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */</span>

  assert.strictEqual = <span class="function"><span class="keyword">function</span> <span class="params">(act, exp, msg)</span> {</span>
    <span class="keyword">new</span> Assertion(act, msg).to.equal(exp);
  };

  <span class="comment">/**
   * ### .notStrictEqual(actual, expected, [message])
   *
   * Asserts strict inequality (`!==`) of `actual` and `expected`.
   *
   *     assert.notStrictEqual(3, '3', 'no coercion for strict equality');
   *
   * @name notStrictEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */</span>

  assert.notStrictEqual = <span class="function"><span class="keyword">function</span> <span class="params">(act, exp, msg)</span> {</span>
    <span class="keyword">new</span> Assertion(act, msg).to.not.equal(exp);
  };

  <span class="comment">/**
   * ### .deepEqual(actual, expected, [message])
   *
   * Asserts that `actual` is deeply equal to `expected`.
   *
   *     assert.deepEqual({ tea: 'green' }, { tea: 'green' });
   *
   * @name deepEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */</span>

  assert.deepEqual = <span class="function"><span class="keyword">function</span> <span class="params">(act, exp, msg)</span> {</span>
    <span class="keyword">new</span> Assertion(act, msg).to.eql(exp);
  };

  <span class="comment">/**
   * ### .notDeepEqual(actual, expected, [message])
   *
   * Assert that `actual` is not deeply equal to `expected`.
   *
   *     assert.notDeepEqual({ tea: 'green' }, { tea: 'jasmine' });
   *
   * @name notDeepEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */</span>

  assert.notDeepEqual = <span class="function"><span class="keyword">function</span> <span class="params">(act, exp, msg)</span> {</span>
    <span class="keyword">new</span> Assertion(act, msg).to.not.eql(exp);
  };

  <span class="comment">/**
   * ### .isTrue(value, [message])
   *
   * Asserts that `value` is true.
   *
   *     var teaServed = true;
   *     assert.isTrue(teaServed, 'the tea has been served');
   *
   * @name isTrue
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */</span>

  assert.isTrue = <span class="function"><span class="keyword">function</span> <span class="params">(val, msg)</span> {</span>
    <span class="keyword">new</span> Assertion(val, msg).is[<span class="string">'true'</span>];
  };

  <span class="comment">/**
   * ### .isFalse(value, [message])
   *
   * Asserts that `value` is false.
   *
   *     var teaServed = false;
   *     assert.isFalse(teaServed, 'no tea yet? hmm...');
   *
   * @name isFalse
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */</span>

  assert.isFalse = <span class="function"><span class="keyword">function</span> <span class="params">(val, msg)</span> {</span>
    <span class="keyword">new</span> Assertion(val, msg).is[<span class="string">'false'</span>];
  };

  <span class="comment">/**
   * ### .isNull(value, [message])
   *
   * Asserts that `value` is null.
   *
   *     assert.isNull(err, 'there was no error');
   *
   * @name isNull
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */</span>

  assert.isNull = <span class="function"><span class="keyword">function</span> <span class="params">(val, msg)</span> {</span>
    <span class="keyword">new</span> Assertion(val, msg).to.equal(<span class="literal">null</span>);
  };

  <span class="comment">/**
   * ### .isNotNull(value, [message])
   *
   * Asserts that `value` is not null.
   *
   *     var tea = 'tasty chai';
   *     assert.isNotNull(tea, 'great, time for tea!');
   *
   * @name isNotNull
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */</span>

  assert.isNotNull = <span class="function"><span class="keyword">function</span> <span class="params">(val, msg)</span> {</span>
    <span class="keyword">new</span> Assertion(val, msg).to.not.equal(<span class="literal">null</span>);
  };

  <span class="comment">/**
   * ### .isUndefined(value, [message])
   *
   * Asserts that `value` is `undefined`.
   *
   *     var tea;
   *     assert.isUndefined(tea, 'no tea defined');
   *
   * @name isUndefined
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */</span>

  assert.isUndefined = <span class="function"><span class="keyword">function</span> <span class="params">(val, msg)</span> {</span>
    <span class="keyword">new</span> Assertion(val, msg).to.equal(<span class="literal">undefined</span>);
  };

  <span class="comment">/**
   * ### .isDefined(value, [message])
   *
   * Asserts that `value` is not `undefined`.
   *
   *     var tea = 'cup of chai';
   *     assert.isDefined(tea, 'tea has been defined');
   *
   * @name isDefined
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */</span>

  assert.isDefined = <span class="function"><span class="keyword">function</span> <span class="params">(val, msg)</span> {</span>
    <span class="keyword">new</span> Assertion(val, msg).to.not.equal(<span class="literal">undefined</span>);
  };

  <span class="comment">/**
   * ### .isFunction(value, [message])
   *
   * Asserts that `value` is a function.
   *
   *     function serveTea() { return 'cup of tea'; };
   *     assert.isFunction(serveTea, 'great, we can have tea now');
   *
   * @name isFunction
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */</span>

  assert.isFunction = <span class="function"><span class="keyword">function</span> <span class="params">(val, msg)</span> {</span>
    <span class="keyword">new</span> Assertion(val, msg).to.be.a(<span class="string">'function'</span>);
  };

  <span class="comment">/**
   * ### .isNotFunction(value, [message])
   *
   * Asserts that `value` is _not_ a function.
   *
   *     var serveTea = [ 'heat', 'pour', 'sip' ];
   *     assert.isNotFunction(serveTea, 'great, we have listed the steps');
   *
   * @name isNotFunction
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */</span>

  assert.isNotFunction = <span class="function"><span class="keyword">function</span> <span class="params">(val, msg)</span> {</span>
    <span class="keyword">new</span> Assertion(val, msg).to.not.be.a(<span class="string">'function'</span>);
  };

  <span class="comment">/**
   * ### .isObject(value, [message])
   *
   * Asserts that `value` is an object (as revealed by
   * `Object.prototype.toString`).
   *
   *     var selection = { name: 'Chai', serve: 'with spices' };
   *     assert.isObject(selection, 'tea selection is an object');
   *
   * @name isObject
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */</span>

  assert.isObject = <span class="function"><span class="keyword">function</span> <span class="params">(val, msg)</span> {</span>
    <span class="keyword">new</span> Assertion(val, msg).to.be.a(<span class="string">'object'</span>);
  };

  <span class="comment">/**
   * ### .isNotObject(value, [message])
   *
   * Asserts that `value` is _not_ an object.
   *
   *     var selection = 'chai'
   *     assert.isObject(selection, 'tea selection is not an object');
   *     assert.isObject(null, 'null is not an object');
   *
   * @name isNotObject
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */</span>

  assert.isNotObject = <span class="function"><span class="keyword">function</span> <span class="params">(val, msg)</span> {</span>
    <span class="keyword">new</span> Assertion(val, msg).to.not.be.a(<span class="string">'object'</span>);
  };

  <span class="comment">/**
   * ### .isArray(value, [message])
   *
   * Asserts that `value` is an array.
   *
   *     var menu = [ 'green', 'chai', 'oolong' ];
   *     assert.isArray(menu, 'what kind of tea do we want?');
   *
   * @name isArray
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */</span>

  assert.isArray = <span class="function"><span class="keyword">function</span> <span class="params">(val, msg)</span> {</span>
    <span class="keyword">new</span> Assertion(val, msg).to.be.an(<span class="string">'array'</span>);
  };

  <span class="comment">/**
   * ### .isNotArray(value, [message])
   *
   * Asserts that `value` is _not_ an array.
   *
   *     var menu = 'green|chai|oolong';
   *     assert.isNotArray(menu, 'what kind of tea do we want?');
   *
   * @name isNotArray
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */</span>

  assert.isNotArray = <span class="function"><span class="keyword">function</span> <span class="params">(val, msg)</span> {</span>
    <span class="keyword">new</span> Assertion(val, msg).to.not.be.an(<span class="string">'array'</span>);
  };

  <span class="comment">/**
   * ### .isString(value, [message])
   *
   * Asserts that `value` is a string.
   *
   *     var teaOrder = 'chai';
   *     assert.isString(teaOrder, 'order placed');
   *
   * @name isString
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */</span>

  assert.isString = <span class="function"><span class="keyword">function</span> <span class="params">(val, msg)</span> {</span>
    <span class="keyword">new</span> Assertion(val, msg).to.be.a(<span class="string">'string'</span>);
  };

  <span class="comment">/**
   * ### .isNotString(value, [message])
   *
   * Asserts that `value` is _not_ a string.
   *
   *     var teaOrder = 4;
   *     assert.isNotString(teaOrder, 'order placed');
   *
   * @name isNotString
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */</span>

  assert.isNotString = <span class="function"><span class="keyword">function</span> <span class="params">(val, msg)</span> {</span>
    <span class="keyword">new</span> Assertion(val, msg).to.not.be.a(<span class="string">'string'</span>);
  };

  <span class="comment">/**
   * ### .isNumber(value, [message])
   *
   * Asserts that `value` is a number.
   *
   *     var cups = 2;
   *     assert.isNumber(cups, 'how many cups');
   *
   * @name isNumber
   * @param {Number} value
   * @param {String} message
   * @api public
   */</span>

  assert.isNumber = <span class="function"><span class="keyword">function</span> <span class="params">(val, msg)</span> {</span>
    <span class="keyword">new</span> Assertion(val, msg).to.be.a(<span class="string">'number'</span>);
  };

  <span class="comment">/**
   * ### .isNotNumber(value, [message])
   *
   * Asserts that `value` is _not_ a number.
   *
   *     var cups = '2 cups please';
   *     assert.isNotNumber(cups, 'how many cups');
   *
   * @name isNotNumber
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */</span>

  assert.isNotNumber = <span class="function"><span class="keyword">function</span> <span class="params">(val, msg)</span> {</span>
    <span class="keyword">new</span> Assertion(val, msg).to.not.be.a(<span class="string">'number'</span>);
  };

  <span class="comment">/**
   * ### .isBoolean(value, [message])
   *
   * Asserts that `value` is a boolean.
   *
   *     var teaReady = true
   *       , teaServed = false;
   *
   *     assert.isBoolean(teaReady, 'is the tea ready');
   *     assert.isBoolean(teaServed, 'has tea been served');
   *
   * @name isBoolean
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */</span>

  assert.isBoolean = <span class="function"><span class="keyword">function</span> <span class="params">(val, msg)</span> {</span>
    <span class="keyword">new</span> Assertion(val, msg).to.be.a(<span class="string">'boolean'</span>);
  };

  <span class="comment">/**
   * ### .isNotBoolean(value, [message])
   *
   * Asserts that `value` is _not_ a boolean.
   *
   *     var teaReady = 'yep'
   *       , teaServed = 'nope';
   *
   *     assert.isNotBoolean(teaReady, 'is the tea ready');
   *     assert.isNotBoolean(teaServed, 'has tea been served');
   *
   * @name isNotBoolean
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */</span>

  assert.isNotBoolean = <span class="function"><span class="keyword">function</span> <span class="params">(val, msg)</span> {</span>
    <span class="keyword">new</span> Assertion(val, msg).to.not.be.a(<span class="string">'boolean'</span>);
  };

  <span class="comment">/**
   * ### .typeOf(value, name, [message])
   *
   * Asserts that `value`'s type is `name`, as determined by
   * `Object.prototype.toString`.
   *
   *     assert.typeOf({ tea: 'chai' }, 'object', 'we have an object');
   *     assert.typeOf(['chai', 'jasmine'], 'array', 'we have an array');
   *     assert.typeOf('tea', 'string', 'we have a string');
   *     assert.typeOf(/tea/, 'regexp', 'we have a regular expression');
   *     assert.typeOf(null, 'null', 'we have a null');
   *     assert.typeOf(undefined, 'undefined', 'we have an undefined');
   *
   * @name typeOf
   * @param {Mixed} value
   * @param {String} name
   * @param {String} message
   * @api public
   */</span>

  assert.typeOf = <span class="function"><span class="keyword">function</span> <span class="params">(val, type, msg)</span> {</span>
    <span class="keyword">new</span> Assertion(val, msg).to.be.a(type);
  };

  <span class="comment">/**
   * ### .notTypeOf(value, name, [message])
   *
   * Asserts that `value`'s type is _not_ `name`, as determined by
   * `Object.prototype.toString`.
   *
   *     assert.notTypeOf('tea', 'number', 'strings are not numbers');
   *
   * @name notTypeOf
   * @param {Mixed} value
   * @param {String} typeof name
   * @param {String} message
   * @api public
   */</span>

  assert.notTypeOf = <span class="function"><span class="keyword">function</span> <span class="params">(val, type, msg)</span> {</span>
    <span class="keyword">new</span> Assertion(val, msg).to.not.be.a(type);
  };

  <span class="comment">/**
   * ### .instanceOf(object, constructor, [message])
   *
   * Asserts that `value` is an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , chai = new Tea('chai');
   *
   *     assert.instanceOf(chai, Tea, 'chai is an instance of tea');
   *
   * @name instanceOf
   * @param {Object} object
   * @param {Constructor} constructor
   * @param {String} message
   * @api public
   */</span>

  assert.instanceOf = <span class="function"><span class="keyword">function</span> <span class="params">(val, type, msg)</span> {</span>
    <span class="keyword">new</span> Assertion(val, msg).to.be.instanceOf(type);
  };

  <span class="comment">/**
   * ### .notInstanceOf(object, constructor, [message])
   *
   * Asserts `value` is not an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , chai = new String('chai');
   *
   *     assert.notInstanceOf(chai, Tea, 'chai is not an instance of tea');
   *
   * @name notInstanceOf
   * @param {Object} object
   * @param {Constructor} constructor
   * @param {String} message
   * @api public
   */</span>

  assert.notInstanceOf = <span class="function"><span class="keyword">function</span> <span class="params">(val, type, msg)</span> {</span>
    <span class="keyword">new</span> Assertion(val, msg).to.not.be.instanceOf(type);
  };

  <span class="comment">/**
   * ### .include(haystack, needle, [message])
   *
   * Asserts that `haystack` includes `needle`. Works
   * for strings and arrays.
   *
   *     assert.include('foobar', 'bar', 'foobar contains string "bar"');
   *     assert.include([ 1, 2, 3 ], 3, 'array contains value');
   *
   * @name include
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @api public
   */</span>

  assert.include = <span class="function"><span class="keyword">function</span> <span class="params">(exp, inc, msg)</span> {</span>
    <span class="keyword">var</span> obj = <span class="keyword">new</span> Assertion(exp, msg);

    <span class="keyword">if</span> (Array.isArray(exp)) {
      obj.to.include(inc);
    } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">'string'</span> === <span class="keyword">typeof</span> exp) {
      obj.to.contain.string(inc);
    } <span class="keyword">else</span> {
      <span class="keyword">throw</span> <span class="keyword">new</span> chai.AssertionError(
          <span class="string">'expected an array or string'</span>
        , <span class="literal">null</span>
        , assert.include
      );
    }
  };

  <span class="comment">/**
   * ### .notInclude(haystack, needle, [message])
   *
   * Asserts that `haystack` does not include `needle`. Works
   * for strings and arrays.
   *i
   *     assert.notInclude('foobar', 'baz', 'string not include substring');
   *     assert.notInclude([ 1, 2, 3 ], 4, 'array not include contain value');
   *
   * @name notInclude
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @api public
   */</span>

  assert.notInclude = <span class="function"><span class="keyword">function</span> <span class="params">(exp, inc, msg)</span> {</span>
    <span class="keyword">var</span> obj = <span class="keyword">new</span> Assertion(exp, msg);

    <span class="keyword">if</span> (Array.isArray(exp)) {
      obj.to.not.include(inc);
    } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">'string'</span> === <span class="keyword">typeof</span> exp) {
      obj.to.not.contain.string(inc);
    } <span class="keyword">else</span> {
      <span class="keyword">throw</span> <span class="keyword">new</span> chai.AssertionError(
          <span class="string">'expected an array or string'</span>
        , <span class="literal">null</span>
        , assert.notInclude
      );
    }
  };

  <span class="comment">/**
   * ### .match(value, regexp, [message])
   *
   * Asserts that `value` matches the regular expression `regexp`.
   *
   *     assert.match('foobar', /^foo/, 'regexp matches');
   *
   * @name match
   * @param {Mixed} value
   * @param {RegExp} regexp
   * @param {String} message
   * @api public
   */</span>

  assert.match = <span class="function"><span class="keyword">function</span> <span class="params">(exp, re, msg)</span> {</span>
    <span class="keyword">new</span> Assertion(exp, msg).to.match(re);
  };

  <span class="comment">/**
   * ### .notMatch(value, regexp, [message])
   *
   * Asserts that `value` does not match the regular expression `regexp`.
   *
   *     assert.notMatch('foobar', /^foo/, 'regexp does not match');
   *
   * @name notMatch
   * @param {Mixed} value
   * @param {RegExp} regexp
   * @param {String} message
   * @api public
   */</span>

  assert.notMatch = <span class="function"><span class="keyword">function</span> <span class="params">(exp, re, msg)</span> {</span>
    <span class="keyword">new</span> Assertion(exp, msg).to.not.match(re);
  };

  <span class="comment">/**
   * ### .property(object, property, [message])
   *
   * Asserts that `object` has a property named by `property`.
   *
   *     assert.property({ tea: { green: 'matcha' }}, 'tea');
   *
   * @name property
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */</span>

  assert.property = <span class="function"><span class="keyword">function</span> <span class="params">(obj, prop, msg)</span> {</span>
    <span class="keyword">new</span> Assertion(obj, msg).to.have.property(prop);
  };

  <span class="comment">/**
   * ### .notProperty(object, property, [message])
   *
   * Asserts that `object` does _not_ have a property named by `property`.
   *
   *     assert.notProperty({ tea: { green: 'matcha' }}, 'coffee');
   *
   * @name notProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */</span>

  assert.notProperty = <span class="function"><span class="keyword">function</span> <span class="params">(obj, prop, msg)</span> {</span>
    <span class="keyword">new</span> Assertion(obj, msg).to.not.have.property(prop);
  };

  <span class="comment">/**
   * ### .deepProperty(object, property, [message])
   *
   * Asserts that `object` has a property named by `property`, which can be a
   * string using dot- and bracket-notation for deep reference.
   *
   *     assert.deepProperty({ tea: { green: 'matcha' }}, 'tea.green');
   *
   * @name deepProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */</span>

  assert.deepProperty = <span class="function"><span class="keyword">function</span> <span class="params">(obj, prop, msg)</span> {</span>
    <span class="keyword">new</span> Assertion(obj, msg).to.have.deep.property(prop);
  };

  <span class="comment">/**
   * ### .notDeepProperty(object, property, [message])
   *
   * Asserts that `object` does _not_ have a property named by `property`, which
   * can be a string using dot- and bracket-notation for deep reference.
   *
   *     assert.notDeepProperty({ tea: { green: 'matcha' }}, 'tea.oolong');
   *
   * @name notDeepProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */</span>

  assert.notDeepProperty = <span class="function"><span class="keyword">function</span> <span class="params">(obj, prop, msg)</span> {</span>
    <span class="keyword">new</span> Assertion(obj, msg).to.not.have.deep.property(prop);
  };

  <span class="comment">/**
   * ### .propertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property` with value given
   * by `value`.
   *
   *     assert.propertyVal({ tea: 'is good' }, 'tea', 'is good');
   *
   * @name propertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */</span>

  assert.propertyVal = <span class="function"><span class="keyword">function</span> <span class="params">(obj, prop, val, msg)</span> {</span>
    <span class="keyword">new</span> Assertion(obj, msg).to.have.property(prop, val);
  };

  <span class="comment">/**
   * ### .propertyNotVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property`, but with a value
   * different from that given by `value`.
   *
   *     assert.propertyNotVal({ tea: 'is good' }, 'tea', 'is bad');
   *
   * @name propertyNotVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */</span>

  assert.propertyNotVal = <span class="function"><span class="keyword">function</span> <span class="params">(obj, prop, val, msg)</span> {</span>
    <span class="keyword">new</span> Assertion(obj, msg).to.not.have.property(prop, val);
  };

  <span class="comment">/**
   * ### .deepPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property` with value given
   * by `value`. `property` can use dot- and bracket-notation for deep
   * reference.
   *
   *     assert.deepPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'matcha');
   *
   * @name deepPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */</span>

  assert.deepPropertyVal = <span class="function"><span class="keyword">function</span> <span class="params">(obj, prop, val, msg)</span> {</span>
    <span class="keyword">new</span> Assertion(obj, msg).to.have.deep.property(prop, val);
  };

  <span class="comment">/**
   * ### .deepPropertyNotVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property`, but with a value
   * different from that given by `value`. `property` can use dot- and
   * bracket-notation for deep reference.
   *
   *     assert.deepPropertyNotVal({ tea: { green: 'matcha' }}, 'tea.green', 'konacha');
   *
   * @name deepPropertyNotVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */</span>

  assert.deepPropertyNotVal = <span class="function"><span class="keyword">function</span> <span class="params">(obj, prop, val, msg)</span> {</span>
    <span class="keyword">new</span> Assertion(obj, msg).to.not.have.deep.property(prop, val);
  };

  <span class="comment">/**
   * ### .lengthOf(object, length, [message])
   *
   * Asserts that `object` has a `length` property with the expected value.
   *
   *     assert.lengthOf([1,2,3], 3, 'array has length of 3');
   *     assert.lengthOf('foobar', 5, 'string has length of 6');
   *
   * @name lengthOf
   * @param {Mixed} object
   * @param {Number} length
   * @param {String} message
   * @api public
   */</span>

  assert.lengthOf = <span class="function"><span class="keyword">function</span> <span class="params">(exp, len, msg)</span> {</span>
    <span class="keyword">new</span> Assertion(exp, msg).to.have.length(len);
  };

  <span class="comment">/**
   * ### .throws(function, [constructor/string/regexp], [string/regexp], [message])
   *
   * Asserts that `function` will throw an error that is an instance of
   * `constructor`, or alternately that it will throw an error with message
   * matching `regexp`.
   *
   *     assert.throw(fn, 'function throws a reference error');
   *     assert.throw(fn, /function throws a reference error/);
   *     assert.throw(fn, ReferenceError);
   *     assert.throw(fn, ReferenceError, 'function throws a reference error');
   *     assert.throw(fn, ReferenceError, /function throws a reference error/);
   *
   * @name throws
   * @alias throw
   * @alias Throw
   * @param {Function} function
   * @param {ErrorConstructor} constructor
   * @param {RegExp} regexp
   * @param {String} message
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @api public
   */</span>

  assert.Throw = <span class="function"><span class="keyword">function</span> <span class="params">(fn, errt, errs, msg)</span> {</span>
    <span class="keyword">if</span> (<span class="string">'string'</span> === <span class="keyword">typeof</span> errt || errt <span class="keyword">instanceof</span> RegExp) {
      errs = errt;
      errt = <span class="literal">null</span>;
    }

    <span class="keyword">new</span> Assertion(fn, msg).to.Throw(errt, errs);
  };

  <span class="comment">/**
   * ### .doesNotThrow(function, [constructor/regexp], [message])
   *
   * Asserts that `function` will _not_ throw an error that is an instance of
   * `constructor`, or alternately that it will not throw an error with message
   * matching `regexp`.
   *
   *     assert.doesNotThrow(fn, Error, 'function does not throw');
   *
   * @name doesNotThrow
   * @param {Function} function
   * @param {ErrorConstructor} constructor
   * @param {RegExp} regexp
   * @param {String} message
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @api public
   */</span>

  assert.doesNotThrow = <span class="function"><span class="keyword">function</span> <span class="params">(fn, type, msg)</span> {</span>
    <span class="keyword">if</span> (<span class="string">'string'</span> === <span class="keyword">typeof</span> type) {
      msg = type;
      type = <span class="literal">null</span>;
    }

    <span class="keyword">new</span> Assertion(fn, msg).to.not.Throw(type);
  };

  <span class="comment">/**
   * ### .operator(val1, operator, val2, [message])
   *
   * Compares two values using `operator`.
   *
   *     assert.operator(1, '&lt;', 2, 'everything is ok');
   *     assert.operator(1, '&gt;', 2, 'this will fail');
   *
   * @name operator
   * @param {Mixed} val1
   * @param {String} operator
   * @param {Mixed} val2
   * @param {String} message
   * @api public
   */</span>

  assert.operator = <span class="function"><span class="keyword">function</span> <span class="params">(val, operator, val2, msg)</span> {</span>
    <span class="keyword">if</span> (!~[<span class="string">'=='</span>, <span class="string">'==='</span>, <span class="string">'&gt;'</span>, <span class="string">'&gt;='</span>, <span class="string">'&lt;'</span>, <span class="string">'&lt;='</span>, <span class="string">'!='</span>, <span class="string">'!=='</span>].indexOf(operator)) {
      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'Invalid operator "'</span> + operator + <span class="string">'"'</span>);
    }
    <span class="keyword">var</span> test = <span class="keyword">new</span> Assertion(eval(val + operator + val2), msg);
    test.assert(
        <span class="literal">true</span> === flag(test, <span class="string">'object'</span>)
      , <span class="string">'expected '</span> + util.inspect(val) + <span class="string">' to be '</span> + operator + <span class="string">' '</span> + util.inspect(val2)
      , <span class="string">'expected '</span> + util.inspect(val) + <span class="string">' to not be '</span> + operator + <span class="string">' '</span> + util.inspect(val2) );
  };

  <span class="comment">/**
   * ### .closeTo(actual, expected, delta, [message])
   *
   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
   *
   *     assert.closeTo(1.5, 1, 0.5, 'numbers are close');
   *
   * @name closeTo
   * @param {Number} actual
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} message
   * @api public
   */</span>

  assert.closeTo = <span class="function"><span class="keyword">function</span> <span class="params">(act, exp, delta, msg)</span> {</span>
    <span class="keyword">new</span> Assertion(act, msg).to.be.closeTo(exp, delta);
  };

  <span class="comment">/**
   * ### .sameMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` have the same members.
   * Order is not taken into account.
   *
   *     assert.sameMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'same members');
   *
   * @name sameMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @api public
   */</span>

  assert.sameMembers = <span class="function"><span class="keyword">function</span> <span class="params">(set1, set2, msg)</span> {</span>
    <span class="keyword">new</span> Assertion(set1, msg).to.have.same.members(set2);
  }

  <span class="comment">/**
   * ### .includeMembers(superset, subset, [message])
   *
   * Asserts that `subset` is included in `superset`.
   * Order is not taken into account.
   *
   *     assert.includeMembers([ 1, 2, 3 ], [ 2, 1 ], 'include members');
   *
   * @name includeMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @api public
   */</span>

  assert.includeMembers = <span class="function"><span class="keyword">function</span> <span class="params">(superset, subset, msg)</span> {</span>
    <span class="keyword">new</span> Assertion(superset, msg).to.include.members(subset);
  }

  <span class="comment">/*!
   * Undocumented / untested
   */</span>

  assert.ifError = <span class="function"><span class="keyword">function</span> <span class="params">(val, msg)</span> {</span>
    <span class="keyword">new</span> Assertion(val, msg).to.not.be.ok;
  };

  <span class="comment">/*!
   * Aliases.
   */</span>

  (<span class="function"><span class="keyword">function</span> <span class="title">alias</span><span class="params">(name, as)</span>{</span>
    assert[as] = assert[name];
    <span class="keyword">return</span> alias;
  })
  (<span class="string">'Throw'</span>, <span class="string">'throw'</span>)
  (<span class="string">'Throw'</span>, <span class="string">'throws'</span>);
};

});
require.register(<span class="string">"chai/lib/chai/interface/expect.js"</span>, <span class="keyword">function</span>(exports, require, module){
<span class="comment">/*!
 * chai
 * Copyright(c) 2011-2013 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */</span>

module.exports = <span class="function"><span class="keyword">function</span> <span class="params">(chai, util)</span> {</span>
  chai.expect = <span class="function"><span class="keyword">function</span> <span class="params">(val, message)</span> {</span>
    <span class="keyword">return</span> <span class="keyword">new</span> chai.Assertion(val, message);
  };
};


});
require.register(<span class="string">"chai/lib/chai/interface/should.js"</span>, <span class="keyword">function</span>(exports, require, module){
<span class="comment">/*!
 * chai
 * Copyright(c) 2011-2013 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */</span>

module.exports = <span class="function"><span class="keyword">function</span> <span class="params">(chai, util)</span> {</span>
  <span class="keyword">var</span> Assertion = chai.Assertion;

  <span class="function"><span class="keyword">function</span> <span class="title">loadShould</span> <span class="params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>modify Object.prototype to have <code>should</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Object.defineProperty(Object.prototype, <span class="string">'should'</span>,
      {
        set: <span class="function"><span class="keyword">function</span> <span class="params">(value)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>See <a href="https://github.com/chaijs/chai/issues/86">https://github.com/chaijs/chai/issues/86</a>: this makes
<code>whatever.should = someValue</code> actually set <code>someValue</code>, which is
especially useful for <code>global.should = require(&#39;chai&#39;).should()</code>.</p>
<p>Note that we have to use [[DefineProperty]] instead of [[Put]]
since otherwise we would trigger this very setter!</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          Object.defineProperty(<span class="keyword">this</span>, <span class="string">'should'</span>, {
            value: value,
            enumerable: <span class="literal">true</span>,
            configurable: <span class="literal">true</span>,
            writable: <span class="literal">true</span>
          });
        }
      , get: <span class="keyword">function</span>(){
          <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> String || <span class="keyword">this</span> <span class="keyword">instanceof</span> Number) {
            <span class="keyword">return</span> <span class="keyword">new</span> Assertion(<span class="keyword">this</span>.constructor(<span class="keyword">this</span>));
          } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> Boolean) {
            <span class="keyword">return</span> <span class="keyword">new</span> Assertion(<span class="keyword">this</span> == <span class="literal">true</span>);
          }
          <span class="keyword">return</span> <span class="keyword">new</span> Assertion(<span class="keyword">this</span>);
        }
      , configurable: <span class="literal">true</span>
    });

    <span class="keyword">var</span> should = {};

    should.equal = <span class="function"><span class="keyword">function</span> <span class="params">(val1, val2, msg)</span> {</span>
      <span class="keyword">new</span> Assertion(val1, msg).to.equal(val2);
    };

    should.Throw = <span class="function"><span class="keyword">function</span> <span class="params">(fn, errt, errs, msg)</span> {</span>
      <span class="keyword">new</span> Assertion(fn, msg).to.Throw(errt, errs);
    };

    should.exist = <span class="function"><span class="keyword">function</span> <span class="params">(val, msg)</span> {</span>
      <span class="keyword">new</span> Assertion(val, msg).to.exist;
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>negation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    should.not = {}

    should.not.equal = <span class="function"><span class="keyword">function</span> <span class="params">(val1, val2, msg)</span> {</span>
      <span class="keyword">new</span> Assertion(val1, msg).to.not.equal(val2);
    };

    should.not.Throw = <span class="function"><span class="keyword">function</span> <span class="params">(fn, errt, errs, msg)</span> {</span>
      <span class="keyword">new</span> Assertion(fn, msg).to.not.Throw(errt, errs);
    };

    should.not.exist = <span class="function"><span class="keyword">function</span> <span class="params">(val, msg)</span> {</span>
      <span class="keyword">new</span> Assertion(val, msg).to.not.exist;
    }

    should[<span class="string">'throw'</span>] = should[<span class="string">'Throw'</span>];
    should.not[<span class="string">'throw'</span>] = should.not[<span class="string">'Throw'</span>];

    <span class="keyword">return</span> should;
  };

  chai.should = loadShould;
  chai.Should = loadShould;
};

});
require.register(<span class="string">"chai/lib/chai/utils/addChainableMethod.js"</span>, <span class="keyword">function</span>(exports, require, module){
<span class="comment">/*!
 * Chai - addChainingMethod utility
 * Copyright(c) 2012-2013 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */</span>

<span class="comment">/*!
 * Module dependencies
 */</span>

<span class="keyword">var</span> transferFlags = require(<span class="string">'./transferFlags'</span>);

<span class="comment">/*!
 * Module variables
 */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>Check whether <code>__proto__</code> is supported</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">var</span> hasProtoSupport = <span class="string">'__proto__'</span> <span class="keyword">in</span> Object;</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>Without <code>__proto__</code> support, this module will need to add properties to a function.
However, some Function.prototype methods cannot be overwritten,
and there seems no easy cross-platform way to detect them (@see chaijs/chai/issues/69).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">var</span> excludeNames = <span class="regexp">/^(?:length|name|arguments|caller)$/</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>Cache <code>Function</code> properties</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">var</span> call  = Function.prototype.call,
    apply = Function.prototype.apply;

<span class="comment">/**
 * ### addChainableMethod (ctx, name, method, chainingBehavior)
 *
 * Adds a method to an object, such that the method can also be chained.
 *
 *     utils.addChainableMethod(chai.Assertion.prototype, 'foo', function (str) {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.equal(str);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addChainableMethod('foo', fn, chainingBehavior);
 *
 * The result can then be used as both a method assertion, executing both `method` and
 * `chainingBehavior`, or as a language chain, which only executes `chainingBehavior`.
 *
 *     expect(fooStr).to.be.foo('bar');
 *     expect(fooStr).to.be.foo.equal('foo');
 *
 * @param {Object} ctx object to which the method is added
 * @param {String} name of method to add
 * @param {Function} method function to be used for `name`, when called
 * @param {Function} chainingBehavior function to be called every time the property is accessed
 * @name addChainableMethod
 * @api public
 */</span>

module.exports = <span class="function"><span class="keyword">function</span> <span class="params">(ctx, name, method, chainingBehavior)</span> {</span>
  <span class="keyword">if</span> (<span class="keyword">typeof</span> chainingBehavior !== <span class="string">'function'</span>)
    chainingBehavior = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span> };

  Object.defineProperty(ctx, name,
    { get: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        chainingBehavior.call(<span class="keyword">this</span>);

        <span class="keyword">var</span> assert = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
          <span class="keyword">var</span> result = method.apply(<span class="keyword">this</span>, arguments);
          <span class="keyword">return</span> result === <span class="literal">undefined</span> ? <span class="keyword">this</span> : result;
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>Use <code>__proto__</code> if available</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">if</span> (hasProtoSupport) {</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>Inherit all properties from the object by replacing the <code>Function</code> prototype</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="keyword">var</span> prototype = assert.__proto__ = Object.create(<span class="keyword">this</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>Restore the <code>call</code> and <code>apply</code> methods from <code>Function</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          prototype.call = call;
          prototype.apply = apply;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>Otherwise, redefine all properties (slow!)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">else</span> {
          <span class="keyword">var</span> asserterNames = Object.getOwnPropertyNames(ctx);
          asserterNames.forEach(<span class="function"><span class="keyword">function</span> <span class="params">(asserterName)</span> {</span>
            <span class="keyword">if</span> (!excludeNames.test(asserterName)) {
              <span class="keyword">var</span> pd = Object.getOwnPropertyDescriptor(ctx, asserterName);
              Object.defineProperty(assert, asserterName, pd);
            }
          });
        }

        transferFlags(<span class="keyword">this</span>, assert);
        <span class="keyword">return</span> assert;
      }
    , configurable: <span class="literal">true</span>
  });
};

});
require.register(<span class="string">"chai/lib/chai/utils/addMethod.js"</span>, <span class="keyword">function</span>(exports, require, module){
<span class="comment">/*!
 * Chai - addMethod utility
 * Copyright(c) 2012-2013 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */</span>

<span class="comment">/**
 * ### .addMethod (ctx, name, method)
 *
 * Adds a method to the prototype of an object.
 *
 *     utils.addMethod(chai.Assertion.prototype, 'foo', function (str) {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.equal(str);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addMethod('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(fooStr).to.be.foo('bar');
 *
 * @param {Object} ctx object to which the method is added
 * @param {String} name of method to add
 * @param {Function} method function to be used for name
 * @name addMethod
 * @api public
 */</span>

module.exports = <span class="function"><span class="keyword">function</span> <span class="params">(ctx, name, method)</span> {</span>
  ctx[name] = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">var</span> result = method.apply(<span class="keyword">this</span>, arguments);
    <span class="keyword">return</span> result === <span class="literal">undefined</span> ? <span class="keyword">this</span> : result;
  };
};

});
require.register(<span class="string">"chai/lib/chai/utils/addProperty.js"</span>, <span class="keyword">function</span>(exports, require, module){
<span class="comment">/*!
 * Chai - addProperty utility
 * Copyright(c) 2012-2013 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */</span>

<span class="comment">/**
 * ### addProperty (ctx, name, getter)
 *
 * Adds a property to the prototype of an object.
 *
 *     utils.addProperty(chai.Assertion.prototype, 'foo', function () {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.instanceof(Foo);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addProperty('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.be.foo;
 *
 * @param {Object} ctx object to which the property is added
 * @param {String} name of property to add
 * @param {Function} getter function to be used for name
 * @name addProperty
 * @api public
 */</span>

module.exports = <span class="function"><span class="keyword">function</span> <span class="params">(ctx, name, getter)</span> {</span>
  Object.defineProperty(ctx, name,
    { get: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">var</span> result = getter.call(<span class="keyword">this</span>);
        <span class="keyword">return</span> result === <span class="literal">undefined</span> ? <span class="keyword">this</span> : result;
      }
    , configurable: <span class="literal">true</span>
  });
};

});
require.register(<span class="string">"chai/lib/chai/utils/eql.js"</span>, <span class="keyword">function</span>(exports, require, module){</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>This is (almost) directly from Node.js assert
<a href="https://github.com/joyent/node/blob/f8c335d0caf47f16d31413f89aa28eda3878e3aa/lib/assert.js">https://github.com/joyent/node/blob/f8c335d0caf47f16d31413f89aa28eda3878e3aa/lib/assert.js</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>module.exports = _deepEqual;

<span class="keyword">var</span> getEnumerableProperties = require(<span class="string">'./getEnumerableProperties'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>for the browser</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">var</span> Buffer;
<span class="keyword">try</span> {
  Buffer = require(<span class="string">'buffer'</span>).Buffer;
} <span class="keyword">catch</span> (ex) {
  Buffer = {
    isBuffer: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span> <span class="keyword">return</span> <span class="literal">false</span>; }
  };
}

<span class="function"><span class="keyword">function</span> <span class="title">_deepEqual</span><span class="params">(actual, expected, memos)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>7.1. All identical values are equivalent, as determined by ===.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">if</span> (actual === expected) {
    <span class="keyword">return</span> <span class="literal">true</span>;

  } <span class="keyword">else</span> <span class="keyword">if</span> (Buffer.isBuffer(actual) &amp;&amp; Buffer.isBuffer(expected)) {
    <span class="keyword">if</span> (actual.length != expected.length) <span class="keyword">return</span> <span class="literal">false</span>;

    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; actual.length; i++) {
      <span class="keyword">if</span> (actual[i] !== expected[i]) <span class="keyword">return</span> <span class="literal">false</span>;
    }

    <span class="keyword">return</span> <span class="literal">true</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>7.2. If the expected value is a Date object, the actual value is
equivalent if it is also a Date object that refers to the same time.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  } <span class="keyword">else</span> <span class="keyword">if</span> (expected <span class="keyword">instanceof</span> Date) {
    <span class="keyword">if</span> (!(actual <span class="keyword">instanceof</span> Date)) <span class="keyword">return</span> <span class="literal">false</span>;
    <span class="keyword">return</span> actual.getTime() === expected.getTime();</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>7.3. Other pairs that do not both pass typeof value == &#39;object&#39;,
equivalence is determined by ==.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> actual != <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> expected != <span class="string">'object'</span>) {
    <span class="keyword">return</span> actual === expected;

  } <span class="keyword">else</span> <span class="keyword">if</span> (expected <span class="keyword">instanceof</span> RegExp) {
    <span class="keyword">if</span> (!(actual <span class="keyword">instanceof</span> RegExp)) <span class="keyword">return</span> <span class="literal">false</span>;
    <span class="keyword">return</span> actual.toString() === expected.toString();</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>7.4. For all other Object pairs, including Array objects, equivalence is
determined by having the same number of owned properties (as verified
with Object.prototype.hasOwnProperty.call), the same set of keys
(although not necessarily the same order), equivalent values for every
corresponding key, and an identical &#39;prototype&#39; property. Note: this
accounts for both named and indexed properties on Arrays.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  } <span class="keyword">else</span> {
    <span class="keyword">return</span> objEquiv(actual, expected, memos);
  }
}

<span class="function"><span class="keyword">function</span> <span class="title">isUndefinedOrNull</span><span class="params">(value)</span> {</span>
  <span class="keyword">return</span> value === <span class="literal">null</span> || value === <span class="literal">undefined</span>;
}

<span class="function"><span class="keyword">function</span> <span class="title">isArguments</span><span class="params">(object)</span> {</span>
  <span class="keyword">return</span> Object.prototype.toString.call(object) == <span class="string">'[object Arguments]'</span>;
}

<span class="function"><span class="keyword">function</span> <span class="title">objEquiv</span><span class="params">(a, b, memos)</span> {</span>
  <span class="keyword">if</span> (isUndefinedOrNull(a) || isUndefinedOrNull(b))
    <span class="keyword">return</span> <span class="literal">false</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>an identical &#39;prototype&#39; property.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">if</span> (a.prototype !== b.prototype) <span class="keyword">return</span> <span class="literal">false</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>check if we have already compared a and b</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">var</span> i;
  <span class="keyword">if</span> (memos) {
    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; memos.length; i++) {
      <span class="keyword">if</span> ((memos[i][<span class="number">0</span>] === a &amp;&amp; memos[i][<span class="number">1</span>] === b) ||
          (memos[i][<span class="number">0</span>] === b &amp;&amp; memos[i][<span class="number">1</span>] === a))
        <span class="keyword">return</span> <span class="literal">true</span>;
    }
  } <span class="keyword">else</span> {
    memos = [];
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>~~~I&#39;ve managed to break Object.keys through screwy arguments passing.
  Converting to array solves the problem.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">if</span> (isArguments(a)) {
    <span class="keyword">if</span> (!isArguments(b)) {
      <span class="keyword">return</span> <span class="literal">false</span>;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    <span class="keyword">return</span> _deepEqual(a, b, memos);
  }
  <span class="keyword">try</span> {
    <span class="keyword">var</span> ka = getEnumerableProperties(a),
        kb = getEnumerableProperties(b),
        key;
  } <span class="keyword">catch</span> (e) {<span class="comment">//happens when one is a string literal and the other isn't</span>
    <span class="keyword">return</span> <span class="literal">false</span>;
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p>having the same number of owned properties (keys incorporates
hasOwnProperty)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">if</span> (ka.length != kb.length)
    <span class="keyword">return</span> <span class="literal">false</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>the same set of keys (although not necessarily the same order),</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  ka.sort();
  kb.sort();</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>~~~cheap key test</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">for</span> (i = ka.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {
    <span class="keyword">if</span> (ka[i] != kb[i])
      <span class="keyword">return</span> <span class="literal">false</span>;
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p>remember objects we have compared to guard against circular references</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  memos.push([ a, b ]);</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p>equivalent values for every corresponding key, and
~~~possibly expensive deep test</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">for</span> (i = ka.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {
    key = ka[i];
    <span class="keyword">if</span> (!_deepEqual(a[key], b[key], memos)) <span class="keyword">return</span> <span class="literal">false</span>;
  }

  <span class="keyword">return</span> <span class="literal">true</span>;
}

});
require.register(<span class="string">"chai/lib/chai/utils/flag.js"</span>, <span class="keyword">function</span>(exports, require, module){
<span class="comment">/*!
 * Chai - flag utility
 * Copyright(c) 2012-2013 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */</span>

<span class="comment">/**
 * ### flag(object ,key, [value])
 *
 * Get or set a flag value on an object. If a
 * value is provided it will be set, else it will
 * return the currently set value or `undefined` if
 * the value is not set.
 *
 *     utils.flag(this, 'foo', 'bar'); // setter
 *     utils.flag(this, 'foo'); // getter, returns `bar`
 *
 * @param {Object} object (constructed Assertion
 * @param {String} key
 * @param {Mixed} value (optional)
 * @name flag
 * @api private
 */</span>

module.exports = <span class="function"><span class="keyword">function</span> <span class="params">(obj, key, value)</span> {</span>
  <span class="keyword">var</span> flags = obj.__flags || (obj.__flags = Object.create(<span class="literal">null</span>));
  <span class="keyword">if</span> (arguments.length === <span class="number">3</span>) {
    flags[key] = value;
  } <span class="keyword">else</span> {
    <span class="keyword">return</span> flags[key];
  }
};

});
require.register(<span class="string">"chai/lib/chai/utils/getActual.js"</span>, <span class="keyword">function</span>(exports, require, module){
<span class="comment">/*!
 * Chai - getActual utility
 * Copyright(c) 2012-2013 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */</span>

<span class="comment">/**
 * # getActual(object, [actual])
 *
 * Returns the `actual` value for an Assertion
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 */</span>

module.exports = <span class="function"><span class="keyword">function</span> <span class="params">(obj, args)</span> {</span>
  <span class="keyword">var</span> actual = args[<span class="number">4</span>];
  <span class="keyword">return</span> <span class="string">'undefined'</span> !== <span class="keyword">typeof</span> actual ? actual : obj._obj;
};

});
require.register(<span class="string">"chai/lib/chai/utils/getEnumerableProperties.js"</span>, <span class="keyword">function</span>(exports, require, module){
<span class="comment">/*!
 * Chai - getEnumerableProperties utility
 * Copyright(c) 2012-2013 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */</span>

<span class="comment">/**
 * ### .getEnumerableProperties(object)
 *
 * This allows the retrieval of enumerable property names of an object,
 * inherited or not.
 *
 * @param {Object} object
 * @returns {Array}
 * @name getEnumerableProperties
 * @api public
 */</span>

module.exports = <span class="function"><span class="keyword">function</span> <span class="title">getEnumerableProperties</span><span class="params">(object)</span> {</span>
  <span class="keyword">var</span> result = [];
  <span class="keyword">for</span> (<span class="keyword">var</span> name <span class="keyword">in</span> object) {
    result.push(name);
  }
  <span class="keyword">return</span> result;
};

});
require.register(<span class="string">"chai/lib/chai/utils/getMessage.js"</span>, <span class="keyword">function</span>(exports, require, module){
<span class="comment">/*!
 * Chai - message composition utility
 * Copyright(c) 2012-2013 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */</span>

<span class="comment">/*!
 * Module dependancies
 */</span>

<span class="keyword">var</span> flag = require(<span class="string">'./flag'</span>)
  , getActual = require(<span class="string">'./getActual'</span>)
  , inspect = require(<span class="string">'./inspect'</span>)
  , objDisplay = require(<span class="string">'./objDisplay'</span>);

<span class="comment">/**
 * ### .getMessage(object, message, negateMessage)
 *
 * Construct the error message based on flags
 * and template tags. Template tags will return
 * a stringified inspection of the object referenced.
 *
 * Message template tags:
 * - `#{this}` current asserted object
 * - `#{act}` actual value
 * - `#{exp}` expected value
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 * @name getMessage
 * @api public
 */</span>

module.exports = <span class="function"><span class="keyword">function</span> <span class="params">(obj, args)</span> {</span>
  <span class="keyword">var</span> negate = flag(obj, <span class="string">'negate'</span>)
    , val = flag(obj, <span class="string">'object'</span>)
    , expected = args[<span class="number">3</span>]
    , actual = getActual(obj, args)
    , msg = negate ? args[<span class="number">2</span>] : args[<span class="number">1</span>]
    , flagMsg = flag(obj, <span class="string">'message'</span>);

  msg = msg || <span class="string">''</span>;
  msg = msg
    .replace(<span class="regexp">/#{this}/g</span>, objDisplay(val))
    .replace(<span class="regexp">/#{act}/g</span>, objDisplay(actual))
    .replace(<span class="regexp">/#{exp}/g</span>, objDisplay(expected));

  <span class="keyword">return</span> flagMsg ? flagMsg + <span class="string">': '</span> + msg : msg;
};

});
require.register(<span class="string">"chai/lib/chai/utils/getName.js"</span>, <span class="keyword">function</span>(exports, require, module){
<span class="comment">/*!
 * Chai - getName utility
 * Copyright(c) 2012-2013 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */</span>

<span class="comment">/**
 * # getName(func)
 *
 * Gets the name of a function, in a cross-browser way.
 *
 * @param {Function} a function (usually a constructor)
 */</span>

module.exports = <span class="function"><span class="keyword">function</span> <span class="params">(func)</span> {</span>
  <span class="keyword">if</span> (func.name) <span class="keyword">return</span> func.name;

  <span class="keyword">var</span> match = <span class="regexp">/^\s?function ([^(]*)\(/</span>.exec(func);
  <span class="keyword">return</span> match &amp;&amp; match[<span class="number">1</span>] ? match[<span class="number">1</span>] : <span class="string">""</span>;
};

});
require.register(<span class="string">"chai/lib/chai/utils/getPathValue.js"</span>, <span class="keyword">function</span>(exports, require, module){
<span class="comment">/*!
 * Chai - getPathValue utility
 * Copyright(c) 2012-2013 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * @see https://github.com/logicalparadox/filtr
 * MIT Licensed
 */</span>

<span class="comment">/**
 * ### .getPathValue(path, object)
 *
 * This allows the retrieval of values in an
 * object given a string path.
 *
 *     var obj = {
 *         prop1: {
 *             arr: ['a', 'b', 'c']
 *           , str: 'Hello'
 *         }
 *       , prop2: {
 *             arr: [ { nested: 'Universe' } ]
 *           , str: 'Hello again!'
 *         }
 *     }
 *
 * The following would be the results.
 *
 *     getPathValue('prop1.str', obj); // Hello
 *     getPathValue('prop1.att[2]', obj); // b
 *     getPathValue('prop2.arr[0].nested', obj); // Universe
 *
 * @param {String} path
 * @param {Object} object
 * @returns {Object} value or `undefined`
 * @name getPathValue
 * @api public
 */</span>

<span class="keyword">var</span> getPathValue = module.exports = <span class="function"><span class="keyword">function</span> <span class="params">(path, obj)</span> {</span>
  <span class="keyword">var</span> parsed = parsePath(path);
  <span class="keyword">return</span> _getPathValue(parsed, obj);
};

<span class="comment">/*!
 * ## parsePath(path)
 *
 * Helper function used to parse string object
 * paths. Use in conjunction with `_getPathValue`.
 *
 *      var parsed = parsePath('myobject.property.subprop');
 *
 * ### Paths:
 *
 * * Can be as near infinitely deep and nested
 * * Arrays are also valid using the formal `myobject.document[3].property`.
 *
 * @param {String} path
 * @returns {Object} parsed
 * @api private
 */</span>

<span class="function"><span class="keyword">function</span> <span class="title">parsePath</span> <span class="params">(path)</span> {</span>
  <span class="keyword">var</span> str = path.replace(<span class="regexp">/\[/g</span>, <span class="string">'.['</span>)
    , parts = str.match(<span class="regexp">/(\\\.|[^.]+?)+/g</span>);
  <span class="keyword">return</span> parts.map(<span class="function"><span class="keyword">function</span> <span class="params">(value)</span> {</span>
    <span class="keyword">var</span> re = <span class="regexp">/\[(\d+)\]$/</span>
      , mArr = re.exec(value)
    <span class="keyword">if</span> (mArr) <span class="keyword">return</span> { i: parseFloat(mArr[<span class="number">1</span>]) };
    <span class="keyword">else</span> <span class="keyword">return</span> { p: value };
  });
};

<span class="comment">/*!
 * ## _getPathValue(parsed, obj)
 *
 * Helper companion function for `.parsePath` that returns
 * the value located at the parsed address.
 *
 *      var value = getPathValue(parsed, obj);
 *
 * @param {Object} parsed definition from `parsePath`.
 * @param {Object} object to search against
 * @returns {Object|Undefined} value
 * @api private
 */</span>

<span class="function"><span class="keyword">function</span> <span class="title">_getPathValue</span> <span class="params">(parsed, obj)</span> {</span>
  <span class="keyword">var</span> tmp = obj
    , res;
  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = parsed.length; i &lt; l; i++) {
    <span class="keyword">var</span> part = parsed[i];
    <span class="keyword">if</span> (tmp) {
      <span class="keyword">if</span> (<span class="string">'undefined'</span> !== <span class="keyword">typeof</span> part.p)
        tmp = tmp[part.p];
      <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">'undefined'</span> !== <span class="keyword">typeof</span> part.i)
        tmp = tmp[part.i];
      <span class="keyword">if</span> (i == (l - <span class="number">1</span>)) res = tmp;
    } <span class="keyword">else</span> {
      res = <span class="literal">undefined</span>;
    }
  }
  <span class="keyword">return</span> res;
};

});
require.register(<span class="string">"chai/lib/chai/utils/getProperties.js"</span>, <span class="keyword">function</span>(exports, require, module){
<span class="comment">/*!
 * Chai - getProperties utility
 * Copyright(c) 2012-2013 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */</span>

<span class="comment">/**
 * ### .getProperties(object)
 *
 * This allows the retrieval of property names of an object, enumerable or not,
 * inherited or not.
 *
 * @param {Object} object
 * @returns {Array}
 * @name getProperties
 * @api public
 */</span>

module.exports = <span class="function"><span class="keyword">function</span> <span class="title">getProperties</span><span class="params">(object)</span> {</span>
  <span class="keyword">var</span> result = Object.getOwnPropertyNames(subject);

  <span class="function"><span class="keyword">function</span> <span class="title">addProperty</span><span class="params">(property)</span> {</span>
    <span class="keyword">if</span> (result.indexOf(property) === -<span class="number">1</span>) {
      result.push(property);
    }
  }

  <span class="keyword">var</span> proto = Object.getPrototypeOf(subject);
  <span class="keyword">while</span> (proto !== <span class="literal">null</span>) {
    Object.getOwnPropertyNames(proto).forEach(addProperty);
    proto = Object.getPrototypeOf(proto);
  }

  <span class="keyword">return</span> result;
};

});
require.register(<span class="string">"chai/lib/chai/utils/index.js"</span>, <span class="keyword">function</span>(exports, require, module){
<span class="comment">/*!
 * chai
 * Copyright(c) 2011 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */</span>

<span class="comment">/*!
 * Main exports
 */</span>

<span class="keyword">var</span> exports = module.exports = {};

<span class="comment">/*!
 * test utility
 */</span>

exports.test = require(<span class="string">'./test'</span>);

<span class="comment">/*!
 * type utility
 */</span>

exports.type = require(<span class="string">'./type'</span>);

<span class="comment">/*!
 * message utility
 */</span>

exports.getMessage = require(<span class="string">'./getMessage'</span>);

<span class="comment">/*!
 * actual utility
 */</span>

exports.getActual = require(<span class="string">'./getActual'</span>);

<span class="comment">/*!
 * Inspect util
 */</span>

exports.inspect = require(<span class="string">'./inspect'</span>);

<span class="comment">/*!
 * Object Display util
 */</span>

exports.objDisplay = require(<span class="string">'./objDisplay'</span>);

<span class="comment">/*!
 * Flag utility
 */</span>

exports.flag = require(<span class="string">'./flag'</span>);

<span class="comment">/*!
 * Flag transferring utility
 */</span>

exports.transferFlags = require(<span class="string">'./transferFlags'</span>);

<span class="comment">/*!
 * Deep equal utility
 */</span>

exports.eql = require(<span class="string">'./eql'</span>);

<span class="comment">/*!
 * Deep path value
 */</span>

exports.getPathValue = require(<span class="string">'./getPathValue'</span>);

<span class="comment">/*!
 * Function name
 */</span>

exports.getName = require(<span class="string">'./getName'</span>);

<span class="comment">/*!
 * add Property
 */</span>

exports.addProperty = require(<span class="string">'./addProperty'</span>);

<span class="comment">/*!
 * add Method
 */</span>

exports.addMethod = require(<span class="string">'./addMethod'</span>);

<span class="comment">/*!
 * overwrite Property
 */</span>

exports.overwriteProperty = require(<span class="string">'./overwriteProperty'</span>);

<span class="comment">/*!
 * overwrite Method
 */</span>

exports.overwriteMethod = require(<span class="string">'./overwriteMethod'</span>);

<span class="comment">/*!
 * Add a chainable method
 */</span>

exports.addChainableMethod = require(<span class="string">'./addChainableMethod'</span>);


});
require.register(<span class="string">"chai/lib/chai/utils/inspect.js"</span>, <span class="keyword">function</span>(exports, require, module){</pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p>This is (almost) directly from Node.js utils
<a href="https://github.com/joyent/node/blob/f8c335d0caf47f16d31413f89aa28eda3878e3aa/lib/util.js">https://github.com/joyent/node/blob/f8c335d0caf47f16d31413f89aa28eda3878e3aa/lib/util.js</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">var</span> getName = require(<span class="string">'./getName'</span>);
<span class="keyword">var</span> getProperties = require(<span class="string">'./getProperties'</span>);
<span class="keyword">var</span> getEnumerableProperties = require(<span class="string">'./getEnumerableProperties'</span>);

module.exports = inspect;

<span class="comment">/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Boolean} showHidden Flag that shows hidden (not enumerable)
 *    properties of objects.
 * @param {Number} depth Depth in which to descend in object. Default is 2.
 * @param {Boolean} colors Flag to turn on ANSI escape codes to color the
 *    output. Default is false (no coloring).
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">inspect</span><span class="params">(obj, showHidden, depth, colors)</span> {</span>
  <span class="keyword">var</span> ctx = {
    showHidden: showHidden,
    seen: [],
    stylize: <span class="function"><span class="keyword">function</span> <span class="params">(str)</span> {</span> <span class="keyword">return</span> str; }
  };
  <span class="keyword">return</span> formatValue(ctx, obj, (<span class="keyword">typeof</span> depth === <span class="string">'undefined'</span> ? <span class="number">2</span> : depth));
}</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p><a href="https://gist.github.com/1044128/">https://gist.github.com/1044128/</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">var</span> getOuterHTML = <span class="keyword">function</span>(element) {
  <span class="keyword">if</span> (<span class="string">'outerHTML'</span> <span class="keyword">in</span> element) <span class="keyword">return</span> element.outerHTML;
  <span class="keyword">var</span> ns = <span class="string">"http://www.w3.org/1999/xhtml"</span>;
  <span class="keyword">var</span> container = document.createElementNS(ns, <span class="string">'_'</span>);
  <span class="keyword">var</span> elemProto = (window.HTMLElement || window.Element).prototype;
  <span class="keyword">var</span> xmlSerializer = <span class="keyword">new</span> XMLSerializer();
  <span class="keyword">var</span> html;
  <span class="keyword">if</span> (document.xmlVersion) {
    <span class="keyword">return</span> xmlSerializer.serializeToString(element);
  } <span class="keyword">else</span> {
    container.appendChild(element.cloneNode(<span class="literal">false</span>));
    html = container.innerHTML.replace(<span class="string">'&gt;&lt;'</span>, <span class="string">'&gt;'</span> + element.innerHTML + <span class="string">'&lt;'</span>);
    container.innerHTML = <span class="string">''</span>;
    <span class="keyword">return</span> html;
  }
};</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p>Returns true if object is a DOM element.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">var</span> isDOMElement = <span class="function"><span class="keyword">function</span> <span class="params">(object)</span> {</span>
  <span class="keyword">if</span> (<span class="keyword">typeof</span> HTMLElement === <span class="string">'object'</span>) {
    <span class="keyword">return</span> object <span class="keyword">instanceof</span> HTMLElement;
  } <span class="keyword">else</span> {
    <span class="keyword">return</span> object &amp;&amp;
      <span class="keyword">typeof</span> object === <span class="string">'object'</span> &amp;&amp;
      object.nodeType === <span class="number">1</span> &amp;&amp;
      <span class="keyword">typeof</span> object.nodeName === <span class="string">'string'</span>;
  }
};

<span class="function"><span class="keyword">function</span> <span class="title">formatValue</span><span class="params">(ctx, value, recurseTimes)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <p>Provide a hook for user-specified inspect functions.
Check that value is an object with an inspect function on it</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">if</span> (value &amp;&amp; <span class="keyword">typeof</span> value.inspect === <span class="string">'function'</span> &amp;&amp;</pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <p>Filter out the util module, it&#39;s inspect function is special</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      value.inspect !== exports.inspect &amp;&amp;</pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <p>Also filter out any prototype objects using the circular check.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      !(value.constructor &amp;&amp; value.constructor.prototype === value)) {
    <span class="keyword">var</span> ret = value.inspect(recurseTimes);
    <span class="keyword">if</span> (<span class="keyword">typeof</span> ret !== <span class="string">'string'</span>) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    <span class="keyword">return</span> ret;
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <p>Primitive types cannot have properties</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">var</span> primitive = formatPrimitive(ctx, value);
  <span class="keyword">if</span> (primitive) {
    <span class="keyword">return</span> primitive;
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <p>If it&#39;s DOM elem, get outer HTML.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">if</span> (isDOMElement(value)) {
    <span class="keyword">return</span> getOuterHTML(value);
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <p>Look up the keys of the object.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">var</span> visibleKeys = getEnumerableProperties(value);
  <span class="keyword">var</span> keys = ctx.showHidden ? getProperties(value) : visibleKeys;</pre></div></div>
            
        </li>
        
        
        <li id="section-51">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>
              <p>Some type of object without properties can be shortcutted.
In IE, errors have a single <code>stack</code> property, or if they are vanilla <code>Error</code>,
a <code>stack</code> plus <code>description</code> property; ignore those for consistency.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">if</span> (keys.length === <span class="number">0</span> || (isError(value) &amp;&amp; (
      (keys.length === <span class="number">1</span> &amp;&amp; keys[<span class="number">0</span>] === <span class="string">'stack'</span>) ||
      (keys.length === <span class="number">2</span> &amp;&amp; keys[<span class="number">0</span>] === <span class="string">'description'</span> &amp;&amp; keys[<span class="number">1</span>] === <span class="string">'stack'</span>)
     ))) {
    <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">'function'</span>) {
      <span class="keyword">var</span> name = getName(value);
      <span class="keyword">var</span> nameSuffix = name ? <span class="string">': '</span> + name : <span class="string">''</span>;
      <span class="keyword">return</span> ctx.stylize(<span class="string">'[Function'</span> + nameSuffix + <span class="string">']'</span>, <span class="string">'special'</span>);
    }
    <span class="keyword">if</span> (isRegExp(value)) {
      <span class="keyword">return</span> ctx.stylize(RegExp.prototype.toString.call(value), <span class="string">'regexp'</span>);
    }
    <span class="keyword">if</span> (isDate(value)) {
      <span class="keyword">return</span> ctx.stylize(Date.prototype.toUTCString.call(value), <span class="string">'date'</span>);
    }
    <span class="keyword">if</span> (isError(value)) {
      <span class="keyword">return</span> formatError(value);
    }
  }

  <span class="keyword">var</span> base = <span class="string">''</span>, array = <span class="literal">false</span>, braces = [<span class="string">'{'</span>, <span class="string">'}'</span>];</pre></div></div>
            
        </li>
        
        
        <li id="section-52">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-52">&#182;</a>
              </div>
              <p>Make Array say that they are Array</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">if</span> (isArray(value)) {
    array = <span class="literal">true</span>;
    braces = [<span class="string">'['</span>, <span class="string">']'</span>];
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-53">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-53">&#182;</a>
              </div>
              <p>Make functions say that they are functions</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">'function'</span>) {
    <span class="keyword">var</span> name = getName(value);
    <span class="keyword">var</span> nameSuffix = name ? <span class="string">': '</span> + name : <span class="string">''</span>;
    base = <span class="string">' [Function'</span> + nameSuffix + <span class="string">']'</span>;
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-54">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-54">&#182;</a>
              </div>
              <p>Make RegExps say that they are RegExps</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">if</span> (isRegExp(value)) {
    base = <span class="string">' '</span> + RegExp.prototype.toString.call(value);
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-55">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-55">&#182;</a>
              </div>
              <p>Make dates with properties first say the date</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">if</span> (isDate(value)) {
    base = <span class="string">' '</span> + Date.prototype.toUTCString.call(value);
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-56">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-56">&#182;</a>
              </div>
              <p>Make error with message first say the error</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">if</span> (isError(value)) {
    <span class="keyword">return</span> formatError(value);
  }

  <span class="keyword">if</span> (keys.length === <span class="number">0</span> &amp;&amp; (!array || value.length == <span class="number">0</span>)) {
    <span class="keyword">return</span> braces[<span class="number">0</span>] + base + braces[<span class="number">1</span>];
  }

  <span class="keyword">if</span> (recurseTimes &lt; <span class="number">0</span>) {
    <span class="keyword">if</span> (isRegExp(value)) {
      <span class="keyword">return</span> ctx.stylize(RegExp.prototype.toString.call(value), <span class="string">'regexp'</span>);
    } <span class="keyword">else</span> {
      <span class="keyword">return</span> ctx.stylize(<span class="string">'[Object]'</span>, <span class="string">'special'</span>);
    }
  }

  ctx.seen.push(value);

  <span class="keyword">var</span> output;
  <span class="keyword">if</span> (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } <span class="keyword">else</span> {
    output = keys.map(<span class="keyword">function</span>(key) {
      <span class="keyword">return</span> formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  <span class="keyword">return</span> reduceToSingleString(output, base, braces);
}


<span class="function"><span class="keyword">function</span> <span class="title">formatPrimitive</span><span class="params">(ctx, value)</span> {</span>
  <span class="keyword">switch</span> (<span class="keyword">typeof</span> value) {
    <span class="keyword">case</span> <span class="string">'undefined'</span>:
      <span class="keyword">return</span> ctx.stylize(<span class="string">'undefined'</span>, <span class="string">'undefined'</span>);

    <span class="keyword">case</span> <span class="string">'string'</span>:
      <span class="keyword">var</span> simple = <span class="string">'\''</span> + JSON.stringify(value).replace(<span class="regexp">/^"|"$/g</span>, <span class="string">''</span>)
                                               .replace(<span class="regexp">/'/g</span>, <span class="string">"\\'"</span>)
                                               .replace(<span class="regexp">/\\"/g</span>, <span class="string">'"'</span>) + <span class="string">'\''</span>;
      <span class="keyword">return</span> ctx.stylize(simple, <span class="string">'string'</span>);

    <span class="keyword">case</span> <span class="string">'number'</span>:
      <span class="keyword">return</span> ctx.stylize(<span class="string">''</span> + value, <span class="string">'number'</span>);

    <span class="keyword">case</span> <span class="string">'boolean'</span>:
      <span class="keyword">return</span> ctx.stylize(<span class="string">''</span> + value, <span class="string">'boolean'</span>);
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-57">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-57">&#182;</a>
              </div>
              <p>For some reason typeof null is &quot;object&quot;, so special case here.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">if</span> (value === <span class="literal">null</span>) {
    <span class="keyword">return</span> ctx.stylize(<span class="string">'null'</span>, <span class="string">'null'</span>);
  }
}


<span class="function"><span class="keyword">function</span> <span class="title">formatError</span><span class="params">(value)</span> {</span>
  <span class="keyword">return</span> <span class="string">'['</span> + Error.prototype.toString.call(value) + <span class="string">']'</span>;
}


<span class="function"><span class="keyword">function</span> <span class="title">formatArray</span><span class="params">(ctx, value, recurseTimes, visibleKeys, keys)</span> {</span>
  <span class="keyword">var</span> output = [];
  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = value.length; i &lt; l; ++i) {
    <span class="keyword">if</span> (Object.prototype.hasOwnProperty.call(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), <span class="literal">true</span>));
    } <span class="keyword">else</span> {
      output.push(<span class="string">''</span>);
    }
  }
  keys.forEach(<span class="keyword">function</span>(key) {
    <span class="keyword">if</span> (!key.match(<span class="regexp">/^\d+$/</span>)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, <span class="literal">true</span>));
    }
  });
  <span class="keyword">return</span> output;
}


<span class="function"><span class="keyword">function</span> <span class="title">formatProperty</span><span class="params">(ctx, value, recurseTimes, visibleKeys, key, array)</span> {</span>
  <span class="keyword">var</span> name, str;
  <span class="keyword">if</span> (value.__lookupGetter__) {
    <span class="keyword">if</span> (value.__lookupGetter__(key)) {
      <span class="keyword">if</span> (value.__lookupSetter__(key)) {
        str = ctx.stylize(<span class="string">'[Getter/Setter]'</span>, <span class="string">'special'</span>);
      } <span class="keyword">else</span> {
        str = ctx.stylize(<span class="string">'[Getter]'</span>, <span class="string">'special'</span>);
      }
    } <span class="keyword">else</span> {
      <span class="keyword">if</span> (value.__lookupSetter__(key)) {
        str = ctx.stylize(<span class="string">'[Setter]'</span>, <span class="string">'special'</span>);
      }
    }
  }
  <span class="keyword">if</span> (visibleKeys.indexOf(key) &lt; <span class="number">0</span>) {
    name = <span class="string">'['</span> + key + <span class="string">']'</span>;
  }
  <span class="keyword">if</span> (!str) {
    <span class="keyword">if</span> (ctx.seen.indexOf(value[key]) &lt; <span class="number">0</span>) {
      <span class="keyword">if</span> (recurseTimes === <span class="literal">null</span>) {
        str = formatValue(ctx, value[key], <span class="literal">null</span>);
      } <span class="keyword">else</span> {
        str = formatValue(ctx, value[key], recurseTimes - <span class="number">1</span>);
      }
      <span class="keyword">if</span> (str.indexOf(<span class="string">'\n'</span>) &gt; -<span class="number">1</span>) {
        <span class="keyword">if</span> (array) {
          str = str.split(<span class="string">'\n'</span>).map(<span class="keyword">function</span>(line) {
            <span class="keyword">return</span> <span class="string">'  '</span> + line;
          }).join(<span class="string">'\n'</span>).substr(<span class="number">2</span>);
        } <span class="keyword">else</span> {
          str = <span class="string">'\n'</span> + str.split(<span class="string">'\n'</span>).map(<span class="keyword">function</span>(line) {
            <span class="keyword">return</span> <span class="string">'   '</span> + line;
          }).join(<span class="string">'\n'</span>);
        }
      }
    } <span class="keyword">else</span> {
      str = ctx.stylize(<span class="string">'[Circular]'</span>, <span class="string">'special'</span>);
    }
  }
  <span class="keyword">if</span> (<span class="keyword">typeof</span> name === <span class="string">'undefined'</span>) {
    <span class="keyword">if</span> (array &amp;&amp; key.match(<span class="regexp">/^\d+$/</span>)) {
      <span class="keyword">return</span> str;
    }
    name = JSON.stringify(<span class="string">''</span> + key);
    <span class="keyword">if</span> (name.match(<span class="regexp">/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/</span>)) {
      name = name.substr(<span class="number">1</span>, name.length - <span class="number">2</span>);
      name = ctx.stylize(name, <span class="string">'name'</span>);
    } <span class="keyword">else</span> {
      name = name.replace(<span class="regexp">/'/g</span>, <span class="string">"\\'"</span>)
                 .replace(<span class="regexp">/\\"/g</span>, <span class="string">'"'</span>)
                 .replace(<span class="regexp">/(^"|"$)/g</span>, <span class="string">"'"</span>);
      name = ctx.stylize(name, <span class="string">'string'</span>);
    }
  }

  <span class="keyword">return</span> name + <span class="string">': '</span> + str;
}


<span class="function"><span class="keyword">function</span> <span class="title">reduceToSingleString</span><span class="params">(output, base, braces)</span> {</span>
  <span class="keyword">var</span> numLinesEst = <span class="number">0</span>;
  <span class="keyword">var</span> length = output.reduce(<span class="keyword">function</span>(prev, cur) {
    numLinesEst++;
    <span class="keyword">if</span> (cur.indexOf(<span class="string">'\n'</span>) &gt;= <span class="number">0</span>) numLinesEst++;
    <span class="keyword">return</span> prev + cur.length + <span class="number">1</span>;
  }, <span class="number">0</span>);

  <span class="keyword">if</span> (length &gt; <span class="number">60</span>) {
    <span class="keyword">return</span> braces[<span class="number">0</span>] +
           (base === <span class="string">''</span> ? <span class="string">''</span> : base + <span class="string">'\n '</span>) +
           <span class="string">' '</span> +
           output.join(<span class="string">',\n  '</span>) +
           <span class="string">' '</span> +
           braces[<span class="number">1</span>];
  }

  <span class="keyword">return</span> braces[<span class="number">0</span>] + base + <span class="string">' '</span> + output.join(<span class="string">', '</span>) + <span class="string">' '</span> + braces[<span class="number">1</span>];
}

<span class="function"><span class="keyword">function</span> <span class="title">isArray</span><span class="params">(ar)</span> {</span>
  <span class="keyword">return</span> Array.isArray(ar) ||
         (<span class="keyword">typeof</span> ar === <span class="string">'object'</span> &amp;&amp; objectToString(ar) === <span class="string">'[object Array]'</span>);
}

<span class="function"><span class="keyword">function</span> <span class="title">isRegExp</span><span class="params">(re)</span> {</span>
  <span class="keyword">return</span> <span class="keyword">typeof</span> re === <span class="string">'object'</span> &amp;&amp; objectToString(re) === <span class="string">'[object RegExp]'</span>;
}

<span class="function"><span class="keyword">function</span> <span class="title">isDate</span><span class="params">(d)</span> {</span>
  <span class="keyword">return</span> <span class="keyword">typeof</span> d === <span class="string">'object'</span> &amp;&amp; objectToString(d) === <span class="string">'[object Date]'</span>;
}

<span class="function"><span class="keyword">function</span> <span class="title">isError</span><span class="params">(e)</span> {</span>
  <span class="keyword">return</span> <span class="keyword">typeof</span> e === <span class="string">'object'</span> &amp;&amp; objectToString(e) === <span class="string">'[object Error]'</span>;
}

<span class="function"><span class="keyword">function</span> <span class="title">objectToString</span><span class="params">(o)</span> {</span>
  <span class="keyword">return</span> Object.prototype.toString.call(o);
}

});
require.register(<span class="string">"chai/lib/chai/utils/objDisplay.js"</span>, <span class="keyword">function</span>(exports, require, module){
<span class="comment">/*!
 * Chai - flag utility
 * Copyright(c) 2012-2013 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */</span>

<span class="comment">/*!
 * Module dependancies
 */</span>

<span class="keyword">var</span> inspect = require(<span class="string">'./inspect'</span>);

<span class="comment">/**
 * ### .objDisplay (object)
 *
 * Determines if an object or an array matches
 * criteria to be inspected in-line for error
 * messages or should be truncated.
 *
 * @param {Mixed} javascript object to inspect
 * @name objDisplay
 * @api public
 */</span>

module.exports = <span class="function"><span class="keyword">function</span> <span class="params">(obj)</span> {</span>
  <span class="keyword">var</span> str = inspect(obj)
    , type = Object.prototype.toString.call(obj);

  <span class="keyword">if</span> (str.length &gt;= <span class="number">40</span>) {
    <span class="keyword">if</span> (type === <span class="string">'[object Function]'</span>) {
      <span class="keyword">return</span> !obj.name || obj.name === <span class="string">''</span>
        ? <span class="string">'[Function]'</span>
        : <span class="string">'[Function: '</span> + obj.name + <span class="string">']'</span>;
    } <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">'[object Array]'</span>) {
      <span class="keyword">return</span> <span class="string">'[ Array('</span> + obj.length + <span class="string">') ]'</span>;
    } <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">'[object Object]'</span>) {
      <span class="keyword">var</span> keys = Object.keys(obj)
        , kstr = keys.length &gt; <span class="number">2</span>
          ? keys.splice(<span class="number">0</span>, <span class="number">2</span>).join(<span class="string">', '</span>) + <span class="string">', ...'</span>
          : keys.join(<span class="string">', '</span>);
      <span class="keyword">return</span> <span class="string">'{ Object ('</span> + kstr + <span class="string">') }'</span>;
    } <span class="keyword">else</span> {
      <span class="keyword">return</span> str;
    }
  } <span class="keyword">else</span> {
    <span class="keyword">return</span> str;
  }
};

});
require.register(<span class="string">"chai/lib/chai/utils/overwriteMethod.js"</span>, <span class="keyword">function</span>(exports, require, module){
<span class="comment">/*!
 * Chai - overwriteMethod utility
 * Copyright(c) 2012-2013 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */</span>

<span class="comment">/**
 * ### overwriteMethod (ctx, name, fn)
 *
 * Overwites an already existing method and provides
 * access to previous function. Must return function
 * to be used for name.
 *
 *     utils.overwriteMethod(chai.Assertion.prototype, 'equal', function (_super) {
 *       return function (str) {
 *         var obj = utils.flag(this, 'object');
 *         if (obj instanceof Foo) {
 *           new chai.Assertion(obj.value).to.equal(str);
 *         } else {
 *           _super.apply(this, arguments);
 *         }
 *       }
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteMethod('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.equal('bar');
 *
 * @param {Object} ctx object whose method is to be overwritten
 * @param {String} name of method to overwrite
 * @param {Function} method function that returns a function to be used for name
 * @name overwriteMethod
 * @api public
 */</span>

module.exports = <span class="function"><span class="keyword">function</span> <span class="params">(ctx, name, method)</span> {</span>
  <span class="keyword">var</span> _method = ctx[name]
    , _super = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span> <span class="keyword">return</span> <span class="keyword">this</span>; };

  <span class="keyword">if</span> (_method &amp;&amp; <span class="string">'function'</span> === <span class="keyword">typeof</span> _method)
    _super = _method;

  ctx[name] = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">var</span> result = method(_super).apply(<span class="keyword">this</span>, arguments);
    <span class="keyword">return</span> result === <span class="literal">undefined</span> ? <span class="keyword">this</span> : result;
  }
};

});
require.register(<span class="string">"chai/lib/chai/utils/overwriteProperty.js"</span>, <span class="keyword">function</span>(exports, require, module){
<span class="comment">/*!
 * Chai - overwriteProperty utility
 * Copyright(c) 2012-2013 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */</span>

<span class="comment">/**
 * ### overwriteProperty (ctx, name, fn)
 *
 * Overwites an already existing property getter and provides
 * access to previous value. Must return function to use as getter.
 *
 *     utils.overwriteProperty(chai.Assertion.prototype, 'ok', function (_super) {
 *       return function () {
 *         var obj = utils.flag(this, 'object');
 *         if (obj instanceof Foo) {
 *           new chai.Assertion(obj.name).to.equal('bar');
 *         } else {
 *           _super.call(this);
 *         }
 *       }
 *     });
 *
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteProperty('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.be.ok;
 *
 * @param {Object} ctx object whose property is to be overwritten
 * @param {String} name of property to overwrite
 * @param {Function} getter function that returns a getter function to be used for name
 * @name overwriteProperty
 * @api public
 */</span>

module.exports = <span class="function"><span class="keyword">function</span> <span class="params">(ctx, name, getter)</span> {</span>
  <span class="keyword">var</span> _get = Object.getOwnPropertyDescriptor(ctx, name)
    , _super = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>};

  <span class="keyword">if</span> (_get &amp;&amp; <span class="string">'function'</span> === <span class="keyword">typeof</span> _get.get)
    _super = _get.get

  Object.defineProperty(ctx, name,
    { get: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">var</span> result = getter(_super).call(<span class="keyword">this</span>);
        <span class="keyword">return</span> result === <span class="literal">undefined</span> ? <span class="keyword">this</span> : result;
      }
    , configurable: <span class="literal">true</span>
  });
};

});
require.register(<span class="string">"chai/lib/chai/utils/test.js"</span>, <span class="keyword">function</span>(exports, require, module){
<span class="comment">/*!
 * Chai - test utility
 * Copyright(c) 2012-2013 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */</span>

<span class="comment">/*!
 * Module dependancies
 */</span>

<span class="keyword">var</span> flag = require(<span class="string">'./flag'</span>);

<span class="comment">/**
 * # test(object, expression)
 *
 * Test and object for expression.
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 */</span>

module.exports = <span class="function"><span class="keyword">function</span> <span class="params">(obj, args)</span> {</span>
  <span class="keyword">var</span> negate = flag(obj, <span class="string">'negate'</span>)
    , expr = args[<span class="number">0</span>];
  <span class="keyword">return</span> negate ? !expr : expr;
};

});
require.register(<span class="string">"chai/lib/chai/utils/transferFlags.js"</span>, <span class="keyword">function</span>(exports, require, module){
<span class="comment">/*!
 * Chai - transferFlags utility
 * Copyright(c) 2012-2013 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */</span>

<span class="comment">/**
 * ### transferFlags(assertion, object, includeAll = true)
 *
 * Transfer all the flags for `assertion` to `object`. If
 * `includeAll` is set to `false`, then the base Chai
 * assertion flags (namely `object`, `ssfi`, and `message`)
 * will not be transferred.
 *
 *
 *     var newAssertion = new Assertion();
 *     utils.transferFlags(assertion, newAssertion);
 *
 *     var anotherAsseriton = new Assertion(myObj);
 *     utils.transferFlags(assertion, anotherAssertion, false);
 *
 * @param {Assertion} assertion the assertion to transfer the flags from
 * @param {Object} object the object to transfer the flags too; usually a new assertion
 * @param {Boolean} includeAll
 * @name getAllFlags
 * @api private
 */</span>

module.exports = <span class="function"><span class="keyword">function</span> <span class="params">(assertion, object, includeAll)</span> {</span>
  <span class="keyword">var</span> flags = assertion.__flags || (assertion.__flags = Object.create(<span class="literal">null</span>));

  <span class="keyword">if</span> (!object.__flags) {
    object.__flags = Object.create(<span class="literal">null</span>);
  }

  includeAll = arguments.length === <span class="number">3</span> ? includeAll : <span class="literal">true</span>;

  <span class="keyword">for</span> (<span class="keyword">var</span> flag <span class="keyword">in</span> flags) {
    <span class="keyword">if</span> (includeAll ||
        (flag !== <span class="string">'object'</span> &amp;&amp; flag !== <span class="string">'ssfi'</span> &amp;&amp; flag != <span class="string">'message'</span>)) {
      object.__flags[flag] = flags[flag];
    }
  }
};

});
require.register(<span class="string">"chai/lib/chai/utils/type.js"</span>, <span class="keyword">function</span>(exports, require, module){
<span class="comment">/*!
 * Chai - type utility
 * Copyright(c) 2012-2013 Jake Luer &lt;jake@alogicalparadox.com&gt;
 * MIT Licensed
 */</span>

<span class="comment">/*!
 * Detectable javascript natives
 */</span>

<span class="keyword">var</span> natives = {
    <span class="string">'[object Arguments]'</span>: <span class="string">'arguments'</span>
  , <span class="string">'[object Array]'</span>: <span class="string">'array'</span>
  , <span class="string">'[object Date]'</span>: <span class="string">'date'</span>
  , <span class="string">'[object Function]'</span>: <span class="string">'function'</span>
  , <span class="string">'[object Number]'</span>: <span class="string">'number'</span>
  , <span class="string">'[object RegExp]'</span>: <span class="string">'regexp'</span>
  , <span class="string">'[object String]'</span>: <span class="string">'string'</span>
};

<span class="comment">/**
 * ### type(object)
 *
 * Better implementation of `typeof` detection that can
 * be used cross-browser. Handles the inconsistencies of
 * Array, `null`, and `undefined` detection.
 *
 *     utils.type({}) // 'object'
 *     utils.type(null) // `null'
 *     utils.type(undefined) // `undefined`
 *     utils.type([]) // `array`
 *
 * @param {Mixed} object to detect type of
 * @name type
 * @api private
 */</span>

module.exports = <span class="function"><span class="keyword">function</span> <span class="params">(obj)</span> {</span>
  <span class="keyword">var</span> str = Object.prototype.toString.call(obj);
  <span class="keyword">if</span> (natives[str]) <span class="keyword">return</span> natives[str];
  <span class="keyword">if</span> (obj === <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">'null'</span>;
  <span class="keyword">if</span> (obj === <span class="literal">undefined</span>) <span class="keyword">return</span> <span class="string">'undefined'</span>;
  <span class="keyword">if</span> (obj === Object(obj)) <span class="keyword">return</span> <span class="string">'object'</span>;
  <span class="keyword">return</span> <span class="keyword">typeof</span> obj;
};

});
require.alias(<span class="string">"chaijs-assertion-error/index.js"</span>, <span class="string">"chai/deps/assertion-error/index.js"</span>);
require.alias(<span class="string">"chaijs-assertion-error/index.js"</span>, <span class="string">"chai/deps/assertion-error/index.js"</span>);
require.alias(<span class="string">"chaijs-assertion-error/index.js"</span>, <span class="string">"assertion-error/index.js"</span>);
require.alias(<span class="string">"chaijs-assertion-error/index.js"</span>, <span class="string">"chaijs-assertion-error/index.js"</span>);

require.alias(<span class="string">"chai/index.js"</span>, <span class="string">"chai/index.js"</span>);

<span class="keyword">if</span> (<span class="keyword">typeof</span> exports == <span class="string">"object"</span>) {
  module.exports = require(<span class="string">"chai"</span>);
} <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> define == <span class="string">"function"</span> &amp;&amp; define.amd) {
  define(<span class="keyword">function</span>(){ <span class="keyword">return</span> require(<span class="string">"chai"</span>); });
} <span class="keyword">else</span> {
  <span class="keyword">this</span>[<span class="string">"chai"</span>] = require(<span class="string">"chai"</span>);
}})();</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
